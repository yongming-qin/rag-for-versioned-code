[
    {
        "name": "is_empty",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::ffi::c_str",
        "type": "method",
        "signature": "pub const fn is_empty(&self) -> bool",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"cstr_is_empty\", since = \"1.71.0\")]\n    pub const fn is_empty(&self) -> bool {\n        // SAFETY: We know there is at least one byte; for empty strings it\n        // is the NUL terminator.\n        // FIXME(const-hack): use get_unchecked\n        unsafe { *self.inner.as_ptr() == 0 }\n    }",
        "old_source_code": ""
    },
    {
        "name": "neg",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "impl Neg for NonZero<$Int>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "        impl Neg for NonZero<$Int> {\n            type Output = Self;\n\n            #[inline]\n            fn neg(self) -> Self {\n                // SAFETY: negation of nonzero cannot yield zero values.\n                unsafe { Self::new_unchecked(self.get().neg()) }\n            }\n        }",
        "old_source_code": "        impl Neg for $Ty {\n            type Output = Self;\n\n            #[inline]\n            fn neg(self) -> Self {\n                // SAFETY: negation of nonzero cannot yield zero values.\n                unsafe { Self::new_unchecked(self.get().neg()) }\n            }\n        }"
    },
    {
        "name": "div",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::ops::arith",
        "type": "method",
        "signature": "impl Div for $t",
        "change_type": "signature",
        "documentation": "",
        "source_code": "        impl Div for $t {\n            type Output = $t;\n\n            #[inline]\n            fn div(self, other: $t) -> $t { self / other }\n        }",
        "old_source_code": "        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n        impl const Div for $t {\n            type Output = $t;\n\n            #[inline]\n            fn div(self, other: $t) -> $t { self / other }\n        }"
    },
    {
        "name": "get_or_insert_with",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn get_or_insert_with<F>(&mut self, f: F) -> &mut T\n    where\n        F: FnOnce() -> T,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn get_or_insert_with<F>(&mut self, f: F) -> &mut T\n    where\n        F: FnOnce() -> T,\n    {\n        if let None = self {\n            *self = Some(f());\n        }\n\n        // SAFETY: a `None` variant for `self` would have been replaced by a `Some`\n        // variant in the code above.\n        unsafe { self.as_mut().unwrap_unchecked() }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n    pub const fn get_or_insert_with<F>(&mut self, f: F) -> &mut T\n    where\n        F: ~const FnOnce() -> T,\n        F: ~const Destruct,\n    {\n        if let None = *self {\n            // the compiler isn't smart enough to know that we are not dropping a `T`\n            // here and wants us to ensure `T` can be dropped at compile time.\n            mem::forget(mem::replace(self, Some(f())))\n        }\n\n        // SAFETY: a `None` variant for `self` would have been replaced by a `Some`\n        // variant in the code above.\n        unsafe { self.as_mut().unwrap_unchecked() }\n    }"
    },
    {
        "name": "from",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::num::error",
        "type": "function",
        "signature": "impl From<Infallible> for TryFromIntError",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl From<Infallible> for TryFromIntError {\n    fn from(x: Infallible) -> TryFromIntError {\n        match x {}\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\nimpl const From<Infallible> for TryFromIntError {\n    fn from(x: Infallible) -> TryFromIntError {\n        match x {}\n    }\n}"
    },
    {
        "name": "default",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::sync::atomic",
        "type": "function",
        "signature": "impl<T> Default for AtomicPtr<T>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<T> Default for AtomicPtr<T> {\n    /// Creates a null `AtomicPtr<T>`.\n    fn default() -> AtomicPtr<T> {\n        AtomicPtr::new(crate::ptr::null_mut())\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\nimpl<T> const Default for AtomicPtr<T> {\n    /// Creates a null `AtomicPtr<T>`.\n    fn default() -> AtomicPtr<T> {\n        AtomicPtr::new(crate::ptr::null_mut())\n    }\n}"
    },
    {
        "name": "index",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::slice::index",
        "type": "method",
        "signature": "impl<T, I> ops::Index<I> for [T]\nwhere\n    I: SliceIndex<[T]>,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<T, I> ops::Index<I> for [T]\nwhere\n    I: SliceIndex<[T]>,\n{\n    type Output = I::Output;\n\n    #[inline]\n    fn index(&self, index: I) -> &I::Output {\n        index.index(self)\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\nimpl<T, I> const ops::Index<I> for [T]\nwhere\n    I: ~const SliceIndex<[T]>,\n{\n    type Output = I::Output;\n\n    #[inline]\n    fn index(&self, index: I) -> &I::Output {\n        index.index(self)\n    }\n}"
    },
    {
        "name": "neg",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::ops::arith",
        "type": "method",
        "signature": "impl Neg for $t",
        "change_type": "signature",
        "documentation": "",
        "source_code": "        impl Neg for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn neg(self) -> $t { -self }\n        }",
        "old_source_code": "        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n        impl const Neg for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn neg(self) -> $t { -self }\n        }"
    },
    {
        "name": "and",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::result",
        "type": "method",
        "signature": "pub fn and<U>(self, res: Result<U, E>) -> Result<U, E>",
        "change_type": "signature",
        "documentation": "//////////////////////////////////////////////////////////////////////",
        "source_code": "    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n        match self {\n            Ok(_) => res,\n            Err(e) => Err(e),\n        }\n    }",
        "old_source_code": "    pub const fn and<U>(self, res: Result<U, E>) -> Result<U, E>\n    where\n        T: ~const Destruct,\n        U: ~const Destruct,\n        E: ~const Destruct,\n    {\n        match self {\n            // FIXME: ~const Drop doesn't quite work right yet\n            #[allow(unused_variables)]\n            Ok(x) => res,\n            Err(e) => Err(e),\n        }\n    }"
    },
    {
        "name": "add",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::ops::arith",
        "type": "method",
        "signature": "impl Add for $t",
        "change_type": "signature",
        "documentation": "",
        "source_code": "        impl Add for $t {\n            type Output = $t;\n\n            #[inline]\n            #[track_caller]\n            #[rustc_inherit_overflow_checks]\n            fn add(self, other: $t) -> $t { self + other }\n        }",
        "old_source_code": "        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n        impl const Add for $t {\n            type Output = $t;\n\n            #[inline]\n            #[track_caller]\n            #[rustc_inherit_overflow_checks]\n            fn add(self, other: $t) -> $t { self + other }\n        }"
    },
    {
        "name": "unwrap_or",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn unwrap_or(self, default: T) -> T",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn unwrap_or(self, default: T) -> T {\n        match self {\n            Some(x) => x,\n            None => default,\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n    pub const fn unwrap_or(self, default: T) -> T\n    where\n        T: ~const Destruct,\n    {\n        match self {\n            Some(x) => x,\n            None => default,\n        }\n    }"
    },
    {
        "name": "to_str",
        "from_version": "1.71.1",
        "to_version": "1.72.0",
        "module": "core::ffi::c_str",
        "type": "method",
        "signature": "pub const fn to_str(&self) -> Result<&str, str::Utf8Error>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_cstr_methods\", since = \"1.72.0\")]\n    pub const fn to_str(&self) -> Result<&str, str::Utf8Error> {\n        // N.B., when `CStr` is changed to perform the length check in `.to_bytes()`\n        // instead of in `from_ptr()`, it may be worth considering if this should\n        // be rewritten to do the UTF-8 check inline with the length calculation\n        // instead of doing it afterwards.\n        str::from_utf8(self.to_bytes())\n    }",
        "old_source_code": "    pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n        // N.B., when `CStr` is changed to perform the length check in `.to_bytes()`\n        // instead of in `from_ptr()`, it may be worth considering if this should\n        // be rewritten to do the UTF-8 check inline with the length calculation\n        // instead of doing it afterwards.\n        str::from_utf8(self.to_bytes())\n    }"
    },
    {
        "name": "then_some",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::bool",
        "type": "method",
        "signature": "pub fn then_some<T>(self, t: T) -> Option<T>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn then_some<T>(self, t: T) -> Option<T> {\n        if self { Some(t) } else { None }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_bool_to_option\", issue = \"91917\")]\n    #[inline]\n    pub const fn then_some<T>(self, t: T) -> Option<T>\n    where\n        T: ~const Destruct,\n    {\n        if self { Some(t) } else { None }\n    }"
    },
    {
        "name": "or_else",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn or_else<F>(self, f: F) -> Option<T>\n    where\n        F: FnOnce() -> Option<T>,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn or_else<F>(self, f: F) -> Option<T>\n    where\n        F: FnOnce() -> Option<T>,\n    {\n        match self {\n            Some(x) => Some(x),\n            None => f(),\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n    pub const fn or_else<F>(self, f: F) -> Option<T>\n    where\n        F: ~const FnOnce() -> Option<T>,\n        F: ~const Destruct,\n    {\n        match self {\n            Some(x) => Some(x),\n            None => f(),\n        }\n    }"
    },
    {
        "name": "hash_slice",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::hash",
        "type": "function",
        "signature": "fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n    where\n        Self: Sized,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n    where\n        Self: Sized,\n    {\n        for piece in data {\n            piece.hash(state)\n        }\n    }",
        "old_source_code": "    fn hash_slice<H: ~const Hasher>(data: &[Self], state: &mut H)\n    where\n        Self: Sized,\n    {\n        //FIXME(const_trait_impl): revert to only a for loop\n        fn rt<T: Hash, H: Hasher>(data: &[T], state: &mut H) {\n            for piece in data {\n                piece.hash(state)\n            }\n        }\n        const fn ct<T: ~const Hash, H: ~const Hasher>(data: &[T], state: &mut H) {\n            let mut i = 0;\n            while i < data.len() {\n                data[i].hash(state);\n                i += 1;\n            }\n        }\n        // SAFETY: same behavior, CT just uses while instead of for\n        unsafe { const_eval_select((data, state), ct, rt) };\n    }"
    },
    {
        "name": "unzip",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn unzip(self) -> (Option<T>, Option<U>)",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn unzip(self) -> (Option<T>, Option<U>) {\n        match self {\n            Some((a, b)) => (Some(a), Some(b)),\n            None => (None, None),\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n    pub const fn unzip(self) -> (Option<T>, Option<U>)\n    where\n        T: ~const Destruct,\n        U: ~const Destruct,\n    {\n        match self {\n            Some((a, b)) => (Some(a), Some(b)),\n            None => (None, None),\n        }\n    }"
    },
    {
        "name": "index",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::array",
        "type": "method",
        "signature": "impl<T, I, const N: usize> Index<I> for [T; N]\nwhere\n    [T]: Index<I>,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<T, I, const N: usize> Index<I> for [T; N]\nwhere\n    [T]: Index<I>,\n{\n    type Output = <[T] as Index<I>>::Output;\n\n    #[inline]\n    fn index(&self, index: I) -> &Self::Output {\n        Index::index(self as &[T], index)\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\nimpl<T, I, const N: usize> const Index<I> for [T; N]\nwhere\n    [T]: ~const Index<I>,\n{\n    type Output = <[T] as Index<I>>::Output;\n\n    #[inline]\n    fn index(&self, index: I) -> &Self::Output {\n        Index::index(self as &[T], index)\n    }\n}"
    },
    {
        "name": "xor",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn xor(self, optb: Option<T>) -> Option<T>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn xor(self, optb: Option<T>) -> Option<T> {\n        match (self, optb) {\n            (Some(a), None) => Some(a),\n            (None, Some(b)) => Some(b),\n            _ => None,\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n    pub const fn xor(self, optb: Option<T>) -> Option<T>\n    where\n        T: ~const Destruct,\n    {\n        match (self, optb) {\n            (Some(a), None) => Some(a),\n            (None, Some(b)) => Some(b),\n            _ => None,\n        }\n    }"
    },
    {
        "name": "default",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "alloc::string",
        "type": "function",
        "signature": "impl Default for String",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl Default for String {\n    /// Creates an empty `String`.\n    #[inline]\n    fn default() -> String {\n        String::new()\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\nimpl const Default for String {\n    /// Creates an empty `String`.\n    #[inline]\n    fn default() -> String {\n        String::new()\n    }\n}"
    },
    {
        "name": "div_f32",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::time",
        "type": "method",
        "signature": "without modifying the original\"]\n    pub fn div_f32(self, rhs: f32) -> Duration",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[must_use = \"this returns the result of the operation, \\\n                  without modifying the original\"]\n    #[inline]\n    pub fn div_f32(self, rhs: f32) -> Duration {\n        Duration::from_secs_f32(self.as_secs_f32() / rhs)\n    }",
        "old_source_code": "    #[must_use = \"this returns the result of the operation, \\\n                  without modifying the original\"]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n    pub const fn div_f32(self, rhs: f32) -> Duration {\n        Duration::from_secs_f32(self.as_secs_f32() / rhs)\n    }"
    },
    {
        "name": "read",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "std::ptr",
        "type": "function",
        "signature": "pub const unsafe fn read<T>(src: *const T) -> T",
        "change_type": "implicit",
        "documentation": "Reads the value from `src` without moving it. This leaves the\nmemory in `src` unchanged.\n\n# Safety\n\nBehavior is undefined if any of the following conditions are violated:\n\n* `src` must be [valid] for reads.\n\n* `src` must be properly aligned. Use [`read_unaligned`] if this is not the\ncase.\n\n* `src` must point to a properly initialized value of type `T`.\n\nNote that even if `T` has size `0`, the pointer must be non-null and properly aligned.\n",
        "examples": [
            "",
            "Basic usage:",
            "",
            "```",
            "let x = 12;",
            "let y = &x as *const i32;",
            "",
            "unsafe {",
            "assert_eq!(std::ptr::read(y), 12);",
            "}",
            "```",
            "",
            "Manually implement [`mem::swap`]:",
            "",
            "```",
            "use std::ptr;",
            "",
            "fn swap<T>(a: &mut T, b: &mut T) {",
            "unsafe {",
            "// Create a bitwise copy of the value at `a` in `tmp`.",
            "let tmp = ptr::read(a);",
            "",
            "// Exiting at this point (either by explicitly returning or by",
            "// calling a function which panics) would cause the value in `tmp` to",
            "// be dropped while the same value is still referenced by `a`. This",
            "// could trigger undefined behavior if `T` is not `Copy`.",
            "",
            "// Create a bitwise copy of the value at `b` in `a`.",
            "// This is safe because mutable references cannot alias.",
            "ptr::copy_nonoverlapping(b, a, 1);",
            "",
            "// As above, exiting here could trigger undefined behavior because",
            "// the same value is referenced by `a` and `b`.",
            "",
            "// Move `tmp` into `b`.",
            "ptr::write(b, tmp);",
            "",
            "// `tmp` has been moved (`write` takes ownership of its second argument),",
            "// so nothing is dropped implicitly here.",
            "}",
            "}",
            "",
            "let mut foo = \"foo\".to_owned();",
            "let mut bar = \"bar\".to_owned();",
            "",
            "swap(&mut foo, &mut bar);",
            "",
            "assert_eq!(foo, \"bar\");",
            "assert_eq!(bar, \"foo\");",
            "```",
            "",
            "## Ownership of the Returned Value",
            "",
            "`read` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].",
            "If `T` is not [`Copy`], using both the returned value and the value at",
            "`*src` can violate memory safety. Note that assigning to `*src` counts as a",
            "use because it will attempt to drop the value at `*src`.",
            "",
            "[`write()`] can be used to overwrite data without causing it to be dropped.",
            "",
            "```",
            "use std::ptr;",
            "",
            "let mut s = String::from(\"foo\");",
            "unsafe {",
            "// `s2` now points to the same underlying memory as `s`.",
            "let mut s2: String = ptr::read(&s);",
            "",
            "assert_eq!(s2, \"foo\");",
            "",
            "// Assigning to `s2` causes its original value to be dropped. Beyond",
            "// this point, `s` must no longer be used, as the underlying memory has",
            "// been freed.",
            "s2 = String::default();",
            "assert_eq!(s2, \"\");",
            "",
            "// Assigning to `s` would cause the old value to be dropped again,",
            "// resulting in undefined behavior.",
            "// s = String::from(\"bar\"); // ERROR",
            "",
            "// `ptr::write` can be used to overwrite a value without dropping it.",
            "ptr::write(&mut s, String::from(\"bar\"));",
            "}",
            "",
            "assert_eq!(s, \"bar\");",
            "```",
            "",
            "[valid]: self#safety"
        ],
        "source_code": "#[rustc_const_stable(feature = \"const_ptr_read\", since = \"1.71.0\")]\n#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n#[rustc_diagnostic_item = \"ptr_read\"]\npub const unsafe fn read<T>(src: *const T) -> T {\n    // It would be semantically correct to implement this via `copy_nonoverlapping`\n    // and `MaybeUninit`, as was done before PR #109035. Calling `assume_init`\n    // provides enough information to know that this is a typed operation.\n\n    // However, as of March 2023 the compiler was not capable of taking advantage\n    // of that information.  Thus the implementation here switched to an intrinsic,\n    // which lowers to `_0 = *src` in MIR, to address a few issues:\n    //\n    // - Using `MaybeUninit::assume_init` after a `copy_nonoverlapping` was not\n    //   turning the untyped copy into a typed load. As such, the generated\n    //   `load` in LLVM didn't get various metadata, such as `!range` (#73258),\n    //   `!nonnull`, and `!noundef`, resulting in poorer optimization.\n    // - Going through the extra local resulted in multiple extra copies, even\n    //   in optimized MIR.  (Ignoring StorageLive/Dead, the intrinsic is one\n    //   MIR statement, while the previous implementation was eight.)  LLVM\n    //   could sometimes optimize them away, but because `read` is at the core\n    //   of so many things, not having them in the first place improves what we\n    //   hand off to the backend.  For example, `mem::replace::<Big>` previously\n    //   emitted 4 `alloca` and 6 `memcpy`s, but is now 1 `alloc` and 3 `memcpy`s.\n    // - In general, this approach keeps us from getting any more bugs (like\n    //   #106369) that boil down to \"`read(p)` is worse than `*p`\", as this\n    //   makes them look identical to the backend (or other MIR consumers).\n    //\n    // Future enhancements to MIR optimizations might well allow this to return\n    // to the previous implementation, rather than using an intrinsic.\n\n    // SAFETY: the caller must guarantee that `src` is valid for reads.\n    unsafe {\n        #[cfg(debug_assertions)] // Too expensive to always enable (for now?)\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::read requires that the pointer argument is aligned and non-null\",\n            (\n                addr: *const () = src as *const (),\n                align: usize = align_of::<T>(),\n            ) => is_aligned_and_not_null(addr, align)\n        );\n        crate::intrinsics::read_via_copy(src)\n    }\n}",
        "old_source_code": "#[rustc_const_stable(feature = \"const_ptr_read\", since = \"1.71.0\")]\n#[rustc_allow_const_fn_unstable(const_mut_refs, const_maybe_uninit_as_mut_ptr)]\n#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n#[rustc_diagnostic_item = \"ptr_read\"]\npub const unsafe fn read<T>(src: *const T) -> T {\n    // It would be semantically correct to implement this via `copy_nonoverlapping`\n    // and `MaybeUninit`, as was done before PR #109035. Calling `assume_init`\n    // provides enough information to know that this is a typed operation.\n\n    // However, as of March 2023 the compiler was not capable of taking advantage\n    // of that information.  Thus the implementation here switched to an intrinsic,\n    // which lowers to `_0 = *src` in MIR, to address a few issues:\n    //\n    // - Using `MaybeUninit::assume_init` after a `copy_nonoverlapping` was not\n    //   turning the untyped copy into a typed load. As such, the generated\n    //   `load` in LLVM didn't get various metadata, such as `!range` (#73258),\n    //   `!nonnull`, and `!noundef`, resulting in poorer optimization.\n    // - Going through the extra local resulted in multiple extra copies, even\n    //   in optimized MIR.  (Ignoring StorageLive/Dead, the intrinsic is one\n    //   MIR statement, while the previous implementation was eight.)  LLVM\n    //   could sometimes optimize them away, but because `read` is at the core\n    //   of so many things, not having them in the first place improves what we\n    //   hand off to the backend.  For example, `mem::replace::<Big>` previously\n    //   emitted 4 `alloca` and 6 `memcpy`s, but is now 1 `alloc` and 3 `memcpy`s.\n    // - In general, this approach keeps us from getting any more bugs (like\n    //   #106369) that boil down to \"`read(p)` is worse than `*p`\", as this\n    //   makes them look identical to the backend (or other MIR consumers).\n    //\n    // Future enhancements to MIR optimizations might well allow this to return\n    // to the previous implementation, rather than using an intrinsic.\n\n    // SAFETY: the caller must guarantee that `src` is valid for reads.\n    unsafe {\n        assert_unsafe_precondition!(\n            \"ptr::read requires that the pointer argument is aligned and non-null\",\n            [T](src: *const T) => is_aligned_and_not_null(src)\n        );\n        crate::intrinsics::read_via_copy(src)\n    }\n}"
    },
    {
        "name": "clone",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::clone",
        "type": "method",
        "signature": "impl<T: ?Sized> Clone for &T",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    impl<T: ?Sized> Clone for &T {\n        #[inline(always)]\n        #[rustc_diagnostic_item = \"noop_method_clone\"]\n        fn clone(&self) -> Self {\n            *self\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n    impl<T: ?Sized> const Clone for &T {\n        #[inline(always)]\n        #[rustc_diagnostic_item = \"noop_method_clone\"]\n        fn clone(&self) -> Self {\n            *self\n        }\n    }"
    },
    {
        "name": "partial_cmp",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::tuple",
        "type": "method",
        "signature": "impl<$($T: PartialOrd),+> PartialOrd for ($($T,)+)\n            where\n                last_type!($($T,)+): ?Sized",
        "change_type": "signature",
        "documentation": "",
        "source_code": "            impl<$($T: PartialOrd),+> PartialOrd for ($($T,)+)\n            where\n                last_type!($($T,)+): ?Sized\n            {\n                #[inline]\n                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n                    lexical_partial_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn lt(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(lt, Less, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn le(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(le, Less, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn ge(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(ge, Greater, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn gt(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(gt, Greater, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n                }\n            }",
        "old_source_code": "            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n            impl<$($T: ~const PartialOrd + ~const PartialEq),+> const PartialOrd for ($($T,)+)\n            where\n                last_type!($($T,)+): ?Sized\n            {\n                #[inline]\n                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n                    lexical_partial_cmp!($( ${ignore(T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn lt(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(lt, Less, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn le(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(le, Less, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn ge(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(ge, Greater, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n                }\n                #[inline]\n                fn gt(&self, other: &($($T,)+)) -> bool {\n                    lexical_ord!(gt, Greater, $( ${ignore(T)} self.${index()}, other.${index()} ),+)\n                }\n            }"
    },
    {
        "name": "filter",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn filter<P>(self, predicate: P) -> Self\n    where\n        P: FnOnce(&T) -> bool,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn filter<P>(self, predicate: P) -> Self\n    where\n        P: FnOnce(&T) -> bool,\n    {\n        if let Some(x) = self {\n            if predicate(&x) {\n                return Some(x);\n            }\n        }\n        None\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n    pub const fn filter<P>(self, predicate: P) -> Self\n    where\n        T: ~const Destruct,\n        P: ~const FnOnce(&T) -> bool,\n        P: ~const Destruct,\n    {\n        if let Some(x) = self {\n            if predicate(&x) {\n                return Some(x);\n            }\n        }\n        None\n    }"
    },
    {
        "name": "zip",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)> {\n        match (self, other) {\n            (Some(a), Some(b)) => Some((a, b)),\n            _ => None,\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n    pub const fn zip<U>(self, other: Option<U>) -> Option<(T, U)>\n    where\n        T: ~const Destruct,\n        U: ~const Destruct,\n    {\n        match (self, other) {\n            (Some(a), Some(b)) => Some((a, b)),\n            _ => None,\n        }\n    }"
    },
    {
        "name": "max_by_key",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::cmp",
        "type": "function",
        "signature": "pub fn max_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T",
        "change_type": "signature",
        "documentation": "",
        "source_code": "pub fn max_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n    max_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\npub const fn max_by_key<T, F: ~const FnMut(&T) -> K, K: ~const Ord>(v1: T, v2: T, mut f: F) -> T\nwhere\n    T: ~const Destruct,\n    F: ~const Destruct,\n    K: ~const Destruct,\n{\n    max_by(v1, v2, const |v1, v2| f(v1).cmp(&f(v2)))\n}"
    },
    {
        "name": "get_mut",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n        i.get_mut(self)\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n    #[inline]\n    pub const fn get_mut<I: ~const SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n        i.get_mut(self)\n    }"
    },
    {
        "name": "clone",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::ptr::non_null",
        "type": "method",
        "signature": "impl<T: ?Sized> Clone for NonNull<T>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<T: ?Sized> Clone for NonNull<T> {\n    #[inline(always)]\n    fn clone(&self) -> Self {\n        *self\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\nimpl<T: ?Sized> const Clone for NonNull<T> {\n    #[inline(always)]\n    fn clone(&self) -> Self {\n        *self\n    }\n}"
    },
    {
        "name": "add",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::ptr::mut_ptr",
        "type": "method",
        "signature": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n    #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n    #[inline(always)]\n    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n    pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            #[inline]\n            fn runtime(this: *const (), count: usize, size: usize) -> bool {\n                let Some(byte_offset) = count.checked_mul(size) else {\n                    return false;\n                };\n                let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                byte_offset <= (isize::MAX as usize) && !overflow\n            }\n\n            const fn comptime(_: *const (), _: usize, _: usize) -> bool {\n                true\n            }\n\n            intrinsics::const_eval_select((this, count, size), comptime, runtime)\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
        "old_source_code": "    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n    #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n    #[inline(always)]\n    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n    pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }"
    },
    {
        "name": "err",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::result",
        "type": "method",
        "signature": "pub fn err(self) -> Option<E>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn err(self) -> Option<E> {\n        match self {\n            Ok(_) => None,\n            Err(x) => Some(x),\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_result_drop\", issue = \"92384\")]\n    pub const fn err(self) -> Option<E>\n    where\n        T: ~const Destruct,\n    {\n        match self {\n            // FIXME: ~const Drop doesn't quite work right yet\n            #[allow(unused_variables)]\n            Ok(x) => None,\n            Err(x) => Some(x),\n        }\n    }"
    },
    {
        "name": "get_or_insert",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn get_or_insert(&mut self, value: T) -> &mut T",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn get_or_insert(&mut self, value: T) -> &mut T {\n        self.get_or_insert_with(|| value)\n    }",
        "old_source_code": "    pub fn get_or_insert(&mut self, value: T) -> &mut T {\n        if let None = *self {\n            *self = Some(value);\n        }\n\n        // SAFETY: a `None` variant for `self` would have been replaced by a `Some`\n        // variant in the code above.\n        unsafe { self.as_mut().unwrap_unchecked() }\n    }"
    },
    {
        "name": "from",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::sync::atomic",
        "type": "function",
        "signature": "impl<T> From<*mut T> for AtomicPtr<T>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<T> From<*mut T> for AtomicPtr<T> {\n    /// Converts a `*mut T` into an `AtomicPtr<T>`.\n    #[inline]\n    fn from(p: *mut T) -> Self {\n        Self::new(p)\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\nimpl<T> const From<*mut T> for AtomicPtr<T> {\n    /// Converts a `*mut T` into an `AtomicPtr<T>`.\n    #[inline]\n    fn from(p: *mut T) -> Self {\n        Self::new(p)\n    }\n}"
    },
    {
        "name": "clear",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "alloc::collections::linked_list",
        "type": "method",
        "signature": "pub fn clear(&mut self)",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn clear(&mut self) {\n        // We need to drop the nodes while keeping self.alloc\n        // We can do this by moving (head, tail, len) into a new list that borrows self.alloc\n        drop(LinkedList {\n            head: self.head.take(),\n            tail: self.tail.take(),\n            len: mem::take(&mut self.len),\n            alloc: &self.alloc,\n            marker: PhantomData,\n        });\n    }",
        "old_source_code": "    pub fn clear(&mut self) {\n        *self = Self::new();\n    }"
    },
    {
        "name": "div_f64",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::time",
        "type": "method",
        "signature": "without modifying the original\"]\n    pub fn div_f64(self, rhs: f64) -> Duration",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[must_use = \"this returns the result of the operation, \\\n                  without modifying the original\"]\n    #[inline]\n    pub fn div_f64(self, rhs: f64) -> Duration {\n        Duration::from_secs_f64(self.as_secs_f64() / rhs)\n    }",
        "old_source_code": "    #[must_use = \"this returns the result of the operation, \\\n                  without modifying the original\"]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n    pub const fn div_f64(self, rhs: f64) -> Duration {\n        Duration::from_secs_f64(self.as_secs_f64() / rhs)\n    }"
    },
    {
        "name": "and_then",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn and_then<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> Option<U>,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn and_then<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> Option<U>,\n    {\n        match self {\n            Some(x) => f(x),\n            None => None,\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n    pub const fn and_then<U, F>(self, f: F) -> Option<U>\n    where\n        F: ~const FnOnce(T) -> Option<U>,\n        F: ~const Destruct,\n    {\n        match self {\n            Some(x) => f(x),\n            None => None,\n        }\n    }"
    },
    {
        "name": "map",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn map<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> U,",
        "change_type": "signature",
        "documentation": "//////////////////////////////////////////////////////////////////////",
        "source_code": "    pub fn map<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n    pub const fn map<U, F>(self, f: F) -> Option<U>\n    where\n        F: ~const FnOnce(T) -> U,\n        F: ~const Destruct,\n    {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }"
    },
    {
        "name": "len",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "core::char",
        "type": "method",
        "signature": "impl ExactSizeIterator for $ITER_NAME",
        "change_type": "signature",
        "documentation": "",
        "source_code": "        impl ExactSizeIterator for $ITER_NAME {\n            fn len(&self) -> usize {\n                self.0.len()\n            }\n\n            fn is_empty(&self) -> bool {\n                self.0.is_empty()\n            }\n        }",
        "old_source_code": "impl ExactSizeIterator for EscapeDebug {\n    fn len(&self) -> usize {\n        match &self.0 {\n            EscapeDebugInner::Bytes(bytes) => bytes.len(),\n            EscapeDebugInner::Char(_) => 1,\n        }\n    }\n}"
    },
    {
        "name": "is_ascii",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::num",
        "type": "method",
        "signature": "pub const fn is_ascii(&self) -> bool",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_u8_is_ascii\", since = \"1.43.0\")]\n    #[inline]\n    pub const fn is_ascii(&self) -> bool {\n        *self <= 127\n    }",
        "old_source_code": "    #[rustc_const_stable(feature = \"const_u8_is_ascii\", since = \"1.43.0\")]\n    #[inline]\n    pub const fn is_ascii(&self) -> bool {\n        *self & 128 == 0\n    }"
    },
    {
        "name": "clone_from",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::clone",
        "type": "method",
        "signature": "fn clone_from(&mut self, source: &Self)",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    fn clone_from(&mut self, source: &Self) {\n        *self = source.clone()\n    }",
        "old_source_code": "    fn clone_from(&mut self, source: &Self)\n    where\n        Self: ~const Destruct,\n    {\n        *self = source.clone()\n    }"
    },
    {
        "name": "default",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "alloc::boxed",
        "type": "function",
        "signature": "impl Default for Box<str>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl Default for Box<str> {\n    #[inline]\n    fn default() -> Self {\n        // SAFETY: This is the same as `Unique::cast<U>` but with an unsized `U = str`.\n        let ptr: Unique<str> = unsafe {\n            let bytes: Unique<[u8]> = Unique::<[u8; 0]>::dangling();\n            Unique::new_unchecked(bytes.as_ptr() as *mut str)\n        };\n        Box(ptr, Global)\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\nimpl const Default for Box<str> {\n    #[inline]\n    fn default() -> Self {\n        // SAFETY: This is the same as `Unique::cast<U>` but with an unsized `U = str`.\n        let ptr: Unique<str> = unsafe {\n            let bytes: Unique<[u8]> = Unique::<[u8; 0]>::dangling();\n            Unique::new_unchecked(bytes.as_ptr() as *mut str)\n        };\n        Box(ptr, Global)\n    }\n}"
    },
    {
        "name": "default",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::marker",
        "type": "function",
        "signature": "impl<T: ?Sized> Default for PhantomData<T>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<T: ?Sized> Default for PhantomData<T> {\n    fn default() -> Self {\n        Self\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\nimpl<T: ?Sized> const Default for PhantomData<T> {\n    fn default() -> Self {\n        Self\n    }\n}"
    },
    {
        "name": "unwrap_or_default",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn unwrap_or_default(self) -> T\n    where\n        T: Default,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn unwrap_or_default(self) -> T\n    where\n        T: Default,\n    {\n        match self {\n            Some(x) => x,\n            None => T::default(),\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n    pub const fn unwrap_or_default(self) -> T\n    where\n        T: ~const Default,\n    {\n        match self {\n            Some(x) => x,\n            None => Default::default(),\n        }\n    }"
    },
    {
        "name": "into_iter",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::iter::traits::collect",
        "type": "method",
        "signature": "impl<I: Iterator> IntoIterator for I",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<I: Iterator> IntoIterator for I {\n    type Item = I::Item;\n    type IntoIter = I;\n\n    #[inline]\n    fn into_iter(self) -> I {\n        self\n    }\n}",
        "old_source_code": "impl<I: Iterator> const IntoIterator for I {\n    type Item = I::Item;\n    type IntoIter = I;\n\n    #[inline]\n    fn into_iter(self) -> I {\n        self\n    }\n}"
    },
    {
        "name": "from",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::char::convert",
        "type": "function",
        "signature": "impl From<u8> for char",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl From<u8> for char {\n    /// Converts a [`u8`] into a [`char`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::mem;\n    ///\n    /// let u = 32 as u8;\n    /// let c = char::from(u);\n    /// assert!(4 == mem::size_of_val(&c))\n    /// ```\n    #[inline]\n    fn from(i: u8) -> Self {\n        i as char\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\nimpl const From<u8> for char {\n    /// Converts a [`u8`] into a [`char`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::mem;\n    ///\n    /// let u = 32 as u8;\n    /// let c = char::from(u);\n    /// assert!(4 == mem::size_of_val(&c))\n    /// ```\n    #[inline]\n    fn from(i: u8) -> Self {\n        i as char\n    }\n}"
    },
    {
        "name": "bitor",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::num::wrapping",
        "type": "method",
        "signature": "impl BitOr for Wrapping<$t>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "        impl BitOr for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                Wrapping(self.0 | other.0)\n            }\n        }",
        "old_source_code": "        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n        impl const BitOr for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                Wrapping(self.0 | other.0)\n            }\n        }"
    },
    {
        "name": "max_by",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::cmp",
        "type": "function",
        "signature": "pub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T",
        "change_type": "signature",
        "documentation": "",
        "source_code": "pub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n    match compare(&v1, &v2) {\n        Ordering::Less | Ordering::Equal => v2,\n        Ordering::Greater => v1,\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\npub const fn max_by<T, F: ~const FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T\nwhere\n    T: ~const Destruct,\n    F: ~const Destruct,\n{\n    match compare(&v1, &v2) {\n        Ordering::Less | Ordering::Equal => v2,\n        Ordering::Greater => v1,\n    }\n}"
    },
    {
        "name": "next",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::iter::adapters::filter",
        "type": "method",
        "signature": "impl<I: Iterator, P> Iterator for Filter<I, P>\nwhere\n    P: FnMut(&I::Item) -> bool,",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl<I: Iterator, P> Iterator for Filter<I, P>\nwhere\n    P: FnMut(&I::Item) -> bool,\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        self.iter.find(&mut self.predicate)\n    }\n\n    #[inline]\n    fn next_chunk<const N: usize>(\n        &mut self,\n    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>> {\n        // avoid codegen for the dead branch\n        let fun = const {\n            if crate::mem::needs_drop::<I::Item>() {\n                array::iter_next_chunk::<I::Item, N>\n            } else {\n                Self::next_chunk_dropless::<N>\n            }\n        };\n\n        fun(self)\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, upper) = self.iter.size_hint();\n        (0, upper) // can't know a lower bound, due to the predicate\n    }\n\n    // this special case allows the compiler to make `.filter(_).count()`\n    // branchless. Barring perfect branch prediction (which is unattainable in\n    // the general case), this will be much faster in >90% of cases (containing\n    // virtually all real workloads) and only a tiny bit slower in the rest.\n    //\n    // Having this specialization thus allows us to write `.filter(p).count()`\n    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is\n    // less readable and also less backwards-compatible to Rust before 1.10.\n    //\n    // Using the branchless version will also simplify the LLVM byte code, thus\n    // leaving more budget for LLVM optimizations.\n    #[inline]\n    fn count(self) -> usize {\n        #[inline]\n        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n            move |x| predicate(&x) as usize\n        }\n\n        self.iter.map(to_usize(self.predicate)).sum()\n    }\n\n    #[inline]\n    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n    where\n        Self: Sized,\n        Fold: FnMut(Acc, Self::Item) -> R,\n        R: Try<Output = Acc>,\n    {\n        self.iter.try_fold(init, filter_try_fold(&mut self.predicate, fold))\n    }\n\n    #[inline]\n    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n    where\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.iter.fold(init, filter_fold(self.predicate, fold))\n    }\n}",
        "old_source_code": "impl<I: Iterator, P> Iterator for Filter<I, P>\nwhere\n    P: FnMut(&I::Item) -> bool,\n{\n    type Item = I::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<I::Item> {\n        self.iter.find(&mut self.predicate)\n    }\n\n    #[inline]\n    fn next_chunk<const N: usize>(\n        &mut self,\n    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>> {\n        let mut array: [MaybeUninit<Self::Item>; N] = MaybeUninit::uninit_array();\n\n        struct Guard<'a, T> {\n            array: &'a mut [MaybeUninit<T>],\n            initialized: usize,\n        }\n\n        impl<T> Drop for Guard<'_, T> {\n            #[inline]\n            fn drop(&mut self) {\n                if const { crate::mem::needs_drop::<T>() } {\n                    // SAFETY: self.initialized is always <= N, which also is the length of the array.\n                    unsafe {\n                        core::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(\n                            self.array.get_unchecked_mut(..self.initialized),\n                        ));\n                    }\n                }\n            }\n        }\n\n        let mut guard = Guard { array: &mut array, initialized: 0 };\n\n        let result = self.iter.try_for_each(|element| {\n            let idx = guard.initialized;\n            guard.initialized = idx + (self.predicate)(&element) as usize;\n\n            // SAFETY: Loop conditions ensure the index is in bounds.\n            unsafe { guard.array.get_unchecked_mut(idx) }.write(element);\n\n            if guard.initialized < N { ControlFlow::Continue(()) } else { ControlFlow::Break(()) }\n        });\n\n        let guard = ManuallyDrop::new(guard);\n\n        match result {\n            ControlFlow::Break(()) => {\n                // SAFETY: The loop above is only explicitly broken when the array has been fully initialized\n                Ok(unsafe { MaybeUninit::array_assume_init(array) })\n            }\n            ControlFlow::Continue(()) => {\n                let initialized = guard.initialized;\n                // SAFETY: The range is in bounds since the loop breaks when reaching N elements.\n                Err(unsafe { array::IntoIter::new_unchecked(array, 0..initialized) })\n            }\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (_, upper) = self.iter.size_hint();\n        (0, upper) // can't know a lower bound, due to the predicate\n    }\n\n    // this special case allows the compiler to make `.filter(_).count()`\n    // branchless. Barring perfect branch prediction (which is unattainable in\n    // the general case), this will be much faster in >90% of cases (containing\n    // virtually all real workloads) and only a tiny bit slower in the rest.\n    //\n    // Having this specialization thus allows us to write `.filter(p).count()`\n    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is\n    // less readable and also less backwards-compatible to Rust before 1.10.\n    //\n    // Using the branchless version will also simplify the LLVM byte code, thus\n    // leaving more budget for LLVM optimizations.\n    #[inline]\n    fn count(self) -> usize {\n        #[inline]\n        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n            move |x| predicate(&x) as usize\n        }\n\n        self.iter.map(to_usize(self.predicate)).sum()\n    }\n\n    #[inline]\n    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n    where\n        Self: Sized,\n        Fold: FnMut(Acc, Self::Item) -> R,\n        R: Try<Output = Acc>,\n    {\n        self.iter.try_fold(init, filter_try_fold(&mut self.predicate, fold))\n    }\n\n    #[inline]\n    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n    where\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.iter.fold(init, filter_fold(self.predicate, fold))\n    }\n}"
    },
    {
        "name": "default",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "alloc::vec",
        "type": "function",
        "signature": "impl<T> Default for Vec<T>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<T> Default for Vec<T> {\n    /// Creates an empty `Vec<T>`.\n    ///\n    /// The vector will not allocate until elements are pushed onto it.\n    fn default() -> Vec<T> {\n        Vec::new()\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\nimpl<T> const Default for Vec<T> {\n    /// Creates an empty `Vec<T>`.\n    ///\n    /// The vector will not allocate until elements are pushed onto it.\n    fn default() -> Vec<T> {\n        Vec::new()\n    }\n}"
    },
    {
        "name": "push_back",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "alloc::collections::linked_list",
        "type": "method",
        "signature": "pub fn push_back(&mut self, elt: T)",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn push_back(&mut self, elt: T) {\n        let node = Box::new_in(Node::new(elt), &self.alloc);\n        let node_ptr = Unique::from(Box::leak(node));\n        // SAFETY: node_ptr is a unique pointer to a node we boxed with self.alloc\n        unsafe {\n            self.push_back_node(node_ptr);\n        }\n    }",
        "old_source_code": "    pub fn push_back(&mut self, elt: T) {\n        self.push_back_node(Box::new(Node::new(elt)));\n    }"
    },
    {
        "name": "then",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::bool",
        "type": "method",
        "signature": "pub fn then<T, F: FnOnce() -> T>(self, f: F) -> Option<T>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn then<T, F: FnOnce() -> T>(self, f: F) -> Option<T> {\n        if self { Some(f()) } else { None }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_bool_to_option\", issue = \"91917\")]\n    #[inline]\n    pub const fn then<T, F>(self, f: F) -> Option<T>\n    where\n        F: ~const FnOnce() -> T,\n        F: ~const Destruct,\n    {\n        if self { Some(f()) } else { None }\n    }"
    },
    {
        "name": "signum",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::num::int_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn signum(self) -> Self",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"const_int_sign\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn signum(self) -> Self {\n            // Picking the right way to phrase this is complicated\n            // (<https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign>)\n            // so delegate it to `Ord` which is already producing -1/0/+1\n            // exactly like we need and can be the place to deal with the complexity.\n\n            // FIXME(const-hack): replace with cmp\n            if self < 0 { -1 }\n            else if self == 0 { 0 }\n            else { 1 }\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"const_int_sign\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[rustc_allow_const_fn_unstable(const_cmp)]\n        pub const fn signum(self) -> Self {\n            // Picking the right way to phrase this is complicated\n            // (<https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign>)\n            // so delegate it to `Ord` which is already producing -1/0/+1\n            // exactly like we need and can be the place to deal with the complexity.\n            self.cmp(&0) as _\n        }"
    },
    {
        "name": "escape_unicode",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::char::methods",
        "type": "method",
        "signature": "pub fn escape_unicode(self) -> EscapeUnicode",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn escape_unicode(self) -> EscapeUnicode {\n        EscapeUnicode::new(self)\n    }",
        "old_source_code": "    #[inline]\n    pub fn escape_unicode(self) -> EscapeUnicode {\n        let c = self as u32;\n\n        // or-ing 1 ensures that for c==0 the code computes that one\n        // digit should be printed and (which is the same) avoids the\n        // (31 - 32) underflow\n        let msb = 31 - (c | 1).leading_zeros();\n\n        // the index of the most significant hex digit\n        let ms_hex_digit = msb / 4;\n        EscapeUnicode {\n            c: self,\n            state: EscapeUnicodeState::Backslash,\n            hex_digit_idx: ms_hex_digit as usize,\n        }\n    }"
    },
    {
        "name": "bitxor",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::ops::bit",
        "type": "method",
        "signature": "impl BitXor for $t",
        "change_type": "signature",
        "documentation": "",
        "source_code": "        impl BitXor for $t {\n            type Output = $t;\n\n            #[inline]\n            fn bitxor(self, other: $t) -> $t { self ^ other }\n        }",
        "old_source_code": "        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n        impl const BitXor for $t {\n            type Output = $t;\n\n            #[inline]\n            fn bitxor(self, other: $t) -> $t { self ^ other }\n        }"
    },
    {
        "name": "clone",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::convert",
        "type": "method",
        "signature": "impl Clone for Infallible",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl Clone for Infallible {\n    fn clone(&self) -> Infallible {\n        match *self {}\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\nimpl const Clone for Infallible {\n    fn clone(&self) -> Infallible {\n        match *self {}\n    }\n}"
    },
    {
        "name": "from",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::cell",
        "type": "function",
        "signature": "impl<T> From<T> for UnsafeCell<T>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<T> From<T> for UnsafeCell<T> {\n    /// Creates a new `UnsafeCell<T>` containing the given value.\n    fn from(t: T) -> UnsafeCell<T> {\n        UnsafeCell::new(t)\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\nimpl<T> const From<T> for UnsafeCell<T> {\n    /// Creates a new `UnsafeCell<T>` containing the given value.\n    fn from(t: T) -> UnsafeCell<T> {\n        UnsafeCell::new(t)\n    }\n}"
    },
    {
        "name": "next",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::ascii",
        "type": "method",
        "signature": "impl Iterator for EscapeDefault",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl Iterator for EscapeDefault {\n    type Item = u8;\n\n    #[inline]\n    fn next(&mut self) -> Option<u8> {\n        self.0.next()\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.0.len();\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.0.len()\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<u8> {\n        self.0.next_back()\n    }\n\n    #[inline]\n    fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n        self.0.advance_by(n)\n    }\n}",
        "old_source_code": "impl Iterator for EscapeDefault {\n    type Item = u8;\n\n    #[inline]\n    fn next(&mut self) -> Option<u8> {\n        self.range.next().map(|i| self.data[i as usize])\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.range.size_hint()\n    }\n    fn last(mut self) -> Option<u8> {\n        self.next_back()\n    }\n}"
    },
    {
        "name": "write",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "std::io::impls",
        "type": "method",
        "signature": "impl<A: Allocator> Write for VecDeque<u8, A>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl<A: Allocator> Write for VecDeque<u8, A> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.extend(buf);\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        let len = bufs.iter().map(|b| b.len()).sum();\n        self.reserve(len);\n        for buf in bufs {\n            self.extend(&**buf);\n        }\n        Ok(len)\n    }\n\n    #[inline]\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.extend(buf);\n        Ok(())\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}",
        "old_source_code": "impl<A: Allocator> Write for VecDeque<u8, A> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        self.extend(buf);\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        self.extend(buf);\n        Ok(())\n    }\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n        Ok(())\n    }\n}"
    },
    {
        "name": "min_by_key",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::cmp",
        "type": "function",
        "signature": "pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T",
        "change_type": "signature",
        "documentation": "",
        "source_code": "pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n    min_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\npub const fn min_by_key<T, F: ~const FnMut(&T) -> K, K: ~const Ord>(v1: T, v2: T, mut f: F) -> T\nwhere\n    T: ~const Destruct,\n    F: ~const Destruct,\n    K: ~const Destruct,\n{\n    min_by(v1, v2, const |v1, v2| f(v1).cmp(&f(v2)))\n}"
    },
    {
        "name": "from",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::cell::once",
        "type": "function",
        "signature": "impl<T> From<T> for OnceCell<T>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<T> From<T> for OnceCell<T> {\n    /// Creates a new `OnceCell<T>` which already contains the given `value`.\n    #[inline]\n    fn from(value: T) -> Self {\n        OnceCell { inner: UnsafeCell::new(Some(value)) }\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\nimpl<T> const From<T> for OnceCell<T> {\n    /// Creates a new `OnceCell<T>` which already contains the given `value`.\n    #[inline]\n    fn from(value: T) -> Self {\n        OnceCell { inner: UnsafeCell::new(Some(value)) }\n    }\n}"
    },
    {
        "name": "ok_or_else",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E>\n    where\n        F: FnOnce() -> E,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn ok_or_else<E, F>(self, err: F) -> Result<T, E>\n    where\n        F: FnOnce() -> E,\n    {\n        match self {\n            Some(v) => Ok(v),\n            None => Err(err()),\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n    pub const fn ok_or_else<E, F>(self, err: F) -> Result<T, E>\n    where\n        F: ~const FnOnce() -> E,\n        F: ~const Destruct,\n    {\n        match self {\n            Some(v) => Ok(v),\n            None => Err(err()),\n        }\n    }"
    },
    {
        "name": "insert",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn insert(&mut self, value: T) -> &mut T",
        "change_type": "signature",
        "documentation": "//////////////////////////////////////////////////////////////////////",
        "source_code": "    pub fn insert(&mut self, value: T) -> &mut T {\n        *self = Some(value);\n\n        // SAFETY: the code above just filled the option\n        unsafe { self.as_mut().unwrap_unchecked() }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n    pub const fn insert(&mut self, value: T) -> &mut T\n    where\n        T: ~const Destruct,\n    {\n        *self = Some(value);\n\n        // SAFETY: the code above just filled the option\n        unsafe { self.as_mut().unwrap_unchecked() }\n    }"
    },
    {
        "name": "get",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub fn get<I>(&self, index: I) -> Option<&I::Output>\n    where\n        I: SliceIndex<Self>,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[inline]\n    #[must_use]\n    pub fn get<I>(&self, index: I) -> Option<&I::Output>\n    where\n        I: SliceIndex<Self>,\n    {\n        index.get(self)\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n    #[inline]\n    #[must_use]\n    pub const fn get<I>(&self, index: I) -> Option<&I::Output>\n    where\n        I: ~const SliceIndex<Self>,\n    {\n        index.get(self)\n    }"
    },
    {
        "name": "leak",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "alloc::boxed",
        "type": "function",
        "signature": "pub fn leak<'a>(b: Self) -> &'a mut T\n    where\n        A: 'a,",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn leak<'a>(b: Self) -> &'a mut T\n    where\n        A: 'a,\n    {\n        unsafe { &mut *Box::into_raw(b) }\n    }",
        "old_source_code": "    #[inline]\n    pub fn leak<'a>(b: Self) -> &'a mut T\n    where\n        A: 'a,\n    {\n        unsafe { &mut *mem::ManuallyDrop::new(b).0.as_ptr() }\n    }"
    },
    {
        "name": "clamp",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::cmp",
        "type": "method",
        "signature": "fn clamp(self, min: Self, max: Self) -> Self\n    where\n        Self: Sized,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    fn clamp(self, min: Self, max: Self) -> Self\n    where\n        Self: Sized,\n    {\n        assert!(min <= max);\n        if self < min {\n            min\n        } else if self > max {\n            max\n        } else {\n            self\n        }\n    }",
        "old_source_code": "    fn clamp(self, min: Self, max: Self) -> Self\n    where\n        Self: Sized,\n        Self: PartialOrd,\n    {\n        assert!(min <= max);\n        if self < min {\n            min\n        } else if self > max {\n            max\n        } else {\n            self\n        }\n    }"
    },
    {
        "name": "into_iter",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "alloc::collections::linked_list",
        "type": "method",
        "signature": "impl<'a, T, A: Allocator> IntoIterator for &'a mut LinkedList<T, A>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<'a, T, A: Allocator> IntoIterator for &'a mut LinkedList<T, A> {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n        self.iter_mut()\n    }\n}",
        "old_source_code": "impl<'a, T> IntoIterator for &'a mut LinkedList<T> {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n        self.iter_mut()\n    }\n}"
    },
    {
        "name": "min_by",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::cmp",
        "type": "function",
        "signature": "pub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T",
        "change_type": "signature",
        "documentation": "",
        "source_code": "pub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n    match compare(&v1, &v2) {\n        Ordering::Less | Ordering::Equal => v1,\n        Ordering::Greater => v2,\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\npub const fn min_by<T, F: ~const FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T\nwhere\n    T: ~const Destruct,\n    F: ~const Destruct,\n{\n    match compare(&v1, &v2) {\n        Ordering::Less | Ordering::Equal => v1,\n        Ordering::Greater => v2,\n    }\n}"
    },
    {
        "name": "eq",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::tuple",
        "type": "method",
        "signature": "impl<$($T: PartialEq),+> PartialEq for ($($T,)+)\n            where\n                last_type!($($T,)+): ?Sized",
        "change_type": "signature",
        "documentation": "",
        "source_code": "            impl<$($T: PartialEq),+> PartialEq for ($($T,)+)\n            where\n                last_type!($($T,)+): ?Sized\n            {\n                #[inline]\n                fn eq(&self, other: &($($T,)+)) -> bool {\n                    $( ${ignore(T)} self.${index()} == other.${index()} )&&+\n                }\n                #[inline]\n                fn ne(&self, other: &($($T,)+)) -> bool {\n                    $( ${ignore(T)} self.${index()} != other.${index()} )||+\n                }\n            }",
        "old_source_code": "            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n            impl<$($T: ~const PartialEq),+> const PartialEq for ($($T,)+)\n            where\n                last_type!($($T,)+): ?Sized\n            {\n                #[inline]\n                fn eq(&self, other: &($($T,)+)) -> bool {\n                    $( ${ignore(T)} self.${index()} == other.${index()} )&&+\n                }\n                #[inline]\n                fn ne(&self, other: &($($T,)+)) -> bool {\n                    $( ${ignore(T)} self.${index()} != other.${index()} )||+\n                }\n            }"
    },
    {
        "name": "get_mut",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n    where\n        I: SliceIndex<Self>,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[inline]\n    #[must_use]\n    pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n    where\n        I: SliceIndex<Self>,\n    {\n        index.get_mut(self)\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n    #[inline]\n    #[must_use]\n    pub const fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n    where\n        I: ~const SliceIndex<Self>,\n    {\n        index.get_mut(self)\n    }"
    },
    {
        "name": "write",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "std::ptr",
        "type": "function",
        "signature": "pub const unsafe fn write<T>(dst: *mut T, src: T)",
        "change_type": "implicit",
        "documentation": "Overwrites a memory location with the given value without reading or\ndropping the old value.\n\n`write` does not drop the contents of `dst`. This is safe, but it could leak\nallocations or resources, so care should be taken not to overwrite an object\nthat should be dropped.\n\nAdditionally, it does not drop `src`. Semantically, `src` is moved into the\nlocation pointed to by `dst`.\n\nThis is appropriate for initializing uninitialized memory, or overwriting\nmemory that has previously been [`read`] from.\n\n# Safety\n\nBehavior is undefined if any of the following conditions are violated:\n\n* `dst` must be [valid] for writes.\n\n* `dst` must be properly aligned. Use [`write_unaligned`] if this is not the\ncase.\n\nNote that even if `T` has size `0`, the pointer must be non-null and properly aligned.\n\n[valid]: self#safety\n",
        "examples": [
            "",
            "Basic usage:",
            "",
            "```",
            "let mut x = 0;",
            "let y = &mut x as *mut i32;",
            "let z = 12;",
            "",
            "unsafe {",
            "std::ptr::write(y, z);",
            "assert_eq!(std::ptr::read(y), 12);",
            "}",
            "```",
            "",
            "Manually implement [`mem::swap`]:",
            "",
            "```",
            "use std::ptr;",
            "",
            "fn swap<T>(a: &mut T, b: &mut T) {",
            "unsafe {",
            "// Create a bitwise copy of the value at `a` in `tmp`.",
            "let tmp = ptr::read(a);",
            "",
            "// Exiting at this point (either by explicitly returning or by",
            "// calling a function which panics) would cause the value in `tmp` to",
            "// be dropped while the same value is still referenced by `a`. This",
            "// could trigger undefined behavior if `T` is not `Copy`.",
            "",
            "// Create a bitwise copy of the value at `b` in `a`.",
            "// This is safe because mutable references cannot alias.",
            "ptr::copy_nonoverlapping(b, a, 1);",
            "",
            "// As above, exiting here could trigger undefined behavior because",
            "// the same value is referenced by `a` and `b`.",
            "",
            "// Move `tmp` into `b`.",
            "ptr::write(b, tmp);",
            "",
            "// `tmp` has been moved (`write` takes ownership of its second argument),",
            "// so nothing is dropped implicitly here.",
            "}",
            "}",
            "",
            "let mut foo = \"foo\".to_owned();",
            "let mut bar = \"bar\".to_owned();",
            "",
            "swap(&mut foo, &mut bar);",
            "",
            "assert_eq!(foo, \"bar\");",
            "assert_eq!(bar, \"foo\");",
            "```"
        ],
        "source_code": "#[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n#[rustc_diagnostic_item = \"ptr_write\"]\n#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\npub const unsafe fn write<T>(dst: *mut T, src: T) {\n    // Semantically, it would be fine for this to be implemented as a\n    // `copy_nonoverlapping` and appropriate drop suppression of `src`.\n\n    // However, implementing via that currently produces more MIR than is ideal.\n    // Using an intrinsic keeps it down to just the simple `*dst = move src` in\n    // MIR (11 statements shorter, at the time of writing), and also allows\n    // `src` to stay an SSA value in codegen_ssa, rather than a memory one.\n\n    // SAFETY: the caller must guarantee that `dst` is valid for writes.\n    // `dst` cannot overlap `src` because the caller has mutable access\n    // to `dst` while `src` is owned by this function.\n    unsafe {\n        #[cfg(debug_assertions)] // Too expensive to always enable (for now?)\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::write requires that the pointer argument is aligned and non-null\",\n            (\n                addr: *mut () = dst as *mut (),\n                align: usize = align_of::<T>(),\n            ) => is_aligned_and_not_null(addr, align)\n        );\n        intrinsics::write_via_move(dst, src)\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n#[rustc_diagnostic_item = \"ptr_write\"]\n#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\npub const unsafe fn write<T>(dst: *mut T, src: T) {\n    // Semantically, it would be fine for this to be implemented as a\n    // `copy_nonoverlapping` and appropriate drop suppression of `src`.\n\n    // However, implementing via that currently produces more MIR than is ideal.\n    // Using an intrinsic keeps it down to just the simple `*dst = move src` in\n    // MIR (11 statements shorter, at the time of writing), and also allows\n    // `src` to stay an SSA value in codegen_ssa, rather than a memory one.\n\n    // SAFETY: the caller must guarantee that `dst` is valid for writes.\n    // `dst` cannot overlap `src` because the caller has mutable access\n    // to `dst` while `src` is owned by this function.\n    unsafe {\n        assert_unsafe_precondition!(\n            \"ptr::write requires that the pointer argument is aligned and non-null\",\n            [T](dst: *mut T) => is_aligned_and_not_null(dst)\n        );\n        intrinsics::write_via_move(dst, src)\n    }\n}"
    },
    {
        "name": "reverse",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub fn reverse(&mut self)",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn reverse(&mut self) {\n        let half_len = self.len() / 2;\n        let Range { start, end } = self.as_mut_ptr_range();\n\n        // These slices will skip the middle item for an odd length,\n        // since that one doesn't need to move.\n        let (front_half, back_half) =\n            // SAFETY: Both are subparts of the original slice, so the memory\n            // range is valid, and they don't overlap because they're each only\n            // half (or less) of the original slice.\n            unsafe {\n                (\n                    slice::from_raw_parts_mut(start, half_len),\n                    slice::from_raw_parts_mut(end.sub(half_len), half_len),\n                )\n            };\n\n        // Introducing a function boundary here means that the two halves\n        // get `noalias` markers, allowing better optimization as LLVM\n        // knows that they're disjoint, unlike in the original slice.\n        revswap(front_half, back_half, half_len);\n\n        #[inline]\n        fn revswap<T>(a: &mut [T], b: &mut [T], n: usize) {\n            debug_assert!(a.len() == n);\n            debug_assert!(b.len() == n);\n\n            // Because this function is first compiled in isolation,\n            // this check tells LLVM that the indexing below is\n            // in-bounds. Then after inlining -- once the actual\n            // lengths of the slices are known -- it's removed.\n            let (a, b) = (&mut a[..n], &mut b[..n]);\n\n            let mut i = 0;\n            while i < n {\n                mem::swap(&mut a[i], &mut b[n - 1 - i]);\n                i += 1;\n            }\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_reverse\", issue = \"100784\")]\n    #[inline]\n    pub const fn reverse(&mut self) {\n        let half_len = self.len() / 2;\n        let Range { start, end } = self.as_mut_ptr_range();\n\n        // These slices will skip the middle item for an odd length,\n        // since that one doesn't need to move.\n        let (front_half, back_half) =\n            // SAFETY: Both are subparts of the original slice, so the memory\n            // range is valid, and they don't overlap because they're each only\n            // half (or less) of the original slice.\n            unsafe {\n                (\n                    slice::from_raw_parts_mut(start, half_len),\n                    slice::from_raw_parts_mut(end.sub(half_len), half_len),\n                )\n            };\n\n        // Introducing a function boundary here means that the two halves\n        // get `noalias` markers, allowing better optimization as LLVM\n        // knows that they're disjoint, unlike in the original slice.\n        revswap(front_half, back_half, half_len);\n\n        #[inline]\n        const fn revswap<T>(a: &mut [T], b: &mut [T], n: usize) {\n            debug_assert!(a.len() == n);\n            debug_assert!(b.len() == n);\n\n            // Because this function is first compiled in isolation,\n            // this check tells LLVM that the indexing below is\n            // in-bounds. Then after inlining -- once the actual\n            // lengths of the slices are known -- it's removed.\n            let (a, b) = (&mut a[..n], &mut b[..n]);\n\n            let mut i = 0;\n            while i < n {\n                mem::swap(&mut a[i], &mut b[n - 1 - i]);\n                i += 1;\n            }\n        }\n    }"
    },
    {
        "name": "or",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::result",
        "type": "method",
        "signature": "pub fn or<F>(self, res: Result<T, F>) -> Result<T, F>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn or<F>(self, res: Result<T, F>) -> Result<T, F> {\n        match self {\n            Ok(v) => Ok(v),\n            Err(_) => res,\n        }\n    }",
        "old_source_code": "    pub const fn or<F>(self, res: Result<T, F>) -> Result<T, F>\n    where\n        T: ~const Destruct,\n        E: ~const Destruct,\n        F: ~const Destruct,\n    {\n        match self {\n            Ok(v) => Ok(v),\n            // FIXME: ~const Drop doesn't quite work right yet\n            #[allow(unused_variables)]\n            Err(e) => res,\n        }\n    }"
    },
    {
        "name": "deref_mut",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::mem::manually_drop",
        "type": "method",
        "signature": "impl<T: ?Sized> DerefMut for ManuallyDrop<T>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n    #[inline(always)]\n    fn deref_mut(&mut self) -> &mut T {\n        &mut self.value\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_deref\", issue = \"88955\")]\nimpl<T: ?Sized> const DerefMut for ManuallyDrop<T> {\n    #[inline(always)]\n    fn deref_mut(&mut self) -> &mut T {\n        &mut self.value\n    }\n}"
    },
    {
        "name": "get_unchecked_mut",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n    where\n        I: SliceIndex<Self>,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[inline]\n    #[must_use]\n    pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n    where\n        I: SliceIndex<Self>,\n    {\n        // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`;\n        // the slice is dereferenceable because `self` is a safe reference.\n        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n        unsafe { &mut *index.get_unchecked_mut(self) }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n    #[inline]\n    #[must_use]\n    pub const unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n    where\n        I: ~const SliceIndex<Self>,\n    {\n        // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`;\n        // the slice is dereferenceable because `self` is a safe reference.\n        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n        unsafe { &mut *index.get_unchecked_mut(self) }\n    }"
    },
    {
        "name": "leak",
        "from_version": "1.71.1",
        "to_version": "1.72.0",
        "module": "alloc::string",
        "type": "method",
        "signature": "pub fn leak<'a>(self) -> &'a mut str",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn leak<'a>(self) -> &'a mut str {\n        let slice = self.vec.leak();\n        unsafe { from_utf8_unchecked_mut(slice) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "ptr_eq",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "alloc::sync",
        "type": "method",
        "signature": "pub fn ptr_eq(&self, other: &Self) -> bool",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn ptr_eq(&self, other: &Self) -> bool {\n        ptr::addr_eq(self.ptr.as_ptr(), other.ptr.as_ptr())\n    }",
        "old_source_code": "    pub fn ptr_eq(&self, other: &Self) -> bool {\n        ptr::eq(self.ptr.as_ptr() as *const (), other.ptr.as_ptr() as *const ())\n    }"
    },
    {
        "name": "retain",
        "from_version": "1.71.1",
        "to_version": "1.72.0",
        "module": "alloc::collections::btree::map",
        "type": "method",
        "signature": "pub fn retain<F>(&mut self, mut f: F)\n    where\n        K: Ord,\n        F: FnMut(&K, &mut V) -> bool,",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn retain<F>(&mut self, mut f: F)\n    where\n        K: Ord,\n        F: FnMut(&K, &mut V) -> bool,\n    {\n        self.extract_if(|k, v| !f(k, v)).for_each(drop);\n    }",
        "old_source_code": "    pub fn retain<F>(&mut self, mut f: F)\n    where\n        K: Ord,\n        F: FnMut(&K, &mut V) -> bool,\n    {\n        self.drain_filter(|k, v| !f(k, v));\n    }"
    },
    {
        "name": "PeekMut",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "alloc::collections::binary_heap",
        "type": "struct",
        "signature": "pub struct PeekMut<\n    'a,\n    T: 'a + Ord,\n>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "pub struct PeekMut<\n    'a,\n    T: 'a + Ord,\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n> {\n    heap: &'a mut BinaryHeap<T, A>,\n    // If a set_len + sift_down are required, this is Some. If a &mut T has not\n    // yet been exposed to peek_mut()'s caller, it's None.\n    original_len: Option<NonZero<usize>>,\n}",
        "old_source_code": "pub struct PeekMut<\n    'a,\n    T: 'a + Ord,\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n> {\n    heap: &'a mut BinaryHeap<T, A>,\n    // If a set_len + sift_down are required, this is Some. If a &mut T has not\n    // yet been exposed to peek_mut()'s caller, it's None.\n    original_len: Option<NonZeroUsize>,\n}"
    },
    {
        "name": "fmt",
        "from_version": "1.71.1",
        "to_version": "1.72.0",
        "module": "std::io::buffered::bufreader",
        "type": "method",
        "signature": "impl<R> fmt::Debug for BufReader<R>\nwhere\n    R: ?Sized + fmt::Debug,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<R> fmt::Debug for BufReader<R>\nwhere\n    R: ?Sized + fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.debug_struct(\"BufReader\")\n            .field(\"reader\", &&self.inner)\n            .field(\n                \"buffer\",\n                &format_args!(\"{}/{}\", self.buf.filled() - self.buf.pos(), self.capacity()),\n            )\n            .finish()\n    }\n}",
        "old_source_code": "impl<R> fmt::Debug for BufReader<R>\nwhere\n    R: fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt.debug_struct(\"BufReader\")\n            .field(\"reader\", &self.inner)\n            .field(\n                \"buffer\",\n                &format_args!(\"{}/{}\", self.buf.filled() - self.buf.pos(), self.capacity()),\n            )\n            .finish()\n    }\n}"
    },
    {
        "name": "write",
        "from_version": "1.71.1",
        "to_version": "1.72.0",
        "module": "std::io::buffered::linewriter",
        "type": "method",
        "signature": "impl<W: ?Sized + Write> Write for LineWriter<W>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<W: ?Sized + Write> Write for LineWriter<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        LineWriterShim::new(&mut self.inner).write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.flush()\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        LineWriterShim::new(&mut self.inner).write_vectored(bufs)\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        self.inner.is_write_vectored()\n    }\n\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        LineWriterShim::new(&mut self.inner).write_all(buf)\n    }\n\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        LineWriterShim::new(&mut self.inner).write_all_vectored(bufs)\n    }\n\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n        LineWriterShim::new(&mut self.inner).write_fmt(fmt)\n    }\n}",
        "old_source_code": "impl<W: Write> Write for LineWriter<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        LineWriterShim::new(&mut self.inner).write(buf)\n    }\n\n    fn flush(&mut self) -> io::Result<()> {\n        self.inner.flush()\n    }\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        LineWriterShim::new(&mut self.inner).write_vectored(bufs)\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        self.inner.is_write_vectored()\n    }\n\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        LineWriterShim::new(&mut self.inner).write_all(buf)\n    }\n\n    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n        LineWriterShim::new(&mut self.inner).write_all_vectored(bufs)\n    }\n\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n        LineWriterShim::new(&mut self.inner).write_fmt(fmt)\n    }\n}"
    },
    {
        "name": "TypeId",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "core::any",
        "type": "struct",
        "signature": "pub struct TypeId",
        "change_type": "implicit",
        "documentation": "////////////////////////////////////////////////////////////////////////////",
        "source_code": "pub struct TypeId {\n    // We avoid using `u128` because that imposes higher alignment requirements on many platforms.\n    // See issue #115620 for more information.\n    t: (u64, u64),\n}",
        "old_source_code": "pub struct TypeId {\n    t: u128,\n}"
    },
    {
        "name": "fill_buf",
        "from_version": "1.71.1",
        "to_version": "1.72.0",
        "module": "std::io::buffered::bufreader",
        "type": "method",
        "signature": "impl<R: ?Sized + Read> BufRead for BufReader<R>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<R: ?Sized + Read> BufRead for BufReader<R> {\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        self.buf.fill_buf(&mut self.inner)\n    }\n\n    fn consume(&mut self, amt: usize) {\n        self.buf.consume(amt)\n    }\n}",
        "old_source_code": "impl<R: Read> BufRead for BufReader<R> {\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n        self.buf.fill_buf(&mut self.inner)\n    }\n\n    fn consume(&mut self, amt: usize) {\n        self.buf.consume(amt)\n    }\n}"
    },
    {
        "name": "BufWriter",
        "from_version": "1.71.1",
        "to_version": "1.72.0",
        "module": "std::io::buffered::bufwriter",
        "type": "struct",
        "signature": "pub struct BufWriter<W: ?Sized + Write>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "pub struct BufWriter<W: ?Sized + Write> {\n    // The buffer. Avoid using this like a normal `Vec` in common code paths.\n    // That is, don't use `buf.push`, `buf.extend_from_slice`, or any other\n    // methods that require bounds checking or the like. This makes an enormous\n    // difference to performance (we may want to stop using a `Vec` entirely).\n    buf: Vec<u8>,\n    // #30888: If the inner writer panics in a call to write, we don't want to\n    // write the buffered data a second time in BufWriter's destructor. This\n    // flag tells the Drop impl if it should skip the flush.\n    panicked: bool,\n    inner: W,\n}",
        "old_source_code": "pub struct BufWriter<W: Write> {\n    inner: W,\n    // The buffer. Avoid using this like a normal `Vec` in common code paths.\n    // That is, don't use `buf.push`, `buf.extend_from_slice`, or any other\n    // methods that require bounds checking or the like. This makes an enormous\n    // difference to performance (we may want to stop using a `Vec` entirely).\n    buf: Vec<u8>,\n    // #30888: If the inner writer panics in a call to write, we don't want to\n    // write the buffered data a second time in BufWriter's destructor. This\n    // flag tells the Drop impl if it should skip the flush.\n    panicked: bool,\n}"
    },
    {
        "name": "ptr_eq",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "alloc::rc",
        "type": "method",
        "signature": "pub fn ptr_eq(&self, other: &Self) -> bool",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn ptr_eq(&self, other: &Self) -> bool {\n        ptr::addr_eq(self.ptr.as_ptr(), other.ptr.as_ptr())\n    }",
        "old_source_code": "    pub fn ptr_eq(&self, other: &Self) -> bool {\n        ptr::eq(self.ptr.as_ptr() as *const (), other.ptr.as_ptr() as *const ())\n    }"
    },
    {
        "name": "read",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "std::io::buffered::bufreader",
        "type": "method",
        "signature": "impl<R: ?Sized + Read> Read for BufReader<R>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl<R: ?Sized + Read> Read for BufReader<R> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.buf.pos() == self.buf.filled() && buf.len() >= self.capacity() {\n            self.discard_buffer();\n            return self.inner.read(buf);\n        }\n        let mut rem = self.fill_buf()?;\n        let nread = rem.read(buf)?;\n        self.consume(nread);\n        Ok(nread)\n    }\n\n    fn read_buf(&mut self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.buf.pos() == self.buf.filled() && cursor.capacity() >= self.capacity() {\n            self.discard_buffer();\n            return self.inner.read_buf(cursor);\n        }\n\n        let prev = cursor.written();\n\n        let mut rem = self.fill_buf()?;\n        rem.read_buf(cursor.reborrow())?;\n\n        self.consume(cursor.written() - prev); //slice impl of read_buf known to never unfill buf\n\n        Ok(())\n    }\n\n    // Small read_exacts from a BufReader are extremely common when used with a deserializer.\n    // The default implementation calls read in a loop, which results in surprisingly poor code\n    // generation for the common path where the buffer has enough bytes to fill the passed-in\n    // buffer.\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        if self.buf.consume_with(buf.len(), |claimed| buf.copy_from_slice(claimed)) {\n            return Ok(());\n        }\n\n        crate::io::default_read_exact(self, buf)\n    }\n\n    fn read_buf_exact(&mut self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n        if self.buf.consume_with(cursor.capacity(), |claimed| cursor.append(claimed)) {\n            return Ok(());\n        }\n\n        crate::io::default_read_buf_exact(self, cursor)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n        if self.buf.pos() == self.buf.filled() && total_len >= self.capacity() {\n            self.discard_buffer();\n            return self.inner.read_vectored(bufs);\n        }\n        let mut rem = self.fill_buf()?;\n        let nread = rem.read_vectored(bufs)?;\n\n        self.consume(nread);\n        Ok(nread)\n    }\n\n    fn is_read_vectored(&self) -> bool {\n        self.inner.is_read_vectored()\n    }\n\n    // The inner reader might have an optimized `read_to_end`. Drain our buffer and then\n    // delegate to the inner implementation.\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        let inner_buf = self.buffer();\n        buf.try_reserve(inner_buf.len())?;\n        buf.extend_from_slice(inner_buf);\n        let nread = inner_buf.len();\n        self.discard_buffer();\n        Ok(nread + self.inner.read_to_end(buf)?)\n    }\n\n    // The inner reader might have an optimized `read_to_end`. Drain our buffer and then\n    // delegate to the inner implementation.\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        // In the general `else` case below we must read bytes into a side buffer, check\n        // that they are valid UTF-8, and then append them to `buf`. This requires a\n        // potentially large memcpy.\n        //\n        // If `buf` is empty--the most common case--we can leverage `append_to_string`\n        // to read directly into `buf`'s internal byte buffer, saving an allocation and\n        // a memcpy.\n        if buf.is_empty() {\n            // `append_to_string`'s safety relies on the buffer only being appended to since\n            // it only checks the UTF-8 validity of new data. If there were existing content in\n            // `buf` then an untrustworthy reader (i.e. `self.inner`) could not only append\n            // bytes but also modify existing bytes and render them invalid. On the other hand,\n            // if `buf` is empty then by definition any writes must be appends and\n            // `append_to_string` will validate all of the new bytes.\n            unsafe { crate::io::append_to_string(buf, |b| self.read_to_end(b)) }\n        } else {\n            // We cannot append our byte buffer directly onto the `buf` String as there could\n            // be an incomplete UTF-8 sequence that has only been partially read. We must read\n            // everything into a side buffer first and then call `from_utf8` on the complete\n            // buffer.\n            let mut bytes = Vec::new();\n            self.read_to_end(&mut bytes)?;\n            let string = crate::str::from_utf8(&bytes).map_err(|_| io::Error::INVALID_UTF8)?;\n            *buf += string;\n            Ok(string.len())\n        }\n    }\n}",
        "old_source_code": "impl<R: ?Sized + Read> Read for BufReader<R> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.buf.pos() == self.buf.filled() && buf.len() >= self.capacity() {\n            self.discard_buffer();\n            return self.inner.read(buf);\n        }\n        let mut rem = self.fill_buf()?;\n        let nread = rem.read(buf)?;\n        self.consume(nread);\n        Ok(nread)\n    }\n\n    fn read_buf(&mut self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n        // If we don't have any buffered data and we're doing a massive read\n        // (larger than our internal buffer), bypass our internal buffer\n        // entirely.\n        if self.buf.pos() == self.buf.filled() && cursor.capacity() >= self.capacity() {\n            self.discard_buffer();\n            return self.inner.read_buf(cursor);\n        }\n\n        let prev = cursor.written();\n\n        let mut rem = self.fill_buf()?;\n        rem.read_buf(cursor.reborrow())?;\n\n        self.consume(cursor.written() - prev); //slice impl of read_buf known to never unfill buf\n\n        Ok(())\n    }\n\n    // Small read_exacts from a BufReader are extremely common when used with a deserializer.\n    // The default implementation calls read in a loop, which results in surprisingly poor code\n    // generation for the common path where the buffer has enough bytes to fill the passed-in\n    // buffer.\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        if self.buf.consume_with(buf.len(), |claimed| buf.copy_from_slice(claimed)) {\n            return Ok(());\n        }\n\n        crate::io::default_read_exact(self, buf)\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n        if self.buf.pos() == self.buf.filled() && total_len >= self.capacity() {\n            self.discard_buffer();\n            return self.inner.read_vectored(bufs);\n        }\n        let nread = {\n            let mut rem = self.fill_buf()?;\n            rem.read_vectored(bufs)?\n        };\n        self.consume(nread);\n        Ok(nread)\n    }\n\n    fn is_read_vectored(&self) -> bool {\n        self.inner.is_read_vectored()\n    }\n\n    // The inner reader might have an optimized `read_to_end`. Drain our buffer and then\n    // delegate to the inner implementation.\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        let inner_buf = self.buffer();\n        buf.try_reserve(inner_buf.len())?;\n        buf.extend_from_slice(inner_buf);\n        let nread = inner_buf.len();\n        self.discard_buffer();\n        Ok(nread + self.inner.read_to_end(buf)?)\n    }\n\n    // The inner reader might have an optimized `read_to_end`. Drain our buffer and then\n    // delegate to the inner implementation.\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        // In the general `else` case below we must read bytes into a side buffer, check\n        // that they are valid UTF-8, and then append them to `buf`. This requires a\n        // potentially large memcpy.\n        //\n        // If `buf` is empty--the most common case--we can leverage `append_to_string`\n        // to read directly into `buf`'s internal byte buffer, saving an allocation and\n        // a memcpy.\n        if buf.is_empty() {\n            // `append_to_string`'s safety relies on the buffer only being appended to since\n            // it only checks the UTF-8 validity of new data. If there were existing content in\n            // `buf` then an untrustworthy reader (i.e. `self.inner`) could not only append\n            // bytes but also modify existing bytes and render them invalid. On the other hand,\n            // if `buf` is empty then by definition any writes must be appends and\n            // `append_to_string` will validate all of the new bytes.\n            unsafe { crate::io::append_to_string(buf, |b| self.read_to_end(b)) }\n        } else {\n            // We cannot append our byte buffer directly onto the `buf` String as there could\n            // be an incomplete UTF-8 sequence that has only been partially read. We must read\n            // everything into a side buffer first and then call `from_utf8` on the complete\n            // buffer.\n            let mut bytes = Vec::new();\n            self.read_to_end(&mut bytes)?;\n            let string = crate::str::from_utf8(&bytes).map_err(|_| {\n                io::const_io_error!(\n                    io::ErrorKind::InvalidData,\n                    \"stream did not contain valid UTF-8\",\n                )\n            })?;\n            *buf += string;\n            Ok(string.len())\n        }\n    }\n}"
    },
    {
        "name": "div_ceil",
        "from_version": "1.72.1",
        "to_version": "1.73.0",
        "module": "core::num::uint_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn div_ceil(self, rhs: Self) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 && rhs > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }",
        "old_source_code": ""
    },
    {
        "name": "next_back",
        "from_version": "1.72.1",
        "to_version": "1.73.0",
        "module": "core::slice::iter::macros",
        "type": "method",
        "signature": "impl<'a, T> DoubleEndedIterator for $name<'a, T>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked!`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(next_back_unchecked!(self))\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => *end = self.ptr,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(next_back_unchecked!(self))\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZeroUsize::new(n - advance).map_or(Ok(()), Err)\n            }\n        }",
        "old_source_code": "        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: `assume` call is safe because slices over non-ZSTs must\n                // have a non-null end pointer. The call to `next_back_unchecked!`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if !<T>::IS_ZST {\n                        assume(!self.end.is_null());\n                    }\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(next_back_unchecked!(self))\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if T::IS_ZST {\n                        zst_set_len!(self, 0);\n                    } else {\n                        self.end = self.ptr.as_ptr();\n                    }\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(next_back_unchecked!(self))\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZeroUsize::new(n - advance).map_or(Ok(()), Err)\n            }\n        }"
    },
    {
        "name": "fmt",
        "from_version": "1.72.1",
        "to_version": "1.73.0",
        "module": "std::io::util",
        "type": "method",
        "signature": "impl fmt::Debug for Repeat",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl fmt::Debug for Repeat {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Repeat\").finish_non_exhaustive()\n    }\n}",
        "old_source_code": "impl fmt::Debug for Sink {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Sink\").finish_non_exhaustive()\n    }\n}"
    },
    {
        "name": "sub",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::ptr::const_ptr",
        "type": "method",
        "signature": "pub const unsafe fn sub(self, count: usize) -> Self\n    where\n        T: Sized,",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n    #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n    #[rustc_allow_const_fn_unstable(unchecked_neg)]\n    #[inline(always)]\n    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n    pub const unsafe fn sub(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        const fn runtime_sub_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            #[inline]\n            fn runtime(this: *const (), count: usize, size: usize) -> bool {\n                let Some(byte_offset) = count.checked_mul(size) else {\n                    return false;\n                };\n                byte_offset <= (isize::MAX as usize) && this.addr() >= byte_offset\n            }\n\n            const fn comptime(_: *const (), _: usize, _: usize) -> bool {\n                true\n            }\n\n            intrinsics::const_eval_select((this, count, size), comptime, runtime)\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::sub requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_sub_nowrap(this, count, size)\n        );\n\n        if T::IS_ZST {\n            // Pointer arithmetic does nothing when the pointee is a ZST.\n            self\n        } else {\n            // SAFETY: the caller must uphold the safety contract for `offset`.\n            // Because the pointee is *not* a ZST, that means that `count` is\n            // at most `isize::MAX`, and thus the negation cannot overflow.\n            unsafe { intrinsics::offset(self, intrinsics::unchecked_sub(0, count as isize)) }\n        }\n    }",
        "old_source_code": "    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n    #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n    #[rustc_allow_const_fn_unstable(unchecked_neg)]\n    #[inline(always)]\n    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n    pub const unsafe fn sub(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        if T::IS_ZST {\n            // Pointer arithmetic does nothing when the pointee is a ZST.\n            self\n        } else {\n            // SAFETY: the caller must uphold the safety contract for `offset`.\n            // Because the pointee is *not* a ZST, that means that `count` is\n            // at most `isize::MAX`, and thus the negation cannot overflow.\n            unsafe { self.offset((count as isize).unchecked_neg()) }\n        }\n    }"
    },
    {
        "name": "log2",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "std::f64",
        "type": "method",
        "signature": "pub fn log2(self) -> f64",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn log2(self) -> f64 {\n        unsafe { intrinsics::log2f64(self) }\n    }",
        "old_source_code": "    #[inline]\n    pub fn log2(self) -> f64 {\n        crate::sys::log2f64(self)\n    }"
    },
    {
        "name": "fmt",
        "from_version": "1.72.1",
        "to_version": "1.73.0",
        "module": "core::cell::once",
        "type": "method",
        "signature": "impl<T: fmt::Debug> fmt::Debug for OnceCell<T>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut d = f.debug_tuple(\"OnceCell\");\n        match self.get() {\n            Some(v) => d.field(v),\n            None => d.field(&format_args!(\"<uninit>\")),\n        };\n        d.finish()\n    }\n}",
        "old_source_code": "impl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.get() {\n            Some(v) => f.debug_tuple(\"OnceCell\").field(v).finish(),\n            None => f.write_str(\"OnceCell(Uninit)\"),\n        }\n    }\n}"
    },
    {
        "name": "log2",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "std::f32",
        "type": "method",
        "signature": "pub fn log2(self) -> f32",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn log2(self) -> f32 {\n        unsafe { intrinsics::log2f32(self) }\n    }",
        "old_source_code": "    #[inline]\n    pub fn log2(self) -> f32 {\n        crate::sys::log2f32(self)\n    }"
    },
    {
        "name": "weak_count",
        "from_version": "1.72.1",
        "to_version": "1.73.0",
        "module": "alloc::rc",
        "type": "method",
        "signature": "pub fn weak_count(&self) -> usize",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn weak_count(&self) -> usize {\n        if let Some(inner) = self.inner() {\n            if inner.strong() > 0 {\n                inner.weak() - 1 // subtract the implicit weak ptr\n            } else {\n                0\n            }\n        } else {\n            0\n        }\n    }",
        "old_source_code": "    pub fn weak_count(&self) -> usize {\n        self.inner()\n            .map(|inner| {\n                if inner.strong() > 0 {\n                    inner.weak() - 1 // subtract the implicit weak ptr\n                } else {\n                    0\n                }\n            })\n            .unwrap_or(0)\n    }"
    },
    {
        "name": "new",
        "from_version": "1.72.1",
        "to_version": "1.73.0",
        "module": "alloc::rc",
        "type": "function",
        "signature": "pub const fn new() -> Weak<T>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_weak_new\", since = \"1.73.0\")]\n    #[must_use]\n    pub const fn new() -> Weak<T> {\n        Weak {\n            ptr: unsafe { NonNull::new_unchecked(ptr::invalid_mut::<RcBox<T>>(usize::MAX)) },\n            alloc: Global,\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_weak_new\", issue = \"95091\", reason = \"recently added\")]\n    #[must_use]\n    pub const fn new() -> Weak<T> {\n        Weak { ptr: unsafe { NonNull::new_unchecked(ptr::invalid_mut::<RcBox<T>>(usize::MAX)) } }\n    }"
    },
    {
        "name": "ln",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "std::f64",
        "type": "method",
        "signature": "pub fn ln(self) -> f64",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn ln(self) -> f64 {\n        unsafe { intrinsics::logf64(self) }\n    }",
        "old_source_code": "    #[inline]\n    pub fn ln(self) -> f64 {\n        crate::sys::log_wrapper(self, |n| unsafe { intrinsics::logf64(n) })\n    }"
    },
    {
        "name": "next_back",
        "from_version": "1.72.1",
        "to_version": "1.73.0",
        "module": "core::iter::traits::double_ended",
        "type": "method",
        "signature": "impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n    fn next_back(&mut self) -> Option<I::Item> {\n        (**self).next_back()\n    }\n    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n        (**self).advance_back_by(n)\n    }\n    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n        (**self).nth_back(n)\n    }\n    fn rfold<B, F>(self, init: B, f: F) -> B\n    where\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.spec_rfold(init, f)\n    }\n    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n    where\n        F: FnMut(B, Self::Item) -> R,\n        R: Try<Output = B>,\n    {\n        self.spec_try_rfold(init, f)\n    }\n}",
        "old_source_code": "impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n    fn next_back(&mut self) -> Option<I::Item> {\n        (**self).next_back()\n    }\n    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {\n        (**self).advance_back_by(n)\n    }\n    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n        (**self).nth_back(n)\n    }\n}"
    },
    {
        "name": "fmt",
        "from_version": "1.72.1",
        "to_version": "1.73.0",
        "module": "std::sync::once_lock",
        "type": "method",
        "signature": "impl<T: fmt::Debug> fmt::Debug for OnceLock<T>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl<T: fmt::Debug> fmt::Debug for OnceLock<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut d = f.debug_tuple(\"OnceLock\");\n        match self.get() {\n            Some(v) => d.field(v),\n            None => d.field(&format_args!(\"<uninit>\")),\n        };\n        d.finish()\n    }\n}",
        "old_source_code": "impl<T: fmt::Debug> fmt::Debug for OnceLock<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.get() {\n            Some(v) => f.debug_tuple(\"Once\").field(v).finish(),\n            None => f.write_str(\"Once(Uninit)\"),\n        }\n    }\n}"
    },
    {
        "name": "Weak",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "alloc::rc",
        "type": "struct",
        "signature": "pub struct Weak<\n    T: ?Sized,\n>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "#[cfg_attr(not(test), rustc_diagnostic_item = \"RcWeak\")]\npub struct Weak<\n    T: ?Sized,\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n> {\n    // This is a `NonNull` to allow optimizing the size of this type in enums,\n    // but it is not necessarily a valid pointer.\n    // `Weak::new` sets this to `usize::MAX` so that it doesnt need\n    // to allocate space on the heap. That's not a value a real pointer\n    // will ever have because RcInner has alignment at least 2.\n    // This is only possible when `T: Sized`; unsized `T` never dangle.\n    ptr: NonNull<RcInner<T>>,\n    alloc: A,\n}",
        "old_source_code": "#[cfg_attr(not(test), rustc_diagnostic_item = \"RcWeak\")]\npub struct Weak<\n    T: ?Sized,\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n> {\n    // This is a `NonNull` to allow optimizing the size of this type in enums,\n    // but it is not necessarily a valid pointer.\n    // `Weak::new` sets this to `usize::MAX` so that it doesnt need\n    // to allocate space on the heap. That's not a value a real pointer\n    // will ever have because RcBox has alignment at least 2.\n    // This is only possible when `T: Sized`; unsized `T` never dangle.\n    ptr: NonNull<RcBox<T>>,\n    alloc: A,\n}"
    },
    {
        "name": "increment_strong_count",
        "from_version": "1.72.1",
        "to_version": "1.73.0",
        "module": "alloc::sync",
        "type": "function",
        "signature": "pub unsafe fn increment_strong_count(ptr: *const T)",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub unsafe fn increment_strong_count(ptr: *const T) {\n        unsafe { Arc::increment_strong_count_in(ptr, Global) }\n    }",
        "old_source_code": "    pub unsafe fn increment_strong_count(ptr: *const T) {\n        // Retain Arc, but don't touch refcount by wrapping in ManuallyDrop\n        let arc = unsafe { mem::ManuallyDrop::new(Arc::<T>::from_raw(ptr)) };\n        // Now increase refcount, but don't drop new refcount either\n        let _arc_clone: mem::ManuallyDrop<_> = arc.clone();\n    }"
    },
    {
        "name": "weak_count",
        "from_version": "1.72.1",
        "to_version": "1.73.0",
        "module": "alloc::sync",
        "type": "method",
        "signature": "pub fn weak_count(&self) -> usize",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn weak_count(&self) -> usize {\n        if let Some(inner) = self.inner() {\n            let weak = inner.weak.load(Acquire);\n            let strong = inner.strong.load(Acquire);\n            if strong == 0 {\n                0\n            } else {\n                // Since we observed that there was at least one strong pointer\n                // after reading the weak count, we know that the implicit weak\n                // reference (present whenever any strong references are alive)\n                // was still around when we observed the weak count, and can\n                // therefore safely subtract it.\n                weak - 1\n            }\n        } else {\n            0\n        }\n    }",
        "old_source_code": "    pub fn weak_count(&self) -> usize {\n        self.inner()\n            .map(|inner| {\n                let weak = inner.weak.load(Acquire);\n                let strong = inner.strong.load(Acquire);\n                if strong == 0 {\n                    0\n                } else {\n                    // Since we observed that there was at least one strong pointer\n                    // after reading the weak count, we know that the implicit weak\n                    // reference (present whenever any strong references are alive)\n                    // was still around when we observed the weak count, and can\n                    // therefore safely subtract it.\n                    weak - 1\n                }\n            })\n            .unwrap_or(0)\n    }"
    },
    {
        "name": "fmt",
        "from_version": "1.72.1",
        "to_version": "1.73.0",
        "module": "std::env",
        "type": "method",
        "signature": "impl fmt::Debug for ArgsOs",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl fmt::Debug for ArgsOs {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let Self { inner } = self;\n        f.debug_struct(\"ArgsOs\").field(\"inner\", inner).finish()\n    }\n}",
        "old_source_code": "impl fmt::Debug for ArgsOs {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"ArgsOs\").field(\"inner\", &self.inner).finish()\n    }\n}"
    },
    {
        "name": "log10",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "std::f64",
        "type": "method",
        "signature": "pub fn log10(self) -> f64",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn log10(self) -> f64 {\n        unsafe { intrinsics::log10f64(self) }\n    }",
        "old_source_code": "    #[inline]\n    pub fn log10(self) -> f64 {\n        crate::sys::log_wrapper(self, |n| unsafe { intrinsics::log10f64(n) })\n    }"
    },
    {
        "name": "downcast",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "alloc::rc",
        "type": "method",
        "signature": "pub fn downcast<T: Any>(self) -> Result<Rc<T, A>, Self>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn downcast<T: Any>(self) -> Result<Rc<T, A>, Self> {\n        if (*self).is::<T>() {\n            unsafe {\n                let (ptr, alloc) = Rc::into_inner_with_allocator(self);\n                Ok(Rc::from_inner_in(ptr.cast(), alloc))\n            }\n        } else {\n            Err(self)\n        }\n    }",
        "old_source_code": "    pub fn downcast<T: Any>(self) -> Result<Rc<T, A>, Self> {\n        if (*self).is::<T>() {\n            unsafe {\n                let ptr = self.ptr.cast::<RcBox<T>>();\n                let alloc = self.alloc.clone();\n                forget(self);\n                Ok(Rc::from_inner_in(ptr, alloc))\n            }\n        } else {\n            Err(self)\n        }\n    }"
    },
    {
        "name": "as_encoded_bytes",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "std::ffi::os_str",
        "type": "method",
        "signature": "pub fn as_encoded_bytes(&self) -> &[u8]",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    pub fn as_encoded_bytes(&self) -> &[u8] {\n        self.inner.as_encoded_bytes()\n    }",
        "old_source_code": ""
    },
    {
        "name": "bitand",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::num::saturating",
        "type": "method",
        "signature": "impl BitAnd for Saturating<$t>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "        impl BitAnd for Saturating<$t> {\n            type Output = Saturating<$t>;\n\n            #[inline]\n            fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {\n                Saturating(self.0 & other.0)\n            }\n        }",
        "old_source_code": ""
    },
    {
        "name": "count_ones",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::num::saturating",
        "type": "method",
        "signature": "pub const fn count_ones(self) -> u32",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "            pub const fn count_ones(self) -> u32 {\n                self.0.count_ones()\n            }",
        "old_source_code": ""
    },
    {
        "name": "count_zeros",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::num::saturating",
        "type": "method",
        "signature": "pub const fn count_zeros(self) -> u32",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "            pub const fn count_zeros(self) -> u32 {\n                self.0.count_zeros()\n            }",
        "old_source_code": ""
    },
    {
        "name": "trailing_zeros",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::num::saturating",
        "type": "method",
        "signature": "pub const fn trailing_zeros(self) -> u32",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "            pub const fn trailing_zeros(self) -> u32 {\n                self.0.trailing_zeros()\n            }",
        "old_source_code": ""
    },
    {
        "name": "to_be",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::num::saturating",
        "type": "method",
        "signature": "without modifying the original\"]\n            pub const fn to_be(self) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            pub const fn to_be(self) -> Self {\n                Saturating(self.0.to_be())\n            }",
        "old_source_code": ""
    },
    {
        "name": "leading_zeros",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::num::saturating",
        "type": "method",
        "signature": "without modifying the original\"]\n            pub const fn leading_zeros(self) -> u32",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            pub const fn leading_zeros(self) -> u32 {\n                self.0.leading_zeros()\n            }",
        "old_source_code": ""
    },
    {
        "name": "is_negative",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::num::saturating",
        "type": "method",
        "signature": "pub const fn is_negative(self) -> bool",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "            pub const fn is_negative(self) -> bool {\n                self.0.is_negative()\n            }",
        "old_source_code": ""
    },
    {
        "name": "is_power_of_two",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::num::saturating",
        "type": "method",
        "signature": "pub const fn is_power_of_two(self) -> bool",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "            pub const fn is_power_of_two(self) -> bool {\n                self.0.is_power_of_two()\n            }",
        "old_source_code": ""
    },
    {
        "name": "writer",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::fmt",
        "type": "method",
        "signature": "pub trait Write",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "pub trait Write {\n    /// Writes a string slice into this writer, returning whether the write\n    /// succeeded.\n    ///\n    /// This method can only succeed if the entire string slice was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`std::fmt::Error`][Error] on error.\n    ///\n    /// The purpose of that error is to abort the formatting operation when the underlying\n    /// destination encounters some error preventing it from accepting more text; it should\n    /// generally be propagated rather than handled, at least when implementing formatting traits.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n    ///     f.write_str(s)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, \"hola\").unwrap();\n    /// assert_eq!(&buf, \"hola\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_str(&mut self, s: &str) -> Result;\n\n    /// Writes a [`char`] into this writer, returning whether the write succeeded.\n    ///\n    /// A single [`char`] may be encoded as more than one byte.\n    /// This method can only succeed if the entire byte sequence was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n    ///     f.write_char(c)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, 'a').unwrap();\n    /// writer(&mut buf, 'b').unwrap();\n    /// assert_eq!(&buf, \"ab\");\n    /// ```\n    #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n    fn write_char(&mut self, c: char) -> Result {\n        self.write_str(c.encode_utf8(&mut [0; 4]))\n    }\n\n    /// Glue for usage of the [`write!`] macro with implementors of this trait.\n    ///\n    /// This method should generally not be invoked manually, but rather through\n    /// the [`write!`] macro itself.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error. Please see\n    /// [write_str](Write::write_str) for details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n    ///     f.write_fmt(format_args!(\"{s}\"))\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, \"world\").unwrap();\n    /// assert_eq!(&buf, \"world\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_fmt(&mut self, args: Arguments<'_>) -> Result {\n        // We use a specialization for `Sized` types to avoid an indirection\n        // through `&mut self`\n        trait SpecWriteFmt {\n            fn spec_write_fmt(self, args: Arguments<'_>) -> Result;\n        }\n\n        impl<W: Write + ?Sized> SpecWriteFmt for &mut W {\n            #[inline]\n            default fn spec_write_fmt(mut self, args: Arguments<'_>) -> Result {\n                write(&mut self, args)\n            }\n        }\n\n        impl<W: Write> SpecWriteFmt for &mut W {\n            #[inline]\n            fn spec_write_fmt(self, args: Arguments<'_>) -> Result {\n                write(self, args)\n            }\n        }\n\n        self.spec_write_fmt(args)\n    }\n}",
        "old_source_code": "pub trait Write {\n    /// Writes a string slice into this writer, returning whether the write\n    /// succeeded.\n    ///\n    /// This method can only succeed if the entire string slice was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// The purpose of std::fmt::Error is to abort the formatting operation when the underlying\n    /// destination encounters some error preventing it from accepting more text; it should\n    /// generally be propagated rather than handled, at least when implementing formatting traits.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n    ///     f.write_str(s)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, \"hola\").unwrap();\n    /// assert_eq!(&buf, \"hola\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_str(&mut self, s: &str) -> Result;\n\n    /// Writes a [`char`] into this writer, returning whether the write succeeded.\n    ///\n    /// A single [`char`] may be encoded as more than one byte.\n    /// This method can only succeed if the entire byte sequence was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n    ///     f.write_char(c)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, 'a').unwrap();\n    /// writer(&mut buf, 'b').unwrap();\n    /// assert_eq!(&buf, \"ab\");\n    /// ```\n    #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n    fn write_char(&mut self, c: char) -> Result {\n        self.write_str(c.encode_utf8(&mut [0; 4]))\n    }\n\n    /// Glue for usage of the [`write!`] macro with implementors of this trait.\n    ///\n    /// This method should generally not be invoked manually, but rather through\n    /// the [`write!`] macro itself.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error. Please see\n    /// [write_str](Write::write_str) for details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n    ///     f.write_fmt(format_args!(\"{s}\"))\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, \"world\").unwrap();\n    /// assert_eq!(&buf, \"world\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_fmt(mut self: &mut Self, args: Arguments<'_>) -> Result {\n        write(&mut self, args)\n    }\n}"
    },
    {
        "name": "borrow",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::cell",
        "type": "method",
        "signature": "pub fn borrow(&self) -> Ref<'_, T>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[inline]\n    #[track_caller]\n    pub fn borrow(&self) -> Ref<'_, T> {\n        match self.try_borrow() {\n            Ok(b) => b,\n            Err(err) => panic_already_mutably_borrowed(err),\n        }\n    }",
        "old_source_code": "    #[inline]\n    #[track_caller]\n    pub fn borrow(&self) -> Ref<'_, T> {\n        self.try_borrow().expect(\"already mutably borrowed\")\n    }"
    },
    {
        "name": "byte_offset",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "core::ptr::const_ptr",
        "type": "method",
        "signature": "pub const unsafe fn byte_offset(self, count: isize) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_pointer_byte_offsets\", since = \"1.75.0\")]\n    #[rustc_allow_const_fn_unstable(set_ptr_value)]\n    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n    pub const unsafe fn byte_offset(self, count: isize) -> Self {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { self.cast::<u8>().offset(count).with_metadata_of(self) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "wrapping_byte_offset",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "core::ptr::const_ptr",
        "type": "method",
        "signature": "pub const fn wrapping_byte_offset(self, count: isize) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_pointer_byte_offsets\", since = \"1.75.0\")]\n    #[rustc_allow_const_fn_unstable(set_ptr_value)]\n    pub const fn wrapping_byte_offset(self, count: isize) -> Self {\n        self.cast::<u8>().wrapping_offset(count).with_metadata_of(self)\n    }",
        "old_source_code": ""
    },
    {
        "name": "byte_sub",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "core::ptr::const_ptr",
        "type": "method",
        "signature": "pub const unsafe fn byte_sub(self, count: usize) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_pointer_byte_offsets\", since = \"1.75.0\")]\n    #[rustc_allow_const_fn_unstable(set_ptr_value)]\n    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n    pub const unsafe fn byte_sub(self, count: usize) -> Self {\n        // SAFETY: the caller must uphold the safety contract for `sub`.\n        unsafe { self.cast::<u8>().sub(count).with_metadata_of(self) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "wrapping_byte_add",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "core::ptr::const_ptr",
        "type": "method",
        "signature": "pub const fn wrapping_byte_add(self, count: usize) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_pointer_byte_offsets\", since = \"1.75.0\")]\n    #[rustc_allow_const_fn_unstable(set_ptr_value)]\n    pub const fn wrapping_byte_add(self, count: usize) -> Self {\n        self.cast::<u8>().wrapping_add(count).with_metadata_of(self)\n    }",
        "old_source_code": ""
    },
    {
        "name": "wrapping_byte_sub",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "core::ptr::const_ptr",
        "type": "method",
        "signature": "pub const fn wrapping_byte_sub(self, count: usize) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_pointer_byte_offsets\", since = \"1.75.0\")]\n    #[rustc_allow_const_fn_unstable(set_ptr_value)]\n    pub const fn wrapping_byte_sub(self, count: usize) -> Self {\n        self.cast::<u8>().wrapping_sub(count).with_metadata_of(self)\n    }",
        "old_source_code": ""
    },
    {
        "name": "wrapping_byte_offset",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "core::ptr::mut_ptr",
        "type": "method",
        "signature": "pub const fn wrapping_byte_offset(self, count: isize) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_pointer_byte_offsets\", since = \"1.75.0\")]\n    #[rustc_allow_const_fn_unstable(set_ptr_value)]\n    pub const fn wrapping_byte_offset(self, count: isize) -> Self {\n        self.cast::<u8>().wrapping_offset(count).with_metadata_of(self)\n    }",
        "old_source_code": ""
    },
    {
        "name": "byte_add",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "core::ptr::mut_ptr",
        "type": "method",
        "signature": "pub const unsafe fn byte_add(self, count: usize) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_pointer_byte_offsets\", since = \"1.75.0\")]\n    #[rustc_allow_const_fn_unstable(set_ptr_value)]\n    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n    pub const unsafe fn byte_add(self, count: usize) -> Self {\n        // SAFETY: the caller must uphold the safety contract for `add`.\n        unsafe { self.cast::<u8>().add(count).with_metadata_of(self) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "byte_sub",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "core::ptr::mut_ptr",
        "type": "method",
        "signature": "pub const unsafe fn byte_sub(self, count: usize) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_pointer_byte_offsets\", since = \"1.75.0\")]\n    #[rustc_allow_const_fn_unstable(set_ptr_value)]\n    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n    pub const unsafe fn byte_sub(self, count: usize) -> Self {\n        // SAFETY: the caller must uphold the safety contract for `sub`.\n        unsafe { self.cast::<u8>().sub(count).with_metadata_of(self) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "wrapping_byte_sub",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "core::ptr::mut_ptr",
        "type": "method",
        "signature": "pub const fn wrapping_byte_sub(self, count: usize) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_pointer_byte_offsets\", since = \"1.75.0\")]\n    #[rustc_allow_const_fn_unstable(set_ptr_value)]\n    pub const fn wrapping_byte_sub(self, count: usize) -> Self {\n        self.cast::<u8>().wrapping_sub(count).with_metadata_of(self)\n    }",
        "old_source_code": ""
    },
    {
        "name": "from_ptr",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "core::sync::atomic",
        "type": "function",
        "signature": "pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "            #[rustc_const_unstable(feature = \"const_atomic_from_ptr\", issue = \"108652\")]\n            pub const unsafe fn from_ptr<'a>(ptr: *mut $int_type) -> &'a $atomic_type {\n                // SAFETY: guaranteed by the caller\n                unsafe { &*ptr.cast() }\n            }",
        "old_source_code": ""
    },
    {
        "name": "deref_mut",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "std::ops::{Deref, DerefMut}",
        "type": "method",
        "signature": "pub trait DerefMut: Deref",
        "change_type": "implicit",
        "documentation": "Used for mutable dereferencing operations, like in `*v = 1;`.\n\nIn addition to being used for explicit dereferencing operations with the\n(unary) `*` operator in mutable contexts, `DerefMut` is also used implicitly\nby the compiler in many circumstances. This mechanism is called\n[\"mutable deref coercion\"][coercion]. In immutable contexts, [`Deref`] is used.\n\n**Warning:** Deref coercion is a powerful language feature which has\nfar-reaching implications for every type that implements `DerefMut`. The\ncompiler will silently insert calls to `DerefMut::deref_mut`. For this\nreason, one should be careful about implementing `DerefMut` and only do so\nwhen mutable deref coercion is desirable. See [the `Deref` docs][implementing]\nfor advice on when this is typically desirable or undesirable.\n\nTypes that implement `DerefMut` or `Deref` are often called \"smart\npointers\" and the mechanism of deref coercion has been specifically designed\nto facilitate the pointer-like behaviour that name suggests. Often, the\npurpose of a \"smart pointer\" type is to change the ownership semantics\nof a contained value (for example, [`Rc`][rc] or [`Cow`][cow]) or the\nstorage semantics of a contained value (for example, [`Box`][box]).\n\n# Mutable deref coercion\n\nIf `T` implements `DerefMut<Target = U>`, and `v` is a value of type `T`,\nthen:\n\n* In mutable contexts, `*v` (where `T` is neither a reference nor a raw pointer)\nis equivalent to `*DerefMut::deref_mut(&mut v)`.\n* Values of type `&mut T` are coerced to values of type `&mut U`\n* `T` implicitly implements all the (mutable) methods of the type `U`.\n\nFor more details, visit [the chapter in *The Rust Programming Language*][book]\nas well as the reference sections on [the dereference operator][ref-deref-op],\n[method resolution] and [type coercions].\n\n# Fallibility\n\n**This trait's method should never unexpectedly fail**. Deref coercion means\nthe compiler will often insert calls to `DerefMut::deref_mut` implicitly.\nFailure during dereferencing can be extremely confusing when `DerefMut` is\ninvoked implicitly. In the majority of uses it should be infallible, though\nit may be acceptable to panic if the type is misused through programmer\nerror, for example.\n\nHowever, infallibility is not enforced and therefore not guaranteed.\nAs such, `unsafe` code should not rely on infallibility in general for\nsoundness.\n\n[book]: ../../book/ch15-02-deref.html\n[coercion]: #mutable-deref-coercion\n[implementing]: Deref#when-to-implement-deref-or-derefmut\n[ref-deref-op]: ../../reference/expressions/operator-expr.html#the-dereference-operator\n[method resolution]: ../../reference/expressions/method-call-expr.html\n[type coercions]: ../../reference/type-coercions.html\n[box]: ../../alloc/boxed/struct.Box.html\n[string]: ../../alloc/string/struct.String.html\n[rc]: ../../alloc/rc/struct.Rc.html\n[cow]: ../../alloc/borrow/enum.Cow.html\n",
        "examples": [
            "",
            "A struct with a single field which is modifiable by dereferencing the",
            "struct.",
            "",
            "```",
            "use std::ops::{Deref, DerefMut};",
            "",
            "struct DerefMutExample<T> {",
            "value: T",
            "}",
            "",
            "impl<T> Deref for DerefMutExample<T> {",
            "type Target = T;",
            "",
            "fn deref(&self) -> &Self::Target {",
            "&self.value",
            "}",
            "}",
            "",
            "impl<T> DerefMut for DerefMutExample<T> {",
            "fn deref_mut(&mut self) -> &mut Self::Target {",
            "&mut self.value",
            "}",
            "}",
            "",
            "let mut x = DerefMutExample { value: 'a' };",
            "*x = 'b';",
            "assert_eq!('b', x.value);",
            "```"
        ],
        "source_code": "pub trait DerefMut: Deref {\n    /// Mutably dereferences the value.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_diagnostic_item = \"deref_mut_method\"]\n    fn deref_mut(&mut self) -> &mut Self::Target;\n}",
        "old_source_code": "pub trait DerefMut: Deref {\n    /// Mutably dereferences the value.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn deref_mut(&mut self) -> &mut Self::Target;\n}"
    },
    {
        "name": "handle_alloc_error",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "alloc::alloc",
        "type": "function",
        "signature": "pub const fn handle_alloc_error(layout: Layout) -> !",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "#[rustc_const_unstable(feature = \"const_alloc_error\", issue = \"92523\")]\n#[cfg(all(not(no_global_oom_handling), not(test)))]\n#[cold]\npub const fn handle_alloc_error(layout: Layout) -> ! {\n    const fn ct_error(_: Layout) -> ! {\n        panic!(\"allocation failed\");\n    }\n\n    #[inline]\n    fn rt_error(layout: Layout) -> ! {\n        unsafe {\n            __rust_alloc_error_handler(layout.size(), layout.align());\n        }\n    }\n\n    #[cfg(not(feature = \"panic_immediate_abort\"))]\n    unsafe {\n        core::intrinsics::const_eval_select((layout,), ct_error, rt_error)\n    }\n\n    #[cfg(feature = \"panic_immediate_abort\")]\n    ct_error(layout)\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_alloc_error\", issue = \"92523\")]\n#[cfg(all(not(no_global_oom_handling), not(test)))]\n#[cold]\npub const fn handle_alloc_error(layout: Layout) -> ! {\n    const fn ct_error(_: Layout) -> ! {\n        panic!(\"allocation failed\");\n    }\n\n    fn rt_error(layout: Layout) -> ! {\n        unsafe {\n            __rust_alloc_error_handler(layout.size(), layout.align());\n        }\n    }\n\n    unsafe { core::intrinsics::const_eval_select((layout,), ct_error, rt_error) }\n}"
    },
    {
        "name": "mul",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "core::time",
        "type": "method",
        "signature": "impl Mul<Duration> for u32",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl Mul<Duration> for u32 {\n    type Output = Duration;\n\n    #[inline]\n    fn mul(self, rhs: Duration) -> Duration {\n        rhs * self\n    }\n}",
        "old_source_code": "impl Mul<Duration> for u32 {\n    type Output = Duration;\n\n    fn mul(self, rhs: Duration) -> Duration {\n        rhs * self\n    }\n}"
    },
    {
        "name": "pop",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "alloc::vec",
        "type": "method",
        "signature": "pub fn pop(&mut self) -> Option<T>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn pop(&mut self) -> Option<T> {\n        if self.len == 0 {\n            None\n        } else {\n            unsafe {\n                self.len -= 1;\n                core::intrinsics::assume(self.len < self.capacity());\n                Some(ptr::read(self.as_ptr().add(self.len())))\n            }\n        }\n    }",
        "old_source_code": "    pub fn pop(&mut self) -> Option<T> {\n        if self.len == 0 {\n            None\n        } else {\n            unsafe {\n                self.len -= 1;\n                Some(ptr::read(self.as_ptr().add(self.len())))\n            }\n        }\n    }"
    },
    {
        "name": "assume_init_read",
        "from_version": "1.75.0",
        "to_version": "1.76.0",
        "module": "std::mem::MaybeUninit",
        "type": "method",
        "signature": "pub const unsafe fn assume_init_read(&self) -> T",
        "change_type": "signature",
        "documentation": "Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\nto the usual drop handling.\n\nWhenever possible, it is preferable to use [`assume_init`] instead, which\nprevents duplicating the content of the `MaybeUninit<T>`.\n\n# Safety\n\nIt is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\nstate. Calling this when the content is not yet fully initialized causes undefined\nbehavior. The [type-level documentation][inv] contains more information about\nthis initialization invariant.\n\nMoreover, similar to the [`ptr::read`] function, this function creates a\nbitwise copy of the contents, regardless whether the contained type\nimplements the [`Copy`] trait or not. When using multiple copies of the\ndata (by calling `assume_init_read` multiple times, or first calling\n`assume_init_read` and then [`assume_init`]), it is your responsibility\nto ensure that data may indeed be duplicated.\n\n[inv]: #initialization-invariant\n[`assume_init`]: MaybeUninit::assume_init\n",
        "examples": [
            "",
            "Correct usage of this method:",
            "",
            "```rust",
            "use std::mem::MaybeUninit;",
            "",
            "let mut x = MaybeUninit::<u32>::uninit();",
            "x.write(13);",
            "let x1 = unsafe { x.assume_init_read() };",
            "// `u32` is `Copy`, so we may read multiple times.",
            "let x2 = unsafe { x.assume_init_read() };",
            "assert_eq!(x1, x2);",
            "",
            "let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();",
            "x.write(None);",
            "let x1 = unsafe { x.assume_init_read() };",
            "// Duplicating a `None` value is okay, so we may read multiple times.",
            "let x2 = unsafe { x.assume_init_read() };",
            "assert_eq!(x1, x2);",
            "```",
            "",
            "*Incorrect* usage of this method:",
            "",
            "```rust,no_run",
            "use std::mem::MaybeUninit;",
            "",
            "let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();",
            "x.write(Some(vec![0, 1, 2]));",
            "let x1 = unsafe { x.assume_init_read() };",
            "let x2 = unsafe { x.assume_init_read() };",
            "// We now created two copies of the same vector, leading to a double-free  when",
            "// they both get dropped!",
            "```"
        ],
        "source_code": "    #[rustc_const_stable(feature = \"const_maybe_uninit_assume_init_read\", since = \"1.75.0\")]\n    #[inline(always)]\n    #[track_caller]\n    pub const unsafe fn assume_init_read(&self) -> T {\n        // SAFETY: the caller must guarantee that `self` is initialized.\n        // Reading from `self.as_ptr()` is safe since `self` should be initialized.\n        unsafe {\n            intrinsics::assert_inhabited::<T>();\n            self.as_ptr().read()\n        }\n    }",
        "old_source_code": "    #[rustc_const_stable(\n        feature = \"const_maybe_uninit_assume_init_read\",\n        since = \"1.75.0\"\n    )]\n    #[inline(always)]\n    #[track_caller]\n    pub const unsafe fn assume_init_read(&self) -> T {\n        // SAFETY: the caller must guarantee that `self` is initialized.\n        // Reading from `self.as_ptr()` is safe since `self` should be initialized.\n        unsafe {\n            intrinsics::assert_inhabited::<T>();\n            self.as_ptr().read()\n        }\n    }"
    },
    {
        "name": "alloc",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "std::sys::uefi::alloc",
        "type": "method",
        "signature": "unsafe impl GlobalAlloc for System",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "unsafe impl GlobalAlloc for System {\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        static EFI_MEMORY_TYPE: OnceLock<u32> = OnceLock::new();\n\n        // Return null pointer if boot services are not available\n        if crate::os::uefi::env::boot_services().is_none() {\n            return crate::ptr::null_mut();\n        }\n\n        // If boot services is valid then SystemTable is not null.\n        let system_table = crate::os::uefi::env::system_table().as_ptr().cast();\n\n        // Each loaded image has an image handle that supports `EFI_LOADED_IMAGE_PROTOCOL`. Thus, this\n        // will never fail.\n        let mem_type = EFI_MEMORY_TYPE.get_or_init(|| {\n            let protocol = helpers::image_handle_protocol::<loaded_image::Protocol>(\n                loaded_image::PROTOCOL_GUID,\n            )\n            .unwrap();\n            // Gives allocations the memory type that the data sections were loaded as.\n            unsafe { (*protocol.as_ptr()).image_data_type }\n        });\n\n        // The caller must ensure non-0 layout\n        unsafe { r_efi_alloc::raw::alloc(system_table, layout, *mem_type) }\n    }\n\n    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n        // Do nothing if boot services are not available\n        if crate::os::uefi::env::boot_services().is_none() {\n            return;\n        }\n\n        // If boot services is valid then SystemTable is not null.\n        let system_table = crate::os::uefi::env::system_table().as_ptr().cast();\n        // The caller must ensure non-0 layout\n        unsafe { r_efi_alloc::raw::dealloc(system_table, ptr, layout) }\n    }\n}",
        "old_source_code": "unsafe impl GlobalAlloc for System {\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        // Return null pointer if boot services are not available\n        if crate::os::uefi::env::boot_services().is_none() {\n            return crate::ptr::null_mut();\n        }\n\n        // If boot services is valid then SystemTable is not null.\n        let system_table = crate::os::uefi::env::system_table().as_ptr().cast();\n        // The caller must ensure non-0 layout\n        unsafe { r_efi_alloc::raw::alloc(system_table, layout, MEMORY_TYPE) }\n    }\n\n    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n        // Do nothing if boot services are not available\n        if crate::os::uefi::env::boot_services().is_none() {\n            return;\n        }\n\n        // If boot services is valid then SystemTable is not null.\n        let system_table = crate::os::uefi::env::system_table().as_ptr().cast();\n        // The caller must ensure non-0 layout\n        unsafe { r_efi_alloc::raw::dealloc(system_table, ptr, layout) }\n    }\n}"
    },
    {
        "name": "inspect",
        "from_version": "1.75.0",
        "to_version": "1.76.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn inspect<F: FnOnce(&T)>(self, f: F) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    pub fn inspect<F: FnOnce(&T)>(self, f: F) -> Self {\n        if let Some(ref x) = self {\n            f(x);\n        }\n\n        self\n    }",
        "old_source_code": ""
    },
    {
        "name": "inspect",
        "from_version": "1.75.0",
        "to_version": "1.76.0",
        "module": "core::result",
        "type": "method",
        "signature": "pub fn inspect<F: FnOnce(&T)>(self, f: F) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    pub fn inspect<F: FnOnce(&T)>(self, f: F) -> Self {\n        if let Ok(ref t) = self {\n            f(t);\n        }\n\n        self\n    }",
        "old_source_code": ""
    },
    {
        "name": "inspect_err",
        "from_version": "1.75.0",
        "to_version": "1.76.0",
        "module": "core::result",
        "type": "method",
        "signature": "pub fn inspect_err<F: FnOnce(&E)>(self, f: F) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    pub fn inspect_err<F: FnOnce(&E)>(self, f: F) -> Self {\n        if let Err(ref e) = self {\n            f(e);\n        }\n\n        self\n    }",
        "old_source_code": ""
    },
    {
        "name": "unwrap_or_clone",
        "from_version": "1.75.0",
        "to_version": "1.76.0",
        "module": "alloc::rc",
        "type": "function",
        "signature": "pub fn unwrap_or_clone(this: Self) -> T",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    pub fn unwrap_or_clone(this: Self) -> T {\n        Rc::try_unwrap(this).unwrap_or_else(|rc| (*rc).clone())\n    }",
        "old_source_code": ""
    },
    {
        "name": "set",
        "from_version": "1.75.0",
        "to_version": "1.76.0",
        "module": "core::cell",
        "type": "method",
        "signature": "pub fn set(&self, val: T)",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn set(&self, val: T) {\n        self.replace(val);\n    }",
        "old_source_code": "    pub fn set(&self, val: T) {\n        let old = self.replace(val);\n        drop(old);\n    }"
    },
    {
        "name": "new",
        "from_version": "1.75.0",
        "to_version": "1.76.0",
        "module": "std::collections::hash::map",
        "type": "function",
        "signature": "pub fn new() -> HashMap<K, V, RandomState>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn new() -> HashMap<K, V, RandomState> {\n        Default::default()\n    }",
        "old_source_code": "    #[inline]\n    #[allow(deprecated)]\n    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n    #[must_use]\n    pub const fn new() -> DefaultHasher {\n        DefaultHasher(SipHasher13::new_with_keys(0, 0))\n    }"
    },
    {
        "name": "eq",
        "from_version": "1.75.0",
        "to_version": "1.76.0",
        "module": "core::ptr::const_ptr",
        "type": "method",
        "signature": "impl<T: ?Sized> PartialEq for *const T",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl<T: ?Sized> PartialEq for *const T {\n    #[inline]\n    #[cfg_attr(not(bootstrap), allow(ambiguous_wide_pointer_comparisons))]\n    fn eq(&self, other: &*const T) -> bool {\n        *self == *other\n    }\n}",
        "old_source_code": "impl<T: ?Sized> PartialEq for *const T {\n    #[inline]\n    fn eq(&self, other: &*const T) -> bool {\n        *self == *other\n    }\n}"
    },
    {
        "name": "eq",
        "from_version": "1.75.0",
        "to_version": "1.76.0",
        "module": "core::ptr::mut_ptr",
        "type": "method",
        "signature": "impl<T: ?Sized> PartialEq for *mut T",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl<T: ?Sized> PartialEq for *mut T {\n    #[inline(always)]\n    #[cfg_attr(not(bootstrap), allow(ambiguous_wide_pointer_comparisons))]\n    fn eq(&self, other: &*mut T) -> bool {\n        *self == *other\n    }\n}",
        "old_source_code": "impl<T: ?Sized> PartialEq for *mut T {\n    #[inline(always)]\n    fn eq(&self, other: &*mut T) -> bool {\n        *self == *other\n    }\n}"
    },
    {
        "name": "eq",
        "from_version": "1.75.0",
        "to_version": "1.76.0",
        "module": "core::ptr::non_null",
        "type": "method",
        "signature": "impl<T: ?Sized> PartialEq for NonNull<T>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl<T: ?Sized> PartialEq for NonNull<T> {\n    #[inline]\n    #[cfg_attr(not(bootstrap), allow(ambiguous_wide_pointer_comparisons))]\n    fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }\n}",
        "old_source_code": "impl<T: ?Sized> PartialEq for NonNull<T> {\n    #[inline]\n    fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }\n}"
    },
    {
        "name": "round_ties_even",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "std::f64",
        "type": "method",
        "signature": "pub fn round_ties_even(self) -> f64",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn round_ties_even(self) -> f64 {\n        unsafe { intrinsics::rintf64(self) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "each_mut",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::array",
        "type": "method",
        "signature": "pub fn each_mut(&mut self) -> [&mut T; N]",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    pub fn each_mut(&mut self) -> [&mut T; N] {\n        from_trusted_iterator(self.iter_mut())\n    }",
        "old_source_code": ""
    },
    {
        "name": "new",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::slice::iter",
        "type": "function",
        "signature": "impl<'a, T: 'a, P> ChunkByMut<'a, T, P>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "impl<'a, T: 'a, P> ChunkByMut<'a, T, P> {\n    pub(super) fn new(slice: &'a mut [T], predicate: P) -> Self {\n        ChunkByMut { slice, predicate }\n    }\n}",
        "old_source_code": ""
    },
    {
        "name": "first_chunk",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub const fn first_chunk<const N: usize>(&self) -> Option<&[T; N]>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"slice_first_last_chunk\", since = \"1.77.0\")]\n    pub const fn first_chunk<const N: usize>(&self) -> Option<&[T; N]> {\n        if self.len() < N {\n            None\n        } else {\n            // SAFETY: We explicitly check for the correct number of elements,\n            //   and do not let the reference outlive the slice.\n            Some(unsafe { &*(self.as_ptr().cast::<[T; N]>()) })\n        }\n    }",
        "old_source_code": ""
    },
    {
        "name": "last_chunk_mut",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub const fn last_chunk_mut<const N: usize>(&mut self) -> Option<&mut [T; N]>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_unstable(feature = \"const_slice_first_last_chunk\", issue = \"111774\")]\n    pub const fn last_chunk_mut<const N: usize>(&mut self) -> Option<&mut [T; N]> {\n        if self.len() < N {\n            None\n        } else {\n            // SAFETY: We manually verified the bounds of the slice.\n            // FIXME: Without const traits, we need this instead of `get_unchecked`.\n            let last = unsafe { self.split_at_mut_unchecked(self.len() - N).1 };\n\n            // SAFETY: We explicitly check for the correct number of elements,\n            //   do not let the reference outlive the slice,\n            //   and require exclusive access to the entire slice to mutate the chunk.\n            Some(unsafe { &mut *(last.as_mut_ptr().cast::<[T; N]>()) })\n        }\n    }",
        "old_source_code": ""
    },
    {
        "name": "chunk_by_mut",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub fn chunk_by_mut<F>(&mut self, pred: F) -> ChunkByMut<'_, T, F>\n    where\n        F: FnMut(&T, &T) -> bool,",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn chunk_by_mut<F>(&mut self, pred: F) -> ChunkByMut<'_, T, F>\n    where\n        F: FnMut(&T, &T) -> bool,\n    {\n        ChunkByMut::new(self, pred)\n    }",
        "old_source_code": ""
    },
    {
        "name": "from_str",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::num::nonzero",
        "type": "function",
        "signature": "impl FromStr for NonZero<$Int>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "        impl FromStr for NonZero<$Int> {\n            type Err = ParseIntError;\n            fn from_str(src: &str) -> Result<Self, Self::Err> {\n                Self::new(<$Int>::from_str_radix(src, 10)?)\n                    .ok_or(ParseIntError {\n                        kind: IntErrorKind::Zero\n                    })\n            }\n        }",
        "old_source_code": "        impl FromStr for $Ty {\n            type Err = ParseIntError;\n            fn from_str(src: &str) -> Result<Self, Self::Err> {\n                Self::new(<$Int>::from_str_radix(src, 10)?)\n                    .ok_or(ParseIntError {\n                        kind: IntErrorKind::Zero\n                    })\n            }\n        }"
    },
    {
        "name": "read_to_string",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "std::fs",
        "type": "function",
        "signature": "pub fn read_to_string<P: AsRef<Path>>(path: P) -> io::Result<String>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "pub fn read_to_string<P: AsRef<Path>>(path: P) -> io::Result<String> {\n    fn inner(path: &Path) -> io::Result<String> {\n        let mut file = File::open(path)?;\n        let size = file.metadata().map(|m| m.len() as usize).ok();\n        let mut string = String::new();\n        string.try_reserve_exact(size.unwrap_or(0)).map_err(|_| io::ErrorKind::OutOfMemory)?;\n        io::default_read_to_string(&mut file, &mut string, size)?;\n        Ok(string)\n    }\n    inner(path.as_ref())\n}",
        "old_source_code": "pub fn read_to_string<P: AsRef<Path>>(path: P) -> io::Result<String> {\n    fn inner(path: &Path) -> io::Result<String> {\n        let mut file = File::open(path)?;\n        let size = file.metadata().map(|m| m.len() as usize).ok();\n        let mut string = String::with_capacity(size.unwrap_or(0));\n        io::default_read_to_string(&mut file, &mut string, size)?;\n        Ok(string)\n    }\n    inner(path.as_ref())\n}"
    },
    {
        "name": "checked_mul",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "without modifying the original\"]\n            pub const fn checked_mul(self, other: Self) -> Option<Self>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn checked_mul(self, other: Self) -> Option<Self> {\n                if let Some(result) = self.get().checked_mul(other.get()) {\n                    // SAFETY:\n                    // - `checked_mul` returns `None` on overflow\n                    // - `self` and `other` are non-zero\n                    // - the only way to get zero from a multiplication without overflow is for one\n                    //   of the sides to be zero\n                    //\n                    // So the result cannot be zero.\n                    Some(unsafe { Self::new_unchecked(result) })\n                } else {\n                    None\n                }\n            }",
        "old_source_code": "                #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n                #[must_use = \"this returns the result of the operation, \\\n                              without modifying the original\"]\n                #[inline]\n                pub const fn checked_mul(self, other: $Ty) -> Option<$Ty> {\n                    if let Some(result) = self.get().checked_mul(other.get()) {\n                        // SAFETY:\n                        // - `checked_mul` returns `None` on overflow\n                        // - `self` and `other` are non-zero\n                        // - the only way to get zero from a multiplication without overflow is for one\n                        //   of the sides to be zero\n                        //\n                        // So the result cannot be zero.\n                        Some(unsafe { $Ty::new_unchecked(result) })\n                    } else {\n                        None\n                    }\n                }"
    },
    {
        "name": "split_at",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub const fn split_at(&self, mid: usize) -> (&[T], &[T])",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_slice_split_at_not_mut\", since = \"1.71.0\")]\n    #[rustc_allow_const_fn_unstable(split_at_checked)]\n    #[inline]\n    #[track_caller]\n    #[must_use]\n    pub const fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        match self.split_at_checked(mid) {\n            Some(pair) => pair,\n            None => panic!(\"mid > len\"),\n        }\n    }",
        "old_source_code": "    #[rustc_const_stable(feature = \"const_slice_split_at_not_mut\", since = \"1.71.0\")]\n    #[rustc_allow_const_fn_unstable(slice_split_at_unchecked)]\n    #[inline]\n    #[track_caller]\n    #[must_use]\n    pub const fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        assert!(mid <= self.len());\n        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n        // fulfills the requirements of `split_at_unchecked`.\n        unsafe { self.split_at_unchecked(mid) }\n    }"
    },
    {
        "name": "partial_cmp",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::pin",
        "type": "method",
        "signature": "impl<Ptr: Deref, Q: Deref> PartialOrd<Pin<Q>> for Pin<Ptr>\nwhere\n    Ptr::Target: PartialOrd<Q::Target>,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<Ptr: Deref, Q: Deref> PartialOrd<Pin<Q>> for Pin<Ptr>\nwhere\n    Ptr::Target: PartialOrd<Q::Target>,\n{\n    fn partial_cmp(&self, other: &Pin<Q>) -> Option<cmp::Ordering> {\n        Ptr::Target::partial_cmp(self, other)\n    }\n\n    fn lt(&self, other: &Pin<Q>) -> bool {\n        Ptr::Target::lt(self, other)\n    }\n\n    fn le(&self, other: &Pin<Q>) -> bool {\n        Ptr::Target::le(self, other)\n    }\n\n    fn gt(&self, other: &Pin<Q>) -> bool {\n        Ptr::Target::gt(self, other)\n    }\n\n    fn ge(&self, other: &Pin<Q>) -> bool {\n        Ptr::Target::ge(self, other)\n    }\n}",
        "old_source_code": "impl<P: Deref, Q: Deref> PartialOrd<Pin<Q>> for Pin<P>\nwhere\n    P::Target: PartialOrd<Q::Target>,\n{\n    fn partial_cmp(&self, other: &Pin<Q>) -> Option<cmp::Ordering> {\n        P::Target::partial_cmp(self, other)\n    }\n\n    fn lt(&self, other: &Pin<Q>) -> bool {\n        P::Target::lt(self, other)\n    }\n\n    fn le(&self, other: &Pin<Q>) -> bool {\n        P::Target::le(self, other)\n    }\n\n    fn gt(&self, other: &Pin<Q>) -> bool {\n        P::Target::gt(self, other)\n    }\n\n    fn ge(&self, other: &Pin<Q>) -> bool {\n        P::Target::ge(self, other)\n    }\n}"
    },
    {
        "name": "new_unchecked",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::pin",
        "type": "function",
        "signature": "pub const unsafe fn new_unchecked(pointer: Ptr) -> Pin<Ptr>",
        "change_type": "signature",
        "documentation": "Construct a new `Pin<Ptr>` around a reference to some data of a type that\nmay or may not implement [`Unpin`].\n\nIf `pointer` dereferences to an [`Unpin`] type, [`Pin::new`] should be used\ninstead.\n\n# Safety\n\nThis constructor is unsafe because we cannot guarantee that the data\npointed to by `pointer` is pinned. At its core, pinning a value means making the\nguarantee that the value's data will not be moved nor have its storage invalidated until\nit gets dropped. For a more thorough explanation of pinning, see the [`pin` module docs].\n\nIf the caller that is constructing this `Pin<Ptr>` does not ensure that the data `Ptr`\npoints to is pinned, that is a violation of the API contract and may lead to undefined\nbehavior in later (even safe) operations.\n\nBy using this method, you are also making a promise about the [`Deref`] and\n[`DerefMut`] implementations of `Ptr`, if they exist. Most importantly, they\nmust not move out of their `self` arguments: `Pin::as_mut` and `Pin::as_ref`\nwill call `DerefMut::deref_mut` and `Deref::deref` *on the pointer type `Ptr`*\nand expect these methods to uphold the pinning invariants.\nMoreover, by calling this method you promise that the reference `Ptr`\ndereferences to will not be moved out of again; in particular, it\nmust not be possible to obtain a `&mut Ptr::Target` and then\nmove out of that reference (using, for example [`mem::swap`]).\n\nFor example, calling `Pin::new_unchecked` on an `&'a mut T` is unsafe because\nwhile you are able to pin it for the given lifetime `'a`, you have no control\nover whether it is kept pinned once `'a` ends, and therefore cannot uphold the\nguarantee that a value, once pinned, remains pinned until it is dropped:\n\n```\nuse std::mem;\nuse std::pin::Pin;\n\nfn move_pinned_ref<T>(mut a: T, mut b: T) {\nunsafe {\nlet p: Pin<&mut T> = Pin::new_unchecked(&mut a);\n// This should mean the pointee `a` can never move again.\n}\nmem::swap(&mut a, &mut b); // Potential UB down the road \n// The address of `a` changed to `b`'s stack slot, so `a` got moved even\n// though we have previously pinned it! We have violated the pinning API contract.\n}\n```\nA value, once pinned, must remain pinned until it is dropped (unless its type implements\n`Unpin`). Because `Pin<&mut T>` does not own the value, dropping the `Pin` will not drop\nthe value and will not end the pinning contract. So moving the value after dropping the\n`Pin<&mut T>` is still a violation of the API contract.\n\nSimilarly, calling `Pin::new_unchecked` on an `Rc<T>` is unsafe because there could be\naliases to the same data that are not subject to the pinning restrictions:\n```\nuse std::rc::Rc;\nuse std::pin::Pin;\n\nfn move_pinned_rc<T>(mut x: Rc<T>) {\n// This should mean the pointee can never move again.\nlet pin = unsafe { Pin::new_unchecked(Rc::clone(&x)) };\n{\nlet p: Pin<&T> = pin.as_ref();\n// ...\n}\ndrop(pin);\n\nlet content = Rc::get_mut(&mut x).unwrap(); // Potential UB down the road \n// Now, if `x` was the only reference, we have a mutable reference to\n// data that we pinned above, which we could use to move it as we have\n// seen in the previous example. We have violated the pinning API contract.\n}\n```\n\n## Pinning of closure captures\n\nParticular care is required when using `Pin::new_unchecked` in a closure:\n`Pin::new_unchecked(&mut var)` where `var` is a by-value (moved) closure capture\nimplicitly makes the promise that the closure itself is pinned, and that *all* uses\nof this closure capture respect that pinning.\n```\nuse std::pin::Pin;\nuse std::task::Context;\nuse std::future::Future;\n\nfn move_pinned_closure(mut x: impl Future, cx: &mut Context<'_>) {\n// Create a closure that moves `x`, and then internally uses it in a pinned way.\nlet mut closure = move || unsafe {\nlet _ignore = Pin::new_unchecked(&mut x).poll(cx);\n};\n// Call the closure, so the future can assume it has been pinned.\nclosure();\n// Move the closure somewhere else. This also moves `x`!\nlet mut moved = closure;\n// Calling it again means we polled the future from two different locations,\n// violating the pinning API contract.\nmoved(); // Potential UB \n}\n```\nWhen passing a closure to another API, it might be moving the closure any time, so\n`Pin::new_unchecked` on closure captures may only be used if the API explicitly documents\nthat the closure is pinned.\n\nThe better alternative is to avoid all that trouble and do the pinning in the outer function\ninstead (here using the [`pin!`][crate::pin::pin] macro):\n```\nuse std::pin::pin;\nuse std::task::Context;\nuse std::future::Future;\n\nfn move_pinned_closure(mut x: impl Future, cx: &mut Context<'_>) {\nlet mut x = pin!(x);\n// Create a closure that captures `x: Pin<&mut _>`, which is safe to move.\nlet mut closure = move || {\nlet _ignore = x.as_mut().poll(cx);\n};\n// Call the closure, so the future can assume it has been pinned.\nclosure();\n// Move the closure somewhere else.\nlet mut moved = closure;\n// Calling it again here is fine (except that we might be polling a future that already\n// returned `Poll::Ready`, but that is a separate problem).\nmoved();\n}\n```\n\n[`mem::swap`]: crate::mem::swap\n[`pin` module docs]: self",
        "source_code": "    pub const unsafe fn new_unchecked(pointer: Ptr) -> Pin<Ptr> {\n        Pin { __pointer: pointer }\n    }",
        "old_source_code": "    pub const unsafe fn new_unchecked(pointer: P) -> Pin<P> {\n        Pin { pointer }\n    }"
    },
    {
        "name": "read",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "std::io::util",
        "type": "method",
        "signature": "impl Read for Repeat",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl Read for Repeat {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        for slot in &mut *buf {\n            *slot = self.byte;\n        }\n        Ok(buf.len())\n    }\n\n    fn read_buf(&mut self, mut buf: BorrowedCursor<'_>) -> io::Result<()> {\n        // SAFETY: No uninit bytes are being written\n        for slot in unsafe { buf.as_mut() } {\n            slot.write(self.byte);\n        }\n\n        let remaining = buf.capacity();\n\n        // SAFETY: the entire unfilled portion of buf has been initialized\n        unsafe {\n            buf.advance(remaining);\n        }\n\n        Ok(())\n    }\n\n    /// This function is not supported by `io::Repeat`, because there's no end of its data\n    fn read_to_end(&mut self, _: &mut Vec<u8>) -> io::Result<usize> {\n        Err(io::Error::from(io::ErrorKind::OutOfMemory))\n    }\n\n    /// This function is not supported by `io::Repeat`, because there's no end of its data\n    fn read_to_string(&mut self, _: &mut String) -> io::Result<usize> {\n        Err(io::Error::from(io::ErrorKind::OutOfMemory))\n    }\n\n    #[inline]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let mut nwritten = 0;\n        for buf in bufs {\n            nwritten += self.read(buf)?;\n        }\n        Ok(nwritten)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        true\n    }\n}",
        "old_source_code": "impl Read for Repeat {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        for slot in &mut *buf {\n            *slot = self.byte;\n        }\n        Ok(buf.len())\n    }\n\n    fn read_buf(&mut self, mut buf: BorrowedCursor<'_>) -> io::Result<()> {\n        // SAFETY: No uninit bytes are being written\n        for slot in unsafe { buf.as_mut() } {\n            slot.write(self.byte);\n        }\n\n        let remaining = buf.capacity();\n\n        // SAFETY: the entire unfilled portion of buf has been initialized\n        unsafe {\n            buf.advance(remaining);\n        }\n\n        Ok(())\n    }\n\n    #[inline]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let mut nwritten = 0;\n        for buf in bufs {\n            nwritten += self.read(buf)?;\n        }\n        Ok(nwritten)\n    }\n\n    #[inline]\n    fn is_read_vectored(&self) -> bool {\n        true\n    }\n}"
    },
    {
        "name": "next",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "std::collections::hash::map",
        "type": "method",
        "signature": "impl<'a, K, V> Iterator for Drain<'a, K, V>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl<'a, K, V> Iterator for Drain<'a, K, V> {\n    type Item = (K, V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(K, V)> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n    #[inline]\n    fn fold<B, F>(self, init: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        self.base.fold(init, f)\n    }\n}",
        "old_source_code": "impl<'a, K, V> Iterator for Drain<'a, K, V> {\n    type Item = (K, V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(K, V)> {\n        self.base.next()\n    }\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.base.size_hint()\n    }\n}"
    },
    {
        "name": "deref_mut",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::pin",
        "type": "method",
        "signature": "impl<Ptr: DerefMut<Target: Unpin>> DerefMut for Pin<Ptr>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<Ptr: DerefMut<Target: Unpin>> DerefMut for Pin<Ptr> {\n    fn deref_mut(&mut self) -> &mut Ptr::Target {\n        Pin::get_mut(Pin::as_mut(self))\n    }\n}",
        "old_source_code": "impl<P: DerefMut<Target: Unpin>> DerefMut for Pin<P> {\n    fn deref_mut(&mut self) -> &mut P::Target {\n        Pin::get_mut(Pin::as_mut(self))\n    }\n}"
    },
    {
        "name": "next",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::slice::iter",
        "type": "method",
        "signature": "impl<'a, T: 'a, P> Iterator for ChunkByMut<'a, T, P>\nwhere\n    P: FnMut(&T, &T) -> bool,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<'a, T: 'a, P> Iterator for ChunkByMut<'a, T, P>\nwhere\n    P: FnMut(&T, &T) -> bool,\n{\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.slice.is_empty() {\n            None\n        } else {\n            let mut len = 1;\n            let mut iter = self.slice.windows(2);\n            while let Some([l, r]) = iter.next() {\n                if (self.predicate)(l, r) { len += 1 } else { break }\n            }\n            let slice = mem::take(&mut self.slice);\n            let (head, tail) = slice.split_at_mut(len);\n            self.slice = tail;\n            Some(head)\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.slice.is_empty() { (0, Some(0)) } else { (1, Some(self.slice.len())) }\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }\n}",
        "old_source_code": "impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n        if self.v.len() < self.chunk_size {\n            None\n        } else {\n            let len = self.v.len();\n            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n            let (head, tail) = unsafe { self.v.split_at_mut(len - self.chunk_size) };\n            self.v = head;\n            // SAFETY: Nothing else points to or will point to the contents of this slice.\n            Some(unsafe { &mut *tail })\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let n = self.v.len() / self.chunk_size;\n        (n, Some(n))\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<&'a mut [T]> {\n        let (end, overflow) = n.overflowing_mul(self.chunk_size);\n        if end >= self.v.len() || overflow {\n            self.v = &mut [];\n            None\n        } else {\n            let len = self.v.len();\n            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n            let (fst, _) = unsafe { self.v.split_at_mut(len - end) };\n            self.v = fst;\n            self.next()\n        }\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<Self::Item> {\n        self.next_back()\n    }\n\n    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n        let end = self.v.len() - idx * self.chunk_size;\n        let start = end - self.chunk_size;\n        // SAFETY: see comments for `RChunksMut::__iterator_get_unchecked` and `self.v`.\n        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n    }\n}"
    },
    {
        "name": "unwrap",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub const fn unwrap(self) -> T",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n    pub const fn unwrap(self) -> T {\n        match self {\n            Some(val) => val,\n            None => unwrap_failed(),\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n    pub const fn unwrap(self) -> T {\n        match self {\n            Some(val) => val,\n            None => panic(\"called `Option::unwrap()` on a `None` value\"),\n        }\n    }"
    },
    {
        "name": "StdoutLock",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "std::io::stdio",
        "type": "struct",
        "signature": "pub struct StdoutLock<'a>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "pub struct StdoutLock<'a> {\n    inner: ReentrantLockGuard<'a, RefCell<LineWriter<StdoutRaw>>>,\n}",
        "old_source_code": "pub struct StdoutLock<'a> {\n    inner: ReentrantMutexGuard<'a, RefCell<LineWriter<StdoutRaw>>>,\n}"
    },
    {
        "name": "new",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "std::sync::poison",
        "type": "function",
        "signature": "pub fn new(_guard: T) -> PoisonError<T>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[track_caller]\n    pub fn new(_guard: T) -> PoisonError<T> {\n        panic!(\"PoisonError created in a libstd built with panic=\\\"abort\\\"\")\n    }",
        "old_source_code": "    pub fn new(guard: T) -> PoisonError<T> {\n        PoisonError { guard }\n    }"
    },
    {
        "name": "park",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "std::thread",
        "type": "function",
        "signature": "pub fn park()",
        "change_type": "implicit",
        "documentation": "Blocks unless or until the current thread's token is made available.\n\nA call to `park` does not guarantee that the thread will remain parked\nforever, and callers should be prepared for this possibility. However,\nit is guaranteed that this function will not panic (it may abort the\nprocess if the implementation encounters some rare errors).\n\n# `park` and `unpark`\n\nEvery thread is equipped with some basic low-level blocking support, via the\n[`thread::park`][`park`] function and [`thread::Thread::unpark`][`unpark`]\nmethod. [`park`] blocks the current thread, which can then be resumed from\nanother thread by calling the [`unpark`] method on the blocked thread's\nhandle.\n\nConceptually, each [`Thread`] handle has an associated token, which is\ninitially not present:\n\n* The [`thread::park`][`park`] function blocks the current thread unless or\nuntil the token is available for its thread handle, at which point it\natomically consumes the token. It may also return *spuriously*, without\nconsuming the token. [`thread::park_timeout`] does the same, but allows\nspecifying a maximum time to block the thread for.\n\n* The [`unpark`] method on a [`Thread`] atomically makes the token available\nif it wasn't already. Because the token is initially absent, [`unpark`]\nfollowed by [`park`] will result in the second call returning immediately.\n\nThe API is typically used by acquiring a handle to the current thread,\nplacing that handle in a shared data structure so that other threads can\nfind it, and then `park`ing in a loop. When some desired condition is met, another\nthread calls [`unpark`] on the handle.\n\nThe motivation for this design is twofold:\n\n* It avoids the need to allocate mutexes and condvars when building new\nsynchronization primitives; the threads already provide basic\nblocking/signaling.\n\n* It can be implemented very efficiently on many platforms.\n\n# Memory Ordering\n\nCalls to `park` _synchronize-with_ calls to `unpark`, meaning that memory\noperations performed before a call to `unpark` are made visible to the thread that\nconsumes the token and returns from `park`. Note that all `park` and `unpark`\noperations for a given thread form a total order and `park` synchronizes-with\n_all_ prior `unpark` operations.\n\nIn atomic ordering terms, `unpark` performs a `Release` operation and `park`\nperforms the corresponding `Acquire` operation. Calls to `unpark` for the same\nthread form a [release sequence].\n\nNote that being unblocked does not imply a call was made to `unpark`, because\nwakeups can also be spurious. For example, a valid, but inefficient,\nimplementation could have `park` and `unpark` return immediately without doing anything,\nmaking *all* wakeups spurious.\n",
        "examples": [
            "",
            "```",
            "use std::thread;",
            "use std::sync::{Arc, atomic::{Ordering, AtomicBool}};",
            "use std::time::Duration;",
            "",
            "let flag = Arc::new(AtomicBool::new(false));",
            "let flag2 = Arc::clone(&flag);",
            "",
            "let parked_thread = thread::spawn(move || {",
            "// We want to wait until the flag is set. We *could* just spin, but using",
            "// park/unpark is more efficient.",
            "while !flag2.load(Ordering::Relaxed) {",
            "println!(\"Parking thread\");",
            "thread::park();",
            "// We *could* get here spuriously, i.e., way before the 10ms below are over!",
            "// But that is no problem, we are in a loop until the flag is set anyway.",
            "println!(\"Thread unparked\");",
            "}",
            "println!(\"Flag received\");",
            "});",
            "",
            "// Let some time pass for the thread to be spawned.",
            "thread::sleep(Duration::from_millis(10));",
            "",
            "// Set the flag, and let the thread wake up.",
            "// There is no race condition here, if `unpark`",
            "// happens first, `park` will return immediately.",
            "// Hence there is no risk of a deadlock.",
            "flag.store(true, Ordering::Relaxed);",
            "println!(\"Unpark the thread\");",
            "parked_thread.thread().unpark();",
            "",
            "parked_thread.join().unwrap();",
            "```",
            "",
            "[`unpark`]: Thread::unpark",
            "[`thread::park_timeout`]: park_timeout",
            "[release sequence]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release_sequence"
        ],
        "source_code": "pub fn park() {\n    let guard = PanicGuard;\n    // SAFETY: park_timeout is called on the parker owned by this thread.\n    unsafe {\n        current().park();\n    }\n    // No panic occurred, do not abort.\n    forget(guard);\n}",
        "old_source_code": "pub fn park() {\n    let guard = PanicGuard;\n    // SAFETY: park_timeout is called on the parker owned by this thread.\n    unsafe {\n        current().inner.as_ref().parker().park();\n    }\n    // No panic occurred, do not abort.\n    forget(guard);\n}"
    },
    {
        "name": "from_raw_parts_mut",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "core::slice::raw",
        "type": "function",
        "signature": "pub const unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T]",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "#[rustc_const_unstable(feature = \"const_slice_from_raw_parts_mut\", issue = \"67456\")]\n#[must_use]\n#[rustc_diagnostic_item = \"slice_from_raw_parts_mut\"]\npub const unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n    unsafe {\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts_mut requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n                is_aligned_and_not_null(data, align)\n                && is_valid_allocation_size(size, len)\n        );\n        &mut *ptr::slice_from_raw_parts_mut(data, len)\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_slice_from_raw_parts_mut\", issue = \"67456\")]\n#[must_use]\n#[rustc_diagnostic_item = \"slice_from_raw_parts_mut\"]\npub const unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n    unsafe {\n        assert_unsafe_precondition!(\n            \"slice::from_raw_parts_mut requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            [T](data: *mut T, len: usize) => is_aligned_and_not_null(data)\n                && is_valid_allocation_size::<T>(len)\n        );\n        &mut *ptr::slice_from_raw_parts_mut(data, len)\n    }\n}"
    },
    {
        "name": "unwrap_unchecked",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub const unsafe fn unwrap_unchecked(self) -> T",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n    pub const unsafe fn unwrap_unchecked(self) -> T {\n        match self {\n            Some(val) => val,\n            // SAFETY: the safety contract must be upheld by the caller.\n            None => unsafe { hint::unreachable_unchecked() },\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n    pub const unsafe fn unwrap_unchecked(self) -> T {\n        debug_assert!(self.is_some());\n        match self {\n            Some(val) => val,\n            // SAFETY: the safety contract must be upheld by the caller.\n            None => unsafe { hint::unreachable_unchecked() },\n        }\n    }"
    },
    {
        "name": "Display",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "std::path",
        "type": "struct",
        "signature": "pub struct Display<'a>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "pub struct Display<'a> {\n    inner: os_str::Display<'a>,\n}",
        "old_source_code": "pub struct Display<'a> {\n    path: &'a Path,\n}"
    },
    {
        "name": "new",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "std::sync::barrier",
        "type": "function",
        "signature": "pub const fn new(n: usize) -> Barrier",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_barrier\", since = \"1.78.0\")]\n    #[must_use]\n    #[inline]\n    pub const fn new(n: usize) -> Barrier {\n        Barrier {\n            lock: Mutex::new(BarrierState { count: 0, generation_id: 0 }),\n            cvar: Condvar::new(),\n            num_threads: n,\n        }\n    }",
        "old_source_code": "    #[must_use]\n    pub fn new(n: usize) -> Barrier {\n        Barrier {\n            lock: Mutex::new(BarrierState { count: 0, generation_id: 0 }),\n            cvar: Condvar::new(),\n            num_threads: n,\n        }\n    }"
    },
    {
        "name": "display",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "std::path",
        "type": "method",
        "signature": "it returns an object that can be displayed\"]\n    pub fn display(&self) -> Display<'_>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[must_use = \"this does not display the path, \\\n                  it returns an object that can be displayed\"]\n    #[inline]\n    pub fn display(&self) -> Display<'_> {\n        Display { inner: self.inner.display() }\n    }",
        "old_source_code": "    #[must_use = \"this does not display the path, \\\n                  it returns an object that can be displayed\"]\n    #[inline]\n    pub fn display(&self) -> Display<'_> {\n        Display { path: self }\n    }"
    },
    {
        "name": "from",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "alloc::boxed",
        "type": "function",
        "signature": "impl<'a, 'b> From<Cow<'b, str>> for Box<dyn Error + 'a>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<'a, 'b> From<Cow<'b, str>> for Box<dyn Error + 'a> {\n    /// Converts a [`Cow`] into a box of dyn [`Error`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    /// use std::borrow::Cow;\n    ///\n    /// let a_cow_str_error = Cow::from(\"a str error\");\n    /// let a_boxed_error = Box::<dyn Error>::from(a_cow_str_error);\n    /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: Cow<'b, str>) -> Box<dyn Error + 'a> {\n        From::from(String::from(err))\n    }\n}",
        "old_source_code": "impl<'a> From<Cow<'a, str>> for Box<dyn Error> {\n    /// Converts a [`Cow`] into a box of dyn [`Error`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    /// use std::borrow::Cow;\n    ///\n    /// let a_cow_str_error = Cow::from(\"a str error\");\n    /// let a_boxed_error = Box::<dyn Error>::from(a_cow_str_error);\n    /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: Cow<'a, str>) -> Box<dyn Error> {\n        From::from(String::from(err))\n    }\n}"
    },
    {
        "name": "copy",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "std::ptr",
        "type": "function",
        "signature": "pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize)",
        "change_type": "implicit",
        "documentation": "Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\nand destination may overlap.\n\nIf the source and destination will *never* overlap,\n[`copy_nonoverlapping`] can be used instead.\n\n`copy` is semantically equivalent to C's [`memmove`], but with the argument\norder swapped. Copying takes place as if the bytes were copied from `src`\nto a temporary array and then copied from the array to `dst`.\n\nThe copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\nrequirements of `T`. The initialization state is preserved exactly.\n\n[`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n\n# Safety\n\nBehavior is undefined if any of the following conditions are violated:\n\n* `src` must be [valid] for reads of `count * size_of::<T>()` bytes, and must remain valid even\nwhen `dst` is written for `count * size_of::<T>()` bytes. (This means if the memory ranges\noverlap, the two pointers must not be subject to aliasing restrictions relative to each\nother.)\n\n* `dst` must be [valid] for writes of `count * size_of::<T>()` bytes, and must remain valid even\nwhen `src` is read for `count * size_of::<T>()` bytes.\n\n* Both `src` and `dst` must be properly aligned.\n\nLike [`read`], `copy` creates a bitwise copy of `T`, regardless of\nwhether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\nin the region beginning at `*src` and the region beginning at `*dst` can\n[violate memory safety][read-ownership].\n\nNote that even if the effectively copied size (`count * size_of::<T>()`) is\n`0`, the pointers must be properly aligned.\n\n[`read`]: crate::ptr::read\n[read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n[valid]: crate::ptr#safety\n\n# #[allow(dead_code)]\nunsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\nlet mut dst = Vec::with_capacity(elts);\n\n// SAFETY: Our precondition ensures the source is aligned and valid,\n// and `Vec::with_capacity` ensures that we have usable space to write them.\nptr::copy(ptr, dst.as_mut_ptr(), elts);\n\n// SAFETY: We created it with this much capacity earlier,\n// and the previous `copy` has initialized these elements.\ndst.set_len(elts);\ndst\n}\n```",
        "examples": [
            "",
            "Efficiently create a Rust vector from an unsafe buffer:",
            "",
            "```",
            "use std::ptr;",
            "",
            "/// # Safety",
            "///",
            "/// * `ptr` must be correctly aligned for its type and non-zero.",
            "/// * `ptr` must be valid for reads of `elts` contiguous elements of type `T`.",
            "/// * Those elements must not be used after calling this function unless `T: Copy`."
        ],
        "source_code": "#[rustc_allowed_through_unstable_modules]\n#[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.83.0\")]\n#[inline(always)]\n#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n#[rustc_diagnostic_item = \"ptr_copy\"]\npub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n    #[cfg_attr(bootstrap, rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.83.0\"))]\n    #[cfg_attr(not(bootstrap), rustc_intrinsic_const_stable_indirect)]\n    #[rustc_nounwind]\n    #[rustc_intrinsic]\n    #[rustc_intrinsic_must_be_overridden]\n    const unsafe fn copy<T>(_src: *const T, _dst: *mut T, _count: usize) {\n        unreachable!()\n    }\n\n    // SAFETY: the safety contract for `copy` must be upheld by the caller.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::copy requires that both pointer arguments are aligned and non-null\",\n            (\n                src: *const () = src as *const (),\n                dst: *mut () = dst as *mut (),\n                align: usize = align_of::<T>(),\n                zero_size: bool = T::IS_ZST || count == 0,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(src, align, zero_size)\n                && ub_checks::maybe_is_aligned_and_not_null(dst, align, zero_size)\n        );\n        copy(src, dst, count)\n    }\n}",
        "old_source_code": "#[rustc_allowed_through_unstable_modules]\n#[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.83.0\")]\n#[inline(always)]\n#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n#[rustc_diagnostic_item = \"ptr_copy\"]\npub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n    extern \"rust-intrinsic\" {\n        #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.83.0\")]\n        #[rustc_nounwind]\n        fn copy<T>(src: *const T, dst: *mut T, count: usize);\n    }\n\n    // SAFETY: the safety contract for `copy` must be upheld by the caller.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::copy requires that both pointer arguments are aligned and non-null\",\n            (\n                src: *const () = src as *const (),\n                dst: *mut () = dst as *mut (),\n                align: usize = align_of::<T>(),\n            ) =>\n            ub_checks::is_aligned_and_not_null(src, align)\n                && ub_checks::is_aligned_and_not_null(dst, align)\n        );\n        copy(src, dst, count)\n    }\n}"
    },
    {
        "name": "fmt",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "std::sync::poison",
        "type": "method",
        "signature": "impl<T> fmt::Display for TryLockError<T>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl<T> fmt::Display for TryLockError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            #[cfg(panic = \"unwind\")]\n            TryLockError::Poisoned(..) => \"poisoned lock: another task failed inside\",\n            #[cfg(not(panic = \"unwind\"))]\n            TryLockError::Poisoned(ref p) => match p._never {},\n            TryLockError::WouldBlock => \"try_lock failed because the operation would block\",\n        }\n        .fmt(f)\n    }\n}",
        "old_source_code": "impl<T> fmt::Display for TryLockError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            TryLockError::Poisoned(..) => \"poisoned lock: another task failed inside\",\n            TryLockError::WouldBlock => \"try_lock failed because the operation would block\",\n        }\n        .fmt(f)\n    }\n}"
    },
    {
        "name": "StderrLock",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "std::io::stdio",
        "type": "struct",
        "signature": "pub struct StderrLock<'a>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "pub struct StderrLock<'a> {\n    inner: ReentrantLockGuard<'a, RefCell<StderrRaw>>,\n}",
        "old_source_code": "pub struct StderrLock<'a> {\n    inner: ReentrantMutexGuard<'a, RefCell<StderrRaw>>,\n}"
    },
    {
        "name": "count_bytes",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "core::ffi::c_str",
        "type": "method",
        "signature": "pub const fn count_bytes(&self) -> usize",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_unstable(feature = \"const_cstr_from_ptr\", issue = \"113219\")]\n    pub const fn count_bytes(&self) -> usize {\n        self.inner.len() - 1\n    }",
        "old_source_code": ""
    },
    {
        "name": "unchecked_add",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::num::int_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            // SAFETY: the caller must uphold the safety contract for\n            // `unchecked_add`.\n            unsafe { intrinsics::unchecked_add(self, rhs) }\n        }"
    },
    {
        "name": "unchecked_mul",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::num::int_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            // SAFETY: the caller must uphold the safety contract for\n            // `unchecked_mul`.\n            unsafe { intrinsics::unchecked_mul(self, rhs) }\n        }"
    },
    {
        "name": "unchecked_sub",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::num::uint_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            // SAFETY: the caller must uphold the safety contract for\n            // `unchecked_sub`.\n            unsafe { intrinsics::unchecked_sub(self, rhs) }\n        }"
    },
    {
        "name": "unchecked_mul",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::num::uint_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            // SAFETY: the caller must uphold the safety contract for\n            // `unchecked_mul`.\n            unsafe { intrinsics::unchecked_mul(self, rhs) }\n        }"
    },
    {
        "name": "is_aligned",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::ptr::mut_ptr",
        "type": "method",
        "signature": "pub fn is_aligned(self) -> bool\n    where\n        T: Sized,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn is_aligned(self) -> bool\n    where\n        T: Sized,\n    {\n        self.is_aligned_to(mem::align_of::<T>())\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_pointer_is_aligned\", issue = \"104203\")]\n    pub const fn is_aligned(self) -> bool\n    where\n        T: Sized,\n    {\n        self.is_aligned_to(mem::align_of::<T>())\n    }"
    },
    {
        "name": "is_aligned",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "std::ptr::NonNull",
        "type": "method",
        "signature": "pub const fn is_aligned(self) -> bool\n    where\n        T: Sized,",
        "change_type": "stabilized",
        "documentation": "Returns whether the pointer is properly aligned for `T`.\n\n# At compiletime\n**Note: Alignment at compiletime is experimental and subject to change. See the\n[tracking issue] for details.**\n\nAt compiletime, the compiler may not know where a value will end up in memory.\nCalling this function on a pointer created from a reference at compiletime will only\nreturn `true` if the pointer is guaranteed to be aligned. This means that the pointer\nis never aligned if cast to a type with a stricter alignment than the reference's\nunderlying allocation.\n\n```\n#![feature(const_pointer_is_aligned)]\n#![feature(non_null_convenience)]\n#![feature(const_option)]\n#![feature(const_nonnull_new)]\nuse std::ptr::NonNull;\n\n// On some platforms, the alignment of primitives is less than their size.\n#[repr(align(4))]\nstruct AlignedI32(i32);\n#[repr(align(8))]\nstruct AlignedI64(i64);\n\nconst _: () = {\nlet data = [AlignedI32(42), AlignedI32(42)];\nlet ptr = NonNull::<AlignedI32>::new(&data[0] as *const _ as *mut _).unwrap();\nassert!(ptr.is_aligned());\n\n// At runtime either `ptr1` or `ptr2` would be aligned, but at compiletime neither is aligned.\nlet ptr1 = ptr.cast::<AlignedI64>();\nlet ptr2 = unsafe { ptr.add(1).cast::<AlignedI64>() };\nassert!(!ptr1.is_aligned());\nassert!(!ptr2.is_aligned());\n};\n```\n\nDue to this behavior, it is possible that a runtime pointer derived from a compiletime\npointer is aligned, even if the compiletime pointer wasn't aligned.\n\n```\n#![feature(const_pointer_is_aligned)]\n\n// On some platforms, the alignment of primitives is less than their size.\n#[repr(align(4))]\nstruct AlignedI32(i32);\n#[repr(align(8))]\nstruct AlignedI64(i64);\n\n// At compiletime, neither `COMPTIME_PTR` nor `COMPTIME_PTR + 1` is aligned.\nconst COMPTIME_PTR: *const AlignedI32 = &AlignedI32(42);\nconst _: () = assert!(!COMPTIME_PTR.cast::<AlignedI64>().is_aligned());\nconst _: () = assert!(!COMPTIME_PTR.wrapping_add(1).cast::<AlignedI64>().is_aligned());\n\n// At runtime, either `runtime_ptr` or `runtime_ptr + 1` is aligned.\nlet runtime_ptr = COMPTIME_PTR;\nassert_ne!(\nruntime_ptr.cast::<AlignedI64>().is_aligned(),\nruntime_ptr.wrapping_add(1).cast::<AlignedI64>().is_aligned(),\n);\n```\n\nIf a pointer is created from a fixed address, this function behaves the same during\nruntime and compiletime.\n\n```\n#![feature(const_pointer_is_aligned)]\n#![feature(const_option)]\n#![feature(const_nonnull_new)]\nuse std::ptr::NonNull;\n\n// On some platforms, the alignment of primitives is less than their size.\n#[repr(align(4))]\nstruct AlignedI32(i32);\n#[repr(align(8))]\nstruct AlignedI64(i64);\n\nconst _: () = {\nlet ptr = NonNull::new(40 as *mut AlignedI32).unwrap();\nassert!(ptr.is_aligned());\n\n// For pointers with a known address, runtime and compiletime behavior are identical.\nlet ptr1 = ptr.cast::<AlignedI64>();\nlet ptr2 = NonNull::new(ptr.as_ptr().wrapping_add(1)).unwrap().cast::<AlignedI64>();\nassert!(ptr1.is_aligned());\nassert!(!ptr2.is_aligned());\n};\n```\n\n[tracking issue]: https://github.com/rust-lang/rust/issues/104203",
        "examples": [
            "",
            "```",
            "use std::ptr::NonNull;",
            "",
            "// On some platforms, the alignment of i32 is less than 4.",
            "#[repr(align(4))]",
            "struct AlignedI32(i32);",
            "",
            "let data = AlignedI32(42);",
            "let ptr = NonNull::<AlignedI32>::from(&data);",
            "",
            "assert!(ptr.is_aligned());",
            "assert!(!NonNull::new(ptr.as_ptr().wrapping_byte_add(1)).unwrap().is_aligned());",
            "```",
            ""
        ],
        "source_code": "    #[rustc_const_unstable(feature = \"const_pointer_is_aligned\", issue = \"104203\")]\n    #[must_use]\n    #[inline]\n    pub const fn is_aligned(self) -> bool\n    where\n        T: Sized,\n    {\n        self.pointer.is_aligned()\n    }",
        "old_source_code": ""
    },
    {
        "name": "is_empty",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::ptr::non_null",
        "type": "method",
        "signature": "pub const fn is_empty(self) -> bool",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_slice_ptr_is_empty_nonnull\", since = \"1.79.0\")]\n    #[must_use]\n    #[inline]\n    pub const fn is_empty(self) -> bool {\n        self.len() == 0\n    }",
        "old_source_code": "    #[rustc_const_stable(\n        feature = \"const_slice_ptr_is_empty_nonnull\",\n        since = \"1.79.0\"\n    )]\n    #[must_use]\n    #[inline]\n    pub const fn is_empty(self) -> bool {\n        self.len() == 0\n    }"
    },
    {
        "name": "split_at_unchecked",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub const unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T])",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_slice_split_at_unchecked\", since = \"1.77.0\")]\n    #[inline]\n    #[must_use]\n    pub const unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n        // HACK: the const function `from_raw_parts` is used to make this\n        // function const; previously the implementation used\n        // `(self.get_unchecked(..mid), self.get_unchecked(mid..))`\n\n        let len = self.len();\n        let ptr = self.as_ptr();\n\n        assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        );\n\n        // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), len - mid)) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "checked_shr",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "core::num::uint_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[rustc_allow_const_fn_unstable(unchecked_shifts)]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            let (a, b) = self.overflowing_shr(rhs);\n            if unlikely!(b) { None } else { Some(a) }\n        }"
    },
    {
        "name": "checked_shr",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "core::num::int_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[rustc_allow_const_fn_unstable(unchecked_shifts)]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            let (a, b) = self.overflowing_shr(rhs);\n            if unlikely!(b) { None } else { Some(a) }\n        }"
    },
    {
        "name": "into_raw",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "alloc::boxed",
        "type": "function",
        "signature": "pub fn into_raw(b: Self) -> *mut T",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn into_raw(b: Self) -> *mut T {\n        // Make sure Miri realizes that we transition from a noalias pointer to a raw pointer here.\n        unsafe { &raw mut *&mut *Self::into_raw_with_allocator(b).0 }\n    }",
        "old_source_code": "    #[inline]\n    pub fn into_raw(b: Self) -> *mut T {\n        // Make sure Miri realizes that we transition from a noalias pointer to a raw pointer here.\n        unsafe { addr_of_mut!(*&mut *Self::into_raw_with_allocator(b).0) }\n    }"
    },
    {
        "name": "checked_sub",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "core::num::uint_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self >= rhs {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            } else {\n                None\n            }\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_sub(rhs);\n            if unlikely!(b) { None } else { Some(a) }\n        }"
    },
    {
        "name": "rotate_right",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::num::uint_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn rotate_right(self, n: u32) -> Self",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            #[cfg(not(bootstrap))]\n            return intrinsics::rotate_right(self, n);\n            #[cfg(bootstrap)]\n            return intrinsics::rotate_right(self, n as $SelfT);\n        }"
    },
    {
        "name": "rotate_left",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::num::uint_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn rotate_left(self, n: u32) -> Self",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            #[cfg(not(bootstrap))]\n            return intrinsics::rotate_left(self, n);\n            #[cfg(bootstrap)]\n            return intrinsics::rotate_left(self, n as $SelfT);\n        }"
    },
    {
        "name": "count_ones",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::num::uint_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn count_ones(self) -> u32",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            #[cfg(not(bootstrap))]\n            return intrinsics::ctpop(self as $ActualT);\n            #[cfg(bootstrap)]\n            return intrinsics::ctpop(self as $ActualT) as u32;\n        }"
    },
    {
        "name": "trailing_zeros",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::num::uint_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn trailing_zeros(self) -> u32",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            #[cfg(not(bootstrap))]\n            return intrinsics::cttz(self);\n            #[cfg(bootstrap)]\n            return intrinsics::cttz(self) as u32;\n        }"
    },
    {
        "name": "push",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "alloc::vec",
        "type": "method",
        "signature": "pub fn push(&mut self, value: T)",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[rustc_confusables(\"push_back\", \"put\", \"append\")]\n    pub fn push(&mut self, value: T) {\n        // Inform codegen that the length does not change across grow_one().\n        let len = self.len;\n        // This will panic or abort if we would allocate > isize::MAX bytes\n        // or if the length increment would overflow for zero-sized types.\n        if len == self.buf.capacity() {\n            self.buf.grow_one();\n        }\n        unsafe {\n            let end = self.as_mut_ptr().add(len);\n            ptr::write(end, value);\n            self.len = len + 1;\n        }\n    }",
        "old_source_code": "    #[rustc_confusables(\"push_back\", \"put\", \"append\")]\n    pub fn push(&mut self, value: T) {\n        // This will panic or abort if we would allocate > isize::MAX bytes\n        // or if the length increment would overflow for zero-sized types.\n        if self.len == self.buf.capacity() {\n            self.buf.reserve_for_push(self.len);\n        }\n        unsafe {\n            let end = self.as_mut_ptr().add(self.len);\n            ptr::write(end, value);\n            self.len += 1;\n        }\n    }"
    },
    {
        "name": "write_all",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "std::io",
        "type": "method",
        "signature": "fn write_all(&mut self, mut buf: &[u8]) -> Result<()>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n        while !buf.is_empty() {\n            match self.write(buf) {\n                Ok(0) => {\n                    return Err(Error::WRITE_ALL_EOF);\n                }\n                Ok(n) => buf = &buf[n..],\n                Err(ref e) if e.is_interrupted() => {}\n                Err(e) => return Err(e),\n            }\n        }\n        Ok(())\n    }",
        "old_source_code": "    fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n        while !buf.is_empty() {\n            match self.write(buf) {\n                Ok(0) => {\n                    return Err(error::const_io_error!(\n                        ErrorKind::WriteZero,\n                        \"failed to write whole buffer\",\n                    ));\n                }\n                Ok(n) => buf = &buf[n..],\n                Err(ref e) if e.is_interrupted() => {}\n                Err(e) => return Err(e),\n            }\n        }\n        Ok(())\n    }"
    },
    {
        "name": "checked_ilog",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "core::num::int_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else {\n                // Delegate to the unsigned implementation.\n                // The condition makes sure that both casts are exact.\n                (self as $UnsignedT).checked_ilog(base as $UnsignedT)\n            }\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else {\n                let mut n = 0;\n                let mut r = self;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    let b = Self::ilog2(self) / (Self::ilog2(base) + 1);\n                    n += b;\n                    r /= base.pow(b as u32);\n                }\n\n                while r >= base {\n                    r /= base;\n                    n += 1;\n                }\n                Some(n)\n            }\n        }"
    },
    {
        "name": "deref",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "std::sync::lazy_lock",
        "type": "method",
        "signature": "impl<T, F: FnOnce() -> T> Deref for LazyLock<T, F>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "impl<T, F: FnOnce() -> T> Deref for LazyLock<T, F> {\n    type Target = T;\n\n    /// Dereferences the value.\n    ///\n    /// This method will block the calling thread if another initialization\n    /// routine is currently running.\n    ///\n    #[inline]\n    fn deref(&self) -> &T {\n        LazyLock::force(self)\n    }\n}",
        "old_source_code": ""
    },
    {
        "name": "to_bits",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::net::ip_addr",
        "type": "method",
        "signature": "pub const fn to_bits(self) -> u128",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[must_use]\n    #[inline]\n    pub const fn to_bits(self) -> u128 {\n        u128::from_be_bytes(self.octets)\n    }",
        "old_source_code": ""
    },
    {
        "name": "add",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "std::ptr::NonNull",
        "type": "method",
        "signature": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,",
        "change_type": "stabilized",
        "documentation": "Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n\n`count` is in units of T; e.g., a `count` of 3 represents a pointer\noffset of `3 * size_of::<T>()` bytes.\n\n# Safety\n\nIf any of the following conditions are violated, the result is Undefined\nBehavior:\n\n* Both the starting and resulting pointer must be either in bounds or one\nbyte past the end of the same [allocated object].\n\n* The computed offset, **in bytes**, cannot overflow an `isize`.\n\n* The offset being in bounds cannot rely on \"wrapping around\" the address\nspace. That is, the infinite-precision sum must fit in a `usize`.\n\nThe compiler and standard library generally tries to ensure allocations\nnever reach a size where an offset is a concern. For instance, `Vec`\nand `Box` ensure they never allocate more than `isize::MAX` bytes, so\n`vec.as_ptr().add(vec.len())` is always safe.\n\nMost platforms fundamentally can't even construct such an allocation.\nFor instance, no known 64-bit platform can ever serve a request\nfor 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\nHowever, some 32-bit and 16-bit platforms may successfully serve a request for\nmore than `isize::MAX` bytes with things like Physical Address\nExtension. As such, memory acquired directly from allocators or memory\nmapped files *may* be too large to handle with this function.\n\n[allocated object]: crate::ptr#allocated-object\n",
        "examples": [
            "",
            "```",
            "use std::ptr::NonNull;",
            "",
            "let s: &str = \"123\";",
            "let ptr: NonNull<u8> = NonNull::new(s.as_ptr().cast_mut()).unwrap();",
            "",
            "unsafe {",
            "println!(\"{}\", ptr.add(1).read() as char);",
            "println!(\"{}\", ptr.add(2).read() as char);",
            "}",
            "```"
        ],
        "source_code": "    #[rustc_const_stable(feature = \"non_null_convenience\", since = \"1.80.0\")]\n    pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.pointer, count) } }\n    }",
        "old_source_code": ""
    },
    {
        "name": "sub",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "std::ptr::NonNull",
        "type": "method",
        "signature": "pub const unsafe fn sub(self, count: usize) -> Self\n    where\n        T: Sized,",
        "change_type": "stabilized",
        "documentation": "Calculates the offset from a pointer (convenience for\n`.offset((count as isize).wrapping_neg())`).\n\n`count` is in units of T; e.g., a `count` of 3 represents a pointer\noffset of `3 * size_of::<T>()` bytes.\n\n# Safety\n\nIf any of the following conditions are violated, the result is Undefined\nBehavior:\n\n* Both the starting and resulting pointer must be either in bounds or one\nbyte past the end of the same [allocated object].\n\n* The computed offset cannot exceed `isize::MAX` **bytes**.\n\n* The offset being in bounds cannot rely on \"wrapping around\" the address\nspace. That is, the infinite-precision sum must fit in a usize.\n\nThe compiler and standard library generally tries to ensure allocations\nnever reach a size where an offset is a concern. For instance, `Vec`\nand `Box` ensure they never allocate more than `isize::MAX` bytes, so\n`vec.as_ptr().add(vec.len()).sub(vec.len())` is always safe.\n\nMost platforms fundamentally can't even construct such an allocation.\nFor instance, no known 64-bit platform can ever serve a request\nfor 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\nHowever, some 32-bit and 16-bit platforms may successfully serve a request for\nmore than `isize::MAX` bytes with things like Physical Address\nExtension. As such, memory acquired directly from allocators or memory\nmapped files *may* be too large to handle with this function.\n\n[allocated object]: crate::ptr#allocated-object\n",
        "examples": [
            "",
            "```",
            "use std::ptr::NonNull;",
            "",
            "let s: &str = \"123\";",
            "",
            "unsafe {",
            "let end: NonNull<u8> = NonNull::new(s.as_ptr().cast_mut()).unwrap().add(3);",
            "println!(\"{}\", end.sub(1).read() as char);",
            "println!(\"{}\", end.sub(2).read() as char);",
            "}",
            "```"
        ],
        "source_code": "    #[rustc_const_stable(feature = \"non_null_convenience\", since = \"1.80.0\")]\n    #[rustc_allow_const_fn_unstable(unchecked_neg)]\n    pub const unsafe fn sub(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        if T::IS_ZST {\n            // Pointer arithmetic does nothing when the pointee is a ZST.\n            self\n        } else {\n            // SAFETY: the caller must uphold the safety contract for `offset`.\n            // Because the pointee is *not* a ZST, that means that `count` is\n            // at most `isize::MAX`, and thus the negation cannot overflow.\n            unsafe { self.offset((count as isize).unchecked_neg()) }\n        }\n    }",
        "old_source_code": ""
    },
    {
        "name": "copy_to",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::ptr::non_null",
        "type": "method",
        "signature": "pub const unsafe fn copy_to(self, dest: NonNull<T>, count: usize)\n    where\n        T: Sized,",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n    pub const unsafe fn copy_to(self, dest: NonNull<T>, count: usize)\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `copy`.\n        unsafe { ptr::copy(self.pointer, dest.as_ptr(), count) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "copy_to_nonoverlapping",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::ptr::non_null",
        "type": "method",
        "signature": "pub const unsafe fn copy_to_nonoverlapping(self, dest: NonNull<T>, count: usize)\n    where\n        T: Sized,",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n    pub const unsafe fn copy_to_nonoverlapping(self, dest: NonNull<T>, count: usize)\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.\n        unsafe { ptr::copy_nonoverlapping(self.pointer, dest.as_ptr(), count) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "split_at_checked",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub const fn split_at_checked(&self, mid: usize) -> Option<(&[T], &[T])>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"split_at_checked\", since = \"1.80.0\")]\n    #[inline]\n    #[must_use]\n    pub const fn split_at_checked(&self, mid: usize) -> Option<(&[T], &[T])> {\n        if mid <= self.len() {\n            // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n            // fulfills the requirements of `split_at_unchecked`.\n            Some(unsafe { self.split_at_unchecked(mid) })\n        } else {\n            None\n        }\n    }",
        "old_source_code": ""
    },
    {
        "name": "split_at_mut_checked",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub const fn split_at_mut_checked(&mut self, mid: usize) -> Option<(&mut [T], &mut [T])>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_unstable(feature = \"const_slice_split_at_mut\", issue = \"101804\")]\n    #[inline]\n    #[must_use]\n    pub const fn split_at_mut_checked(&mut self, mid: usize) -> Option<(&mut [T], &mut [T])> {\n        if mid <= self.len() {\n            // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n            // fulfills the requirements of `split_at_unchecked`.\n            Some(unsafe { self.split_at_mut_unchecked(mid) })\n        } else {\n            None\n        }\n    }",
        "old_source_code": ""
    },
    {
        "name": "trim_ascii_start",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub const fn trim_ascii_start(&self) -> &str",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"byte_slice_trim_ascii\", since = \"1.80.0\")]\n    #[inline]\n    pub const fn trim_ascii_start(&self) -> &str {\n        // SAFETY: Removing ASCII characters from a `&str` does not invalidate\n        // UTF-8.\n        unsafe { core::str::from_utf8_unchecked(self.as_bytes().trim_ascii_start()) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "trim_ascii_end",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub const fn trim_ascii_end(&self) -> &str",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"byte_slice_trim_ascii\", since = \"1.80.0\")]\n    #[inline]\n    pub const fn trim_ascii_end(&self) -> &str {\n        // SAFETY: Removing ASCII characters from a `&str` does not invalidate\n        // UTF-8.\n        unsafe { core::str::from_utf8_unchecked(self.as_bytes().trim_ascii_end()) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "trim_ascii",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub const fn trim_ascii(&self) -> &str",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"byte_slice_trim_ascii\", since = \"1.80.0\")]\n    #[inline]\n    pub const fn trim_ascii(&self) -> &str {\n        // SAFETY: Removing ASCII characters from a `&str` does not invalidate\n        // UTF-8.\n        unsafe { core::str::from_utf8_unchecked(self.as_bytes().trim_ascii()) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "split_ascii_whitespace",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub fn split_ascii_whitespace(&self) -> SplitAsciiWhitespace<'_>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn split_ascii_whitespace(&self) -> SplitAsciiWhitespace<'_> {\n        let inner =\n            self.as_bytes().split(IsAsciiWhitespace).filter(BytesIsNotEmpty).map(UnsafeBytesToStr);\n        SplitAsciiWhitespace { inner }\n    }",
        "old_source_code": "    #[inline]\n    pub fn split_ascii_whitespace(&self) -> SplitAsciiWhitespace<'_> {\n        let inner = self\n            .as_bytes()\n            .split(u8::is_ascii_whitespace)\n            .filter(|s| !s.is_empty())\n            // SAFETY: the byte slice came from a string and was only split\n            // along character boundaries, so the resulting slices are strings.\n            .map(|bytes| unsafe { from_utf8_unchecked(bytes) });\n        SplitAsciiWhitespace { inner }\n    }"
    },
    {
        "name": "LocalKey",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "std::cell::Cell",
        "type": "struct",
        "signature": "pub struct LocalKey<T: 'static>",
        "change_type": "implicit",
        "documentation": "A thread local storage key which owns its contents.\n\nThis key uses the fastest possible implementation available to it for the\ntarget platform. It is instantiated with the [`thread_local!`] macro and the\nprimary method is the [`with`] method, though there are helpers to make\nworking with [`Cell`] types easier.\n\nThe [`with`] method yields a reference to the contained value which cannot\noutlive the current thread or escape the given closure.\n\n[`thread_local!`]: crate::thread_local\n\n# Initialization and Destruction\n\nInitialization is dynamically performed on the first call to a setter (e.g.\n[`with`]) within a thread, and values that implement [`Drop`] get\ndestructed when a thread exits. Some caveats apply, which are explained below.\n\nA `LocalKey`'s initializer cannot recursively depend on itself. Using a\n`LocalKey` in this way may cause panics, aborts or infinite recursion on\nthe first call to `with`.\n\n# Single-thread Synchronization\n\nThough there is no potential race with other threads, it is still possible to\nobtain multiple references to the thread-local data in different places on\nthe call stack. For this reason, only shared (`&T`) references may be obtained.\n\nTo allow obtaining an exclusive mutable reference (`&mut T`), typically a\n[`Cell`] or [`RefCell`] is used (see the [`std::cell`] for more information\non how exactly this works). To make this easier there are specialized\nimplementations for [`LocalKey<Cell<T>>`] and [`LocalKey<RefCell<T>>`].\n\n[`std::cell`]: `crate::cell`\n[`LocalKey<Cell<T>>`]: struct.LocalKey.html#impl-LocalKey<Cell<T>>\n[`LocalKey<RefCell<T>>`]: struct.LocalKey.html#impl-LocalKey<RefCell<T>>\n\n\n# Platform-specific behavior\n\nNote that a \"best effort\" is made to ensure that destructors for types\nstored in thread local storage are run, but not all platforms can guarantee\nthat destructors will be run for all types in thread local storage. For\nexample, there are a number of known caveats where destructors are not run:\n\n1. On Unix systems when pthread-based TLS is being used, destructors will\nnot be run for TLS values on the main thread when it exits. Note that the\napplication will exit immediately after the main thread exits as well.\n2. On all platforms it's possible for TLS to re-initialize other TLS slots\nduring destruction. Some platforms ensure that this cannot happen\ninfinitely by preventing re-initialization of any slot that has been\ndestroyed, but not all platforms have this guard. Those platforms that do\nnot guard typically have a synthetic limit after which point no more\ndestructors are run.\n3. When the process exits on Windows systems, TLS destructors may only be\nrun on the thread that causes the process to exit. This is because the\nother threads may be forcibly terminated.\n\n## Synchronization in thread-local destructors\n\nOn Windows, synchronization operations (such as [`JoinHandle::join`]) in\nthread local destructors are prone to deadlocks and so should be avoided.\nThis is because the [loader lock] is held while a destructor is run. The\nlock is acquired whenever a thread starts or exits or when a DLL is loaded\nor unloaded. Therefore these events are blocked for as long as a thread\nlocal destructor is running.\n\n[loader lock]: https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices\n[`JoinHandle::join`]: crate::thread::JoinHandle::join\n[`with`]: LocalKey::with",
        "examples": [
            "",
            "```",
            "use std::cell::Cell;",
            "use std::thread;",
            "",
            "thread_local!(static FOO: Cell<u32> = Cell::new(1));",
            "",
            "assert_eq!(FOO.get(), 1);",
            "FOO.set(2);",
            "",
            "// each thread starts out with the initial value of 1",
            "let t = thread::spawn(move|| {",
            "assert_eq!(FOO.get(), 1);",
            "FOO.set(3);",
            "});",
            "",
            "// wait for the thread to complete and bail out on panic",
            "t.join().unwrap();",
            "",
            "// we retain our original value of 2 despite the child thread",
            "assert_eq!(FOO.get(), 2);",
            "```",
            ""
        ],
        "source_code": "pub struct LocalKey<T: 'static> {\n    // This outer `LocalKey<T>` type is what's going to be stored in statics,\n    // but actual data inside will sometimes be tagged with #[thread_local].\n    // It's not valid for a true static to reference a #[thread_local] static,\n    // so we get around that by exposing an accessor through a layer of function\n    // indirection (this thunk).\n    //\n    // Note that the thunk is itself unsafe because the returned lifetime of the\n    // slot where data lives, `'static`, is not actually valid. The lifetime\n    // here is actually slightly shorter than the currently running thread!\n    //\n    // Although this is an extra layer of indirection, it should in theory be\n    // trivially devirtualizable by LLVM because the value of `inner` never\n    // changes and the constant should be readonly within a crate. This mainly\n    // only runs into problems when TLS statics are exported across crates.\n    inner: fn(Option<&mut Option<T>>) -> *const T,\n}",
        "old_source_code": "pub struct LocalKey<T: 'static> {\n    // This outer `LocalKey<T>` type is what's going to be stored in statics,\n    // but actual data inside will sometimes be tagged with #[thread_local].\n    // It's not valid for a true static to reference a #[thread_local] static,\n    // so we get around that by exposing an accessor through a layer of function\n    // indirection (this thunk).\n    //\n    // Note that the thunk is itself unsafe because the returned lifetime of the\n    // slot where data lives, `'static`, is not actually valid. The lifetime\n    // here is actually slightly shorter than the currently running thread!\n    //\n    // Although this is an extra layer of indirection, it should in theory be\n    // trivially devirtualizable by LLVM because the value of `inner` never\n    // changes and the constant should be readonly within a crate. This mainly\n    // only runs into problems when TLS statics are exported across crates.\n    inner: unsafe fn(Option<&mut Option<T>>) -> Option<&'static T>,\n}"
    },
    {
        "name": "from_nanos",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::time",
        "type": "function",
        "signature": "pub const fn from_nanos(nanos: u64) -> Duration",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[must_use]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_nanos(nanos: u64) -> Duration {\n        const NANOS_PER_SEC: u64 = self::NANOS_PER_SEC as u64;\n        let secs = nanos / NANOS_PER_SEC;\n        let subsec_nanos = (nanos % NANOS_PER_SEC) as u32;\n        // SAFETY: x % 1_000_000_000 < 1_000_000_000\n        let subsec_nanos = unsafe { Nanoseconds(subsec_nanos) };\n\n        Duration { secs, nanos: subsec_nanos }\n    }",
        "old_source_code": "    #[must_use]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_nanos(nanos: u64) -> Duration {\n        Duration::new(nanos / (NANOS_PER_SEC as u64), (nanos % (NANOS_PER_SEC as u64)) as u32)\n    }"
    },
    {
        "name": "write_fmt",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "std::io",
        "type": "method",
        "signature": "fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> Result<()>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> Result<()> {\n        // Create a shim which translates a Write to a fmt::Write and saves\n        // off I/O errors. instead of discarding them\n        struct Adapter<'a, T: ?Sized + 'a> {\n            inner: &'a mut T,\n            error: Result<()>,\n        }\n\n        impl<T: Write + ?Sized> fmt::Write for Adapter<'_, T> {\n            fn write_str(&mut self, s: &str) -> fmt::Result {\n                match self.inner.write_all(s.as_bytes()) {\n                    Ok(()) => Ok(()),\n                    Err(e) => {\n                        self.error = Err(e);\n                        Err(fmt::Error)\n                    }\n                }\n            }\n        }\n\n        let mut output = Adapter { inner: self, error: Ok(()) };\n        match fmt::write(&mut output, fmt) {\n            Ok(()) => Ok(()),\n            Err(..) => {\n                // check if the error came from the underlying `Write` or not\n                if output.error.is_err() {\n                    output.error\n                } else {\n                    // This shouldn't happen: the underlying stream did not error, but somehow\n                    // the formatter still errored?\n                    panic!(\n                        \"a formatting trait implementation returned an error when the underlying stream did not\"\n                    );\n                }\n            }\n        }\n    }",
        "old_source_code": "    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> Result<()> {\n        // Create a shim which translates a Write to a fmt::Write and saves\n        // off I/O errors. instead of discarding them\n        struct Adapter<'a, T: ?Sized + 'a> {\n            inner: &'a mut T,\n            error: Result<()>,\n        }\n\n        impl<T: Write + ?Sized> fmt::Write for Adapter<'_, T> {\n            fn write_str(&mut self, s: &str) -> fmt::Result {\n                match self.inner.write_all(s.as_bytes()) {\n                    Ok(()) => Ok(()),\n                    Err(e) => {\n                        self.error = Err(e);\n                        Err(fmt::Error)\n                    }\n                }\n            }\n        }\n\n        let mut output = Adapter { inner: self, error: Ok(()) };\n        match fmt::write(&mut output, fmt) {\n            Ok(()) => Ok(()),\n            Err(..) => {\n                // check if the error came from the underlying `Write` or not\n                if output.error.is_err() {\n                    output.error\n                } else {\n                    Err(error::const_io_error!(ErrorKind::Uncategorized, \"formatter error\"))\n                }\n            }\n        }\n    }"
    },
    {
        "name": "next",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "alloc::vec::into_iter",
        "type": "method",
        "signature": "impl<T, A: Allocator> Iterator for IntoIter<T, A>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        let ptr = if T::IS_ZST {\n            if self.ptr.as_ptr() == self.end as *mut T {\n                return None;\n            }\n            // `ptr` has to stay where it is to remain aligned, so we reduce the length by 1 by\n            // reducing the `end`.\n            self.end = self.end.wrapping_byte_sub(1);\n            self.ptr\n        } else {\n            if self.ptr == non_null!(self.end, T) {\n                return None;\n            }\n            let old = self.ptr;\n            self.ptr = unsafe { old.add(1) };\n            old\n        };\n        Some(unsafe { ptr.read() })\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let exact = if T::IS_ZST {\n            self.end.addr().wrapping_sub(self.ptr.as_ptr().addr())\n        } else {\n            unsafe { non_null!(self.end, T).sub_ptr(self.ptr) }\n        };\n        (exact, Some(exact))\n    }\n\n    #[inline]\n    fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n        let step_size = self.len().min(n);\n        let to_drop = ptr::slice_from_raw_parts_mut(self.ptr.as_ptr(), step_size);\n        if T::IS_ZST {\n            // See `next` for why we sub `end` here.\n            self.end = self.end.wrapping_byte_sub(step_size);\n        } else {\n            // SAFETY: the min() above ensures that step_size is in bounds\n            self.ptr = unsafe { self.ptr.add(step_size) };\n        }\n        // SAFETY: the min() above ensures that step_size is in bounds\n        unsafe {\n            ptr::drop_in_place(to_drop);\n        }\n        NonZero::new(n - step_size).map_or(Ok(()), Err)\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn next_chunk<const N: usize>(&mut self) -> Result<[T; N], core::array::IntoIter<T, N>> {\n        let mut raw_ary = MaybeUninit::uninit_array();\n\n        let len = self.len();\n\n        if T::IS_ZST {\n            if len < N {\n                self.forget_remaining_elements();\n                // Safety: ZSTs can be conjured ex nihilo, only the amount has to be correct\n                return Err(unsafe { array::IntoIter::new_unchecked(raw_ary, 0..len) });\n            }\n\n            self.end = self.end.wrapping_byte_sub(N);\n            // Safety: ditto\n            return Ok(unsafe { raw_ary.transpose().assume_init() });\n        }\n\n        if len < N {\n            // Safety: `len` indicates that this many elements are available and we just checked that\n            // it fits into the array.\n            unsafe {\n                ptr::copy_nonoverlapping(self.ptr.as_ptr(), raw_ary.as_mut_ptr() as *mut T, len);\n                self.forget_remaining_elements();\n                return Err(array::IntoIter::new_unchecked(raw_ary, 0..len));\n            }\n        }\n\n        // Safety: `len` is larger than the array size. Copy a fixed amount here to fully initialize\n        // the array.\n        return unsafe {\n            ptr::copy_nonoverlapping(self.ptr.as_ptr(), raw_ary.as_mut_ptr() as *mut T, N);\n            self.ptr = self.ptr.add(N);\n            Ok(raw_ary.transpose().assume_init())\n        };\n    }\n\n    fn fold<B, F>(mut self, mut accum: B, mut f: F) -> B\n    where\n        F: FnMut(B, Self::Item) -> B,\n    {\n        if T::IS_ZST {\n            while self.ptr.as_ptr() != self.end.cast_mut() {\n                // SAFETY: we just checked that `self.ptr` is in bounds.\n                let tmp = unsafe { self.ptr.read() };\n                // See `next` for why we subtract from `end` here.\n                self.end = self.end.wrapping_byte_sub(1);\n                accum = f(accum, tmp);\n            }\n        } else {\n            // SAFETY: `self.end` can only be null if `T` is a ZST.\n            while self.ptr != non_null!(self.end, T) {\n                // SAFETY: we just checked that `self.ptr` is in bounds.\n                let tmp = unsafe { self.ptr.read() };\n                // SAFETY: the maximum this can be is `self.end`.\n                // Increment `self.ptr` first to avoid double dropping in the event of a panic.\n                self.ptr = unsafe { self.ptr.add(1) };\n                accum = f(accum, tmp);\n            }\n        }\n        accum\n    }\n\n    fn try_fold<B, F, R>(&mut self, mut accum: B, mut f: F) -> R\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> R,\n        R: core::ops::Try<Output = B>,\n    {\n        if T::IS_ZST {\n            while self.ptr.as_ptr() != self.end.cast_mut() {\n                // SAFETY: we just checked that `self.ptr` is in bounds.\n                let tmp = unsafe { self.ptr.read() };\n                // See `next` for why we subtract from `end` here.\n                self.end = self.end.wrapping_byte_sub(1);\n                accum = f(accum, tmp)?;\n            }\n        } else {\n            // SAFETY: `self.end` can only be null if `T` is a ZST.\n            while self.ptr != non_null!(self.end, T) {\n                // SAFETY: we just checked that `self.ptr` is in bounds.\n                let tmp = unsafe { self.ptr.read() };\n                // SAFETY: the maximum this can be is `self.end`.\n                // Increment `self.ptr` first to avoid double dropping in the event of a panic.\n                self.ptr = unsafe { self.ptr.add(1) };\n                accum = f(accum, tmp)?;\n            }\n        }\n        R::from_output(accum)\n    }\n\n    unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> Self::Item\n    where\n        Self: TrustedRandomAccessNoCoerce,\n    {\n        // SAFETY: the caller must guarantee that `i` is in bounds of the\n        // `Vec<T>`, so `i` cannot overflow an `isize`, and the `self.ptr.add(i)`\n        // is guaranteed to pointer to an element of the `Vec<T>` and\n        // thus guaranteed to be valid to dereference.\n        //\n        // Also note the implementation of `Self: TrustedRandomAccess` requires\n        // that `T: Copy` so reading elements from the buffer doesn't invalidate\n        // them for `Drop`.\n        unsafe { self.ptr.add(i).read() }\n    }\n}",
        "old_source_code": "impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        let ptr = if T::IS_ZST {\n            if self.ptr.as_ptr() == self.end as *mut T {\n                return None;\n            }\n            // `ptr` has to stay where it is to remain aligned, so we reduce the length by 1 by\n            // reducing the `end`.\n            self.end = self.end.wrapping_byte_sub(1);\n            self.ptr\n        } else {\n            if self.ptr == non_null!(self.end, T) {\n                return None;\n            }\n            let old = self.ptr;\n            self.ptr = unsafe { old.add(1) };\n            old\n        };\n        Some(unsafe { ptr.read() })\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let exact = if T::IS_ZST {\n            self.end.addr().wrapping_sub(self.ptr.as_ptr().addr())\n        } else {\n            unsafe { non_null!(self.end, T).sub_ptr(self.ptr) }\n        };\n        (exact, Some(exact))\n    }\n\n    #[inline]\n    fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n        let step_size = self.len().min(n);\n        let to_drop = ptr::slice_from_raw_parts_mut(self.ptr.as_ptr(), step_size);\n        if T::IS_ZST {\n            // See `next` for why we sub `end` here.\n            self.end = self.end.wrapping_byte_sub(step_size);\n        } else {\n            // SAFETY: the min() above ensures that step_size is in bounds\n            self.ptr = unsafe { self.ptr.add(step_size) };\n        }\n        // SAFETY: the min() above ensures that step_size is in bounds\n        unsafe {\n            ptr::drop_in_place(to_drop);\n        }\n        NonZero::new(n - step_size).map_or(Ok(()), Err)\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n\n    #[inline]\n    fn next_chunk<const N: usize>(&mut self) -> Result<[T; N], core::array::IntoIter<T, N>> {\n        let mut raw_ary = MaybeUninit::uninit_array();\n\n        let len = self.len();\n\n        if T::IS_ZST {\n            if len < N {\n                self.forget_remaining_elements();\n                // Safety: ZSTs can be conjured ex nihilo, only the amount has to be correct\n                return Err(unsafe { array::IntoIter::new_unchecked(raw_ary, 0..len) });\n            }\n\n            self.end = self.end.wrapping_byte_sub(N);\n            // Safety: ditto\n            return Ok(unsafe { raw_ary.transpose().assume_init() });\n        }\n\n        if len < N {\n            // Safety: `len` indicates that this many elements are available and we just checked that\n            // it fits into the array.\n            unsafe {\n                ptr::copy_nonoverlapping(self.ptr.as_ptr(), raw_ary.as_mut_ptr() as *mut T, len);\n                self.forget_remaining_elements();\n                return Err(array::IntoIter::new_unchecked(raw_ary, 0..len));\n            }\n        }\n\n        // Safety: `len` is larger than the array size. Copy a fixed amount here to fully initialize\n        // the array.\n        return unsafe {\n            ptr::copy_nonoverlapping(self.ptr.as_ptr(), raw_ary.as_mut_ptr() as *mut T, N);\n            self.ptr = self.ptr.add(N);\n            Ok(raw_ary.transpose().assume_init())\n        };\n    }\n\n    unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> Self::Item\n    where\n        Self: TrustedRandomAccessNoCoerce,\n    {\n        // SAFETY: the caller must guarantee that `i` is in bounds of the\n        // `Vec<T>`, so `i` cannot overflow an `isize`, and the `self.ptr.add(i)`\n        // is guaranteed to pointer to an element of the `Vec<T>` and\n        // thus guaranteed to be valid to dereference.\n        //\n        // Also note the implementation of `Self: TrustedRandomAccess` requires\n        // that `T: Copy` so reading elements from the buffer doesn't invalidate\n        // them for `Drop`.\n        unsafe { self.ptr.add(i).read() }\n    }\n}"
    },
    {
        "name": "split_whitespace",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub fn split_whitespace(&self) -> SplitWhitespace<'_>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[cfg_attr(not(test), rustc_diagnostic_item = \"str_split_whitespace\")]\n    #[inline]\n    pub fn split_whitespace(&self) -> SplitWhitespace<'_> {\n        SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n    }",
        "old_source_code": "    #[cfg_attr(not(test), rustc_diagnostic_item = \"str_split_whitespace\")]\n    #[inline]\n    pub fn split_whitespace(&self) -> SplitWhitespace<'_> {\n        SplitWhitespace { inner: self.split(char::is_whitespace).filter(|s| !s.is_empty()) }\n    }"
    },
    {
        "name": "to_radians",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::num::f64",
        "type": "method",
        "signature": "pub const fn to_radians(self) -> f64",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[rustc_const_unstable(feature = \"const_float_methods\", issue = \"130843\")]\n    #[inline]\n    pub const fn to_radians(self) -> f64 {\n        const RADS_PER_DEG: f64 = consts::PI / 180.0;\n        self * RADS_PER_DEG\n    }",
        "old_source_code": "    #[inline]\n    pub fn to_radians(self) -> f64 {\n        const RADS_PER_DEG: f64 = consts::PI / 180.0;\n        self * RADS_PER_DEG\n    }"
    },
    {
        "name": "escape_default",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub fn escape_default(&self) -> EscapeDefault<'_>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn escape_default(&self) -> EscapeDefault<'_> {\n        EscapeDefault { inner: self.chars().flat_map(CharEscapeDefault) }\n    }",
        "old_source_code": "    pub fn escape_default(&self) -> EscapeDefault<'_> {\n        EscapeDefault { inner: self.chars().flat_map(char::escape_default) }\n    }"
    },
    {
        "name": "read",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "std::io::cursor",
        "type": "method",
        "signature": "impl<T> Read for Cursor<T>\nwhere\n    T: AsRef<[u8]>,",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl<T> Read for Cursor<T>\nwhere\n    T: AsRef<[u8]>,\n{\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let n = Read::read(&mut self.remaining_slice(), buf)?;\n        self.pos += n as u64;\n        Ok(n)\n    }\n\n    fn read_buf(&mut self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n        let prev_written = cursor.written();\n\n        Read::read_buf(&mut self.remaining_slice(), cursor.reborrow())?;\n\n        self.pos += (cursor.written() - prev_written) as u64;\n\n        Ok(())\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let mut nread = 0;\n        for buf in bufs {\n            let n = self.read(buf)?;\n            nread += n;\n            if n < buf.len() {\n                break;\n            }\n        }\n        Ok(nread)\n    }\n\n    fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        let result = Read::read_exact(&mut self.remaining_slice(), buf);\n\n        match result {\n            Ok(_) => self.pos += buf.len() as u64,\n            // The only possible error condition is EOF, so place the cursor at \"EOF\"\n            Err(_) => self.pos = self.inner.as_ref().len() as u64,\n        }\n\n        result\n    }\n\n    fn read_buf_exact(&mut self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n        let prev_written = cursor.written();\n\n        let result = Read::read_buf_exact(&mut self.remaining_slice(), cursor.reborrow());\n        self.pos += (cursor.written() - prev_written) as u64;\n\n        result\n    }\n\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        let content = self.remaining_slice();\n        let len = content.len();\n        buf.try_reserve(len)?;\n        buf.extend_from_slice(content);\n        self.pos += len as u64;\n\n        Ok(len)\n    }\n\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n        let content =\n            crate::str::from_utf8(self.remaining_slice()).map_err(|_| io::Error::INVALID_UTF8)?;\n        let len = content.len();\n        buf.try_reserve(len)?;\n        buf.push_str(content);\n        self.pos += len as u64;\n\n        Ok(len)\n    }\n}",
        "old_source_code": "impl<T> Read for Cursor<T>\nwhere\n    T: AsRef<[u8]>,\n{\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n        let n = Read::read(&mut self.remaining_slice(), buf)?;\n        self.pos += n as u64;\n        Ok(n)\n    }\n\n    fn read_buf(&mut self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n        let prev_written = cursor.written();\n\n        Read::read_buf(&mut self.fill_buf()?, cursor.reborrow())?;\n\n        self.pos += (cursor.written() - prev_written) as u64;\n\n        Ok(())\n    }\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n        let mut nread = 0;\n        for buf in bufs {\n            let n = self.read(buf)?;\n            nread += n;\n            if n < buf.len() {\n                break;\n            }\n        }\n        Ok(nread)\n    }\n\n    fn is_read_vectored(&self) -> bool {\n        true\n    }\n\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        let n = buf.len();\n        Read::read_exact(&mut self.remaining_slice(), buf)?;\n        self.pos += n as u64;\n        Ok(())\n    }\n\n    fn read_buf_exact(&mut self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n        let n = cursor.capacity();\n        Read::read_buf_exact(&mut self.remaining_slice(), cursor)?;\n        self.pos += n as u64;\n        Ok(())\n    }\n}"
    },
    {
        "name": "fetch_not",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::sync::atomic",
        "type": "method",
        "signature": "pub fn fetch_not(&self, order: Ordering) -> bool",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[cfg(target_has_atomic = \"8\")]\n    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n    pub fn fetch_not(&self, order: Ordering) -> bool {\n        self.fetch_xor(true, order)\n    }",
        "old_source_code": ""
    },
    {
        "name": "checked_ilog2",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::num::uint_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn checked_ilog2(self) -> Option<u32>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            // FIXME: Simply use `NonZero::new` once it is actually generic.\n            if let Some(x) = <$NonZeroT>::new(self) {\n                Some(x.ilog2())\n            } else {\n                None\n            }\n        }"
    },
    {
        "name": "extend",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::iter::traits::collect",
        "type": "method",
        "signature": "impl<A, B, ExtendA, ExtendB> Extend<(A, B)> for (ExtendA, ExtendB)\nwhere\n    ExtendA: Extend<A>,\n    ExtendB: Extend<B>,",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl<A, B, ExtendA, ExtendB> Extend<(A, B)> for (ExtendA, ExtendB)\nwhere\n    ExtendA: Extend<A>,\n    ExtendB: Extend<B>,\n{\n    /// Allows to `extend` a tuple of collections that also implement `Extend`.\n    ///\n    /// See also: [`Iterator::unzip`]\n    ///\n    /// # Examples\n    /// ```\n    /// let mut tuple = (vec![0], vec![1]);\n    /// tuple.extend([(2, 3), (4, 5), (6, 7)]);\n    /// assert_eq!(tuple.0, [0, 2, 4, 6]);\n    /// assert_eq!(tuple.1, [1, 3, 5, 7]);\n    ///\n    /// // also allows for arbitrarily nested tuples as elements\n    /// let mut nested_tuple = (vec![1], (vec![2], vec![3]));\n    /// nested_tuple.extend([(4, (5, 6)), (7, (8, 9))]);\n    ///\n    /// let (a, (b, c)) = nested_tuple;\n    /// assert_eq!(a, [1, 4, 7]);\n    /// assert_eq!(b, [2, 5, 8]);\n    /// assert_eq!(c, [3, 6, 9]);\n    /// ```\n    fn extend<T: IntoIterator<Item = (A, B)>>(&mut self, into_iter: T) {\n        let (a, b) = self;\n        let iter = into_iter.into_iter();\n        SpecTupleExtend::extend(iter, a, b);\n    }\n\n    fn extend_one(&mut self, item: (A, B)) {\n        self.0.extend_one(item.0);\n        self.1.extend_one(item.1);\n    }\n\n    fn extend_reserve(&mut self, additional: usize) {\n        self.0.extend_reserve(additional);\n        self.1.extend_reserve(additional);\n    }\n\n    unsafe fn extend_one_unchecked(&mut self, item: (A, B)) {\n        // SAFETY: Those are our safety preconditions, and we correctly forward `extend_reserve`.\n        unsafe {\n            self.0.extend_one_unchecked(item.0);\n            self.1.extend_one_unchecked(item.1);\n        }\n    }\n}",
        "old_source_code": "impl<A, B, ExtendA, ExtendB> Extend<(A, B)> for (ExtendA, ExtendB)\nwhere\n    ExtendA: Extend<A>,\n    ExtendB: Extend<B>,\n{\n    /// Allows to `extend` a tuple of collections that also implement `Extend`.\n    ///\n    /// See also: [`Iterator::unzip`]\n    ///\n    /// # Examples\n    /// ```\n    /// let mut tuple = (vec![0], vec![1]);\n    /// tuple.extend([(2, 3), (4, 5), (6, 7)]);\n    /// assert_eq!(tuple.0, [0, 2, 4, 6]);\n    /// assert_eq!(tuple.1, [1, 3, 5, 7]);\n    ///\n    /// // also allows for arbitrarily nested tuples as elements\n    /// let mut nested_tuple = (vec![1], (vec![2], vec![3]));\n    /// nested_tuple.extend([(4, (5, 6)), (7, (8, 9))]);\n    ///\n    /// let (a, (b, c)) = nested_tuple;\n    /// assert_eq!(a, [1, 4, 7]);\n    /// assert_eq!(b, [2, 5, 8]);\n    /// assert_eq!(c, [3, 6, 9]);\n    /// ```\n    fn extend<T: IntoIterator<Item = (A, B)>>(&mut self, into_iter: T) {\n        let (a, b) = self;\n        let iter = into_iter.into_iter();\n\n        fn extend<'a, A, B>(\n            a: &'a mut impl Extend<A>,\n            b: &'a mut impl Extend<B>,\n        ) -> impl FnMut((), (A, B)) + 'a {\n            move |(), (t, u)| {\n                a.extend_one(t);\n                b.extend_one(u);\n            }\n        }\n\n        let (lower_bound, _) = iter.size_hint();\n        if lower_bound > 0 {\n            a.extend_reserve(lower_bound);\n            b.extend_reserve(lower_bound);\n        }\n\n        iter.fold((), extend(a, b));\n    }\n\n    fn extend_one(&mut self, item: (A, B)) {\n        self.0.extend_one(item.0);\n        self.1.extend_one(item.1);\n    }\n\n    fn extend_reserve(&mut self, additional: usize) {\n        self.0.extend_reserve(additional);\n        self.1.extend_reserve(additional);\n    }\n}"
    },
    {
        "name": "to_owned",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "alloc::str",
        "type": "method",
        "signature": "impl ToOwned for str",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl ToOwned for str {\n    type Owned = String;\n\n    #[inline]\n    fn to_owned(&self) -> String {\n        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }\n    }\n\n    #[inline]\n    fn clone_into(&self, target: &mut String) {\n        target.clear();\n        target.push_str(self);\n    }\n}",
        "old_source_code": "impl ToOwned for str {\n    type Owned = String;\n    #[inline]\n    fn to_owned(&self) -> String {\n        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }\n    }\n\n    fn clone_into(&self, target: &mut String) {\n        let mut b = mem::take(target).into_bytes();\n        self.as_bytes().clone_into(&mut b);\n        *target = unsafe { String::from_utf8_unchecked(b) }\n    }\n}"
    },
    {
        "name": "write",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "std::mem::MaybeUninit",
        "type": "method",
        "signature": "pub const fn write(&mut self, val: T) -> &mut T",
        "change_type": "implicit",
        "documentation": "Sets the value of the `MaybeUninit<T>`.\n\nThis overwrites any previous value without dropping it, so be careful\nnot to use this twice unless you want to skip running the destructor.\nFor your convenience, this also returns a mutable reference to the\n(now safely initialized) contents of `self`.\n\nAs the content is stored inside a `MaybeUninit`, the destructor is not\nrun for the inner data if the MaybeUninit leaves scope without a call to\n[`assume_init`], [`assume_init_drop`], or similar. Code that receives\nthe mutable reference returned by this function needs to keep this in\nmind. The safety model of Rust regards leaks as safe, but they are\nusually still undesirable. This being said, the mutable reference\nbehaves like any other mutable reference would, so assigning a new value\nto it will drop the old content.\n\n[`assume_init`]: Self::assume_init\n[`assume_init_drop`]: Self::assume_init_drop\n\n# // FIXME(https://github.com/rust-lang/miri/issues/3670):\n# // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n# unsafe { MaybeUninit::assume_init_drop(&mut x); }\n// This leaks the contained string:\nx.write(\"hello\".to_string());\n// x is initialized now:\nlet s = unsafe { x.assume_init() };\n```\n\nThis method can be used to avoid unsafe in some cases. The example below\nshows a part of an implementation of a fixed sized arena that lends out\npinned references.\nWith `write`, we can avoid the need to write through a raw pointer:\n\n```rust\nuse core::pin::Pin;\nuse core::mem::MaybeUninit;\n\nstruct PinArena<T> {\nmemory: Box<[MaybeUninit<T>]>,\nlen: usize,\n}\n\nimpl <T> PinArena<T> {\npub fn capacity(&self) -> usize {\nself.memory.len()\n}\npub fn push(&mut self, val: T) -> Pin<&mut T> {\nif self.len >= self.capacity() {\npanic!(\"Attempted to push to a full pin arena!\");\n}\nlet ref_ = self.memory[self.len].write(val);\nself.len += 1;\nunsafe { Pin::new_unchecked(ref_) }\n}\n}\n```",
        "examples": [
            "",
            "Correct usage of this method:",
            "",
            "```rust",
            "use std::mem::MaybeUninit;",
            "",
            "let mut x = MaybeUninit::<Vec<u8>>::uninit();",
            "",
            "{",
            "let hello = x.write((&b\"Hello, world!\").to_vec());",
            "// Setting hello does not leak prior allocations, but drops them",
            "*hello = (&b\"Hello\").to_vec();",
            "hello[0] = 'h' as u8;",
            "}",
            "// x is initialized now:",
            "let s = unsafe { x.assume_init() };",
            "assert_eq!(b\"hello\", s.as_slice());",
            "```",
            "",
            "This usage of the method causes a leak:",
            "",
            "```rust",
            "use std::mem::MaybeUninit;",
            "",
            "let mut x = MaybeUninit::<String>::uninit();",
            "",
            "x.write(\"Hello\".to_string());"
        ],
        "source_code": "    #[rustc_const_unstable(feature = \"const_maybe_uninit_write\", issue = \"63567\")]\n    #[inline(always)]\n    pub const fn write(&mut self, val: T) -> &mut T {\n        *self = MaybeUninit::new(val);\n        // SAFETY: We just initialized this value.\n        unsafe { self.assume_init_mut() }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_maybe_uninit_write\", issue = \"63567\")]\n    #[inline(always)]\n    pub const fn write(&mut self, val: T) -> &mut T {\n        *self = MaybeUninit::new(val);\n        // SAFETY: We just initialized this value.\n        unsafe { self.assume_init_mut() }\n    }"
    },
    {
        "name": "checked_add",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::num::uint_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if unlikely!(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_add(rhs);\n            if unlikely!(b) { None } else { Some(a) }\n        }"
    },
    {
        "name": "from_u32_unchecked",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::char::methods",
        "type": "function",
        "signature": "pub const unsafe fn from_u32_unchecked(i: u32) -> char",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_char_from_u32_unchecked\", since = \"1.81.0\")]\n    #[must_use]\n    #[inline]\n    pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n        // SAFETY: the safety contract must be upheld by the caller.\n        unsafe { super::convert::from_u32_unchecked(i) }\n    }",
        "old_source_code": "    #[rustc_const_stable(\n        feature = \"const_char_from_u32_unchecked\",\n        since = \"1.81.0\"\n    )]\n    #[must_use]\n    #[inline]\n    pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n        // SAFETY: the safety contract must be upheld by the caller.\n        unsafe { super::convert::from_u32_unchecked(i) }\n    }"
    },
    {
        "name": "spawn_unchecked",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "std::thread",
        "type": "method",
        "signature": "pub unsafe fn spawn_unchecked<F, T>(self, f: F) -> io::Result<JoinHandle<T>>\n    where\n        F: FnOnce() -> T,\n        F: Send,\n        T: Send,",
        "change_type": "stabilized",
        "documentation": "Spawns a new thread without any lifetime restrictions by taking ownership\nof the `Builder`, and returns an [`io::Result`] to its [`JoinHandle`].\n\nThe spawned thread may outlive the caller (unless the caller thread\nis the main thread; the whole process is terminated when the main\nthread finishes). The join handle can be used to block on\ntermination of the spawned thread, including recovering its panics.\n\nThis method is identical to [`thread::Builder::spawn`][`Builder::spawn`],\nexcept for the relaxed lifetime bounds, which render it unsafe.\nFor a more complete documentation see [`thread::spawn`][`spawn`].\n\n# Errors\n\nUnlike the [`spawn`] free function, this method yields an\n[`io::Result`] to capture any failure to create the thread at\nthe OS level.\n\n# Panics\n\nPanics if a thread name was set and it contained null bytes.\n\n# Safety\n\nThe caller has to ensure that the spawned thread does not outlive any\nreferences in the supplied thread closure and its return type.\nThis can be guaranteed in two ways:\n\n- ensure that [`join`][`JoinHandle::join`] is called before any referenced\ndata is dropped\n- use only types with `'static` lifetime bounds, i.e., those with no or only\n`'static` references (both [`thread::Builder::spawn`][`Builder::spawn`]\nand [`thread::spawn`][`spawn`] enforce this property statically)\n",
        "examples": [
            "",
            "```",
            "use std::thread;",
            "",
            "let builder = thread::Builder::new();",
            "",
            "let x = 1;",
            "let thread_x = &x;",
            "",
            "let handler = unsafe {",
            "builder.spawn_unchecked(move || {",
            "println!(\"x = {}\", *thread_x);",
            "}).unwrap()",
            "};",
            "",
            "// caller has to ensure `join()` is called, otherwise",
            "// it is possible to access freed memory if `x` gets",
            "// dropped before the thread closure is executed!",
            "handler.join().unwrap();",
            "```",
            "",
            "[`io::Result`]: crate::io::Result"
        ],
        "source_code": "    pub unsafe fn spawn_unchecked<F, T>(self, f: F) -> io::Result<JoinHandle<T>>\n    where\n        F: FnOnce() -> T,\n        F: Send,\n        T: Send,\n    {\n        Ok(JoinHandle(unsafe { self.spawn_unchecked_(f, None) }?))\n    }",
        "old_source_code": ""
    },
    {
        "name": "is_none_or",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn is_none_or(self, f: impl FnOnce(T) -> bool) -> bool",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    pub fn is_none_or(self, f: impl FnOnce(T) -> bool) -> bool {\n        match self {\n            None => true,\n            Some(x) => f(x),\n        }\n    }",
        "old_source_code": ""
    },
    {
        "name": "len",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::iter::adapters::take",
        "type": "method",
        "signature": "impl<F: FnMut() -> A, A> ExactSizeIterator for Take<crate::iter::RepeatWith<F>>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "impl<F: FnMut() -> A, A> ExactSizeIterator for Take<crate::iter::RepeatWith<F>> {\n    fn len(&self) -> usize {\n        self.n\n    }\n}",
        "old_source_code": ""
    },
    {
        "name": "clone",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::iter::sources::repeat_n",
        "type": "method",
        "signature": "impl<A: Clone> Clone for RepeatN<A>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "impl<A: Clone> Clone for RepeatN<A> {\n    fn clone(&self) -> RepeatN<A> {\n        RepeatN {\n            count: self.count,\n            element: self.element_ref().cloned().map_or_else(MaybeUninit::uninit, MaybeUninit::new),\n        }\n    }\n}",
        "old_source_code": ""
    },
    {
        "name": "fmt",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::iter::sources::repeat_n",
        "type": "method",
        "signature": "impl<A: fmt::Debug> fmt::Debug for RepeatN<A>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "impl<A: fmt::Debug> fmt::Debug for RepeatN<A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"RepeatN\")\n            .field(\"count\", &self.count)\n            .field(\"element\", &self.element_ref())\n            .finish()\n    }\n}",
        "old_source_code": ""
    },
    {
        "name": "next",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::iter::sources::repeat_n",
        "type": "method",
        "signature": "impl<A: Clone> Iterator for RepeatN<A>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "impl<A: Clone> Iterator for RepeatN<A> {\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n        if self.count > 0 {\n            // SAFETY: Just checked it's not empty\n            unsafe { Some(self.next_unchecked()) }\n        } else {\n            None\n        }\n    }\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.len();\n        (len, Some(len))\n    }\n\n    #[inline]\n    fn advance_by(&mut self, skip: usize) -> Result<(), NonZero<usize>> {\n        let len = self.count;\n\n        if skip >= len {\n            self.take_element();\n        }\n\n        if skip > len {\n            // SAFETY: we just checked that the difference is positive\n            Err(unsafe { NonZero::new_unchecked(skip - len) })\n        } else {\n            self.count = len - skip;\n            Ok(())\n        }\n    }\n\n    #[inline]\n    fn last(mut self) -> Option<A> {\n        self.take_element()\n    }\n\n    #[inline]\n    fn count(self) -> usize {\n        self.len()\n    }\n}",
        "old_source_code": ""
    },
    {
        "name": "len",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::iter::sources::repeat_n",
        "type": "method",
        "signature": "impl<A: Clone> ExactSizeIterator for RepeatN<A>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "impl<A: Clone> ExactSizeIterator for RepeatN<A> {\n    fn len(&self) -> usize {\n        self.count\n    }\n}",
        "old_source_code": ""
    },
    {
        "name": "is_sorted_by",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::iter::traits::iterator",
        "type": "method",
        "signature": "fn is_sorted_by<F>(mut self, compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_do_not_const_check]\n    fn is_sorted_by<F>(mut self, compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        #[inline]\n        fn check<'a, T>(\n            last: &'a mut T,\n            mut compare: impl FnMut(&T, &T) -> bool + 'a,\n        ) -> impl FnMut(T) -> bool + 'a {\n            move |curr| {\n                if !compare(&last, &curr) {\n                    return false;\n                }\n                *last = curr;\n                true\n            }\n        }\n\n        let mut last = match self.next() {\n            Some(e) => e,\n            None => return true,\n        };\n\n        self.all(check(&mut last, compare))\n    }",
        "old_source_code": ""
    },
    {
        "name": "is_sorted_by_key",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::iter::traits::iterator",
        "type": "method",
        "signature": "fn is_sorted_by_key<F, K>(self, f: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(Self::Item) -> K,\n        K: PartialOrd,",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_do_not_const_check]\n    fn is_sorted_by_key<F, K>(self, f: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(Self::Item) -> K,\n        K: PartialOrd,\n    {\n        self.map(f).is_sorted()\n    }",
        "old_source_code": ""
    },
    {
        "name": "is_sorted",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub fn is_sorted(&self) -> bool\n    where\n        T: PartialOrd,",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[must_use]\n    pub fn is_sorted(&self) -> bool\n    where\n        T: PartialOrd,\n    {\n        // This odd number works the best. 32 + 1 extra due to overlapping chunk boundaries.\n        const CHUNK_SIZE: usize = 33;\n        if self.len() < CHUNK_SIZE {\n            return self.windows(2).all(|w| w[0] <= w[1]);\n        }\n        let mut i = 0;\n        // Check in chunks for autovectorization.\n        while i < self.len() - CHUNK_SIZE {\n            let chunk = &self[i..i + CHUNK_SIZE];\n            if !chunk.windows(2).fold(true, |acc, w| acc & (w[0] <= w[1])) {\n                return false;\n            }\n            // We need to ensure that chunk boundaries are also sorted.\n            // Overlap the next chunk with the last element of our last chunk.\n            i += CHUNK_SIZE - 1;\n        }\n        self[i..].windows(2).all(|w| w[0] <= w[1])\n    }",
        "old_source_code": "    #[must_use]\n    pub fn is_sorted(&self) -> bool\n    where\n        T: PartialOrd,\n    {\n        self.is_sorted_by(|a, b| a <= b)\n    }"
    },
    {
        "name": "new_uninit",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "alloc::rc",
        "type": "function",
        "signature": "pub fn new_uninit() -> Rc<mem::MaybeUninit<T>>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[must_use]\n    pub fn new_uninit() -> Rc<mem::MaybeUninit<T>> {\n        unsafe {\n            Rc::from_ptr(Rc::allocate_for_layout(\n                Layout::new::<T>(),\n                |layout| Global.allocate(layout),\n                <*mut u8>::cast,\n            ))\n        }\n    }",
        "old_source_code": ""
    },
    {
        "name": "new_uninit_slice",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "alloc::rc",
        "type": "function",
        "signature": "pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[must_use]\n    pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {\n        unsafe { Rc::from_ptr(Rc::allocate_for_slice(len)) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "new_uninit_slice",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "alloc::sync",
        "type": "function",
        "signature": "pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[must_use]\n    pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n        unsafe { Arc::from_ptr(Arc::allocate_for_slice(len)) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "next_back",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::iter::adapters::take",
        "type": "method",
        "signature": "impl<T: Clone> DoubleEndedIterator for Take<crate::iter::Repeat<T>>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<T: Clone> DoubleEndedIterator for Take<crate::iter::Repeat<T>> {\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        self.next()\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        self.nth(n)\n    }\n\n    #[inline]\n    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n    where\n        Self: Sized,\n        Fold: FnMut(Acc, Self::Item) -> R,\n        R: Try<Output = Acc>,\n    {\n        self.try_fold(init, fold)\n    }\n\n    #[inline]\n    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n    where\n        Self: Sized,\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.fold(init, fold)\n    }\n\n    #[inline]\n    #[rustc_inherit_overflow_checks]\n    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n        self.advance_by(n)\n    }\n}",
        "old_source_code": "impl<I> DoubleEndedIterator for Take<I>\nwhere\n    I: DoubleEndedIterator + ExactSizeIterator,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<Self::Item> {\n        if self.n == 0 {\n            None\n        } else {\n            let n = self.n;\n            self.n -= 1;\n            self.iter.nth_back(self.iter.len().saturating_sub(n))\n        }\n    }\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n        let len = self.iter.len();\n        if self.n > n {\n            let m = len.saturating_sub(self.n) + n;\n            self.n -= n + 1;\n            self.iter.nth_back(m)\n        } else {\n            if len > 0 {\n                self.iter.nth_back(len - 1);\n            }\n            None\n        }\n    }\n\n    #[inline]\n    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n    where\n        Self: Sized,\n        Fold: FnMut(Acc, Self::Item) -> R,\n        R: Try<Output = Acc>,\n    {\n        if self.n == 0 {\n            try { init }\n        } else {\n            let len = self.iter.len();\n            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n                try { init }\n            } else {\n                self.iter.try_rfold(init, fold)\n            }\n        }\n    }\n\n    #[inline]\n    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n    where\n        Self: Sized,\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        if self.n == 0 {\n            init\n        } else {\n            let len = self.iter.len();\n            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n                init\n            } else {\n                self.iter.rfold(init, fold)\n            }\n        }\n    }\n\n    #[inline]\n    #[rustc_inherit_overflow_checks]\n    fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n        // The amount by which the inner iterator needs to be shortened for it to be\n        // at most as long as the take() amount.\n        let trim_inner = self.iter.len().saturating_sub(self.n);\n        // The amount we need to advance inner to fulfill the caller's request.\n        // take(), advance_by() and len() all can be at most usize, so we don't have to worry\n        // about having to advance more than usize::MAX here.\n        let advance_by = trim_inner.saturating_add(n);\n\n        let remainder = match self.iter.advance_back_by(advance_by) {\n            Ok(()) => 0,\n            Err(rem) => rem.get(),\n        };\n        let advanced_by_inner = advance_by - remainder;\n        let advanced_by = advanced_by_inner - trim_inner;\n        self.n -= advanced_by;\n        NonZero::new(n - advanced_by).map_or(Ok(()), Err)\n    }\n}"
    },
    {
        "name": "try_unwrap",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "alloc::rc",
        "type": "function",
        "signature": "pub fn try_unwrap(this: Self) -> Result<T, Self>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn try_unwrap(this: Self) -> Result<T, Self> {\n        if Rc::strong_count(&this) == 1 {\n            let this = ManuallyDrop::new(this);\n\n            let val: T = unsafe { ptr::read(&**this) }; // copy the contained object\n            let alloc: A = unsafe { ptr::read(&this.alloc) }; // copy the allocator\n\n            // Indicate to Weaks that they can't be promoted by decrementing\n            // the strong count, and then remove the implicit \"strong weak\"\n            // pointer while also handling drop logic by just crafting a\n            // fake Weak.\n            this.inner().dec_strong();\n            let _weak = Weak { ptr: this.ptr, alloc };\n            Ok(val)\n        } else {\n            Err(this)\n        }\n    }",
        "old_source_code": "    pub fn try_unwrap(this: Self) -> Result<T, Self> {\n        if Rc::strong_count(&this) == 1 {\n            unsafe {\n                let val = ptr::read(&*this); // copy the contained object\n                let alloc = ptr::read(&this.alloc); // copy the allocator\n\n                // Indicate to Weaks that they can't be promoted by decrementing\n                // the strong count, and then remove the implicit \"strong weak\"\n                // pointer while also handling drop logic by just crafting a\n                // fake Weak.\n                this.inner().dec_strong();\n                let _weak = Weak { ptr: this.ptr, alloc };\n                forget(this);\n                Ok(val)\n            }\n        } else {\n            Err(this)\n        }\n    }"
    },
    {
        "name": "ends_with",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub fn ends_with<P: Pattern>(&self, pat: P) -> bool\n    where\n        for<'a> P::Searcher<'a>: ReverseSearcher<'a>,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn ends_with<P: Pattern>(&self, pat: P) -> bool\n    where\n        for<'a> P::Searcher<'a>: ReverseSearcher<'a>,\n    {\n        pat.is_suffix_of(self)\n    }",
        "old_source_code": "    pub fn ends_with<'a, P>(&'a self, pat: P) -> bool\n    where\n        P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n    {\n        pat.is_suffix_of(self)\n    }"
    },
    {
        "name": "unwrap_unchecked",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::result",
        "type": "method",
        "signature": "pub unsafe fn unwrap_unchecked(self) -> T",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub unsafe fn unwrap_unchecked(self) -> T {\n        match self {\n            Ok(t) => t,\n            // SAFETY: the safety contract must be upheld by the caller.\n            Err(_) => unsafe { hint::unreachable_unchecked() },\n        }\n    }",
        "old_source_code": "    pub unsafe fn unwrap_unchecked(self) -> T {\n        debug_assert!(self.is_ok());\n        match self {\n            Ok(t) => t,\n            // SAFETY: the safety contract must be upheld by the caller.\n            Err(_) => unsafe { hint::unreachable_unchecked() },\n        }\n    }"
    },
    {
        "name": "from_bits",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::num::f64",
        "type": "function",
        "signature": "pub const fn from_bits(v: u64) -> Self",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[must_use]\n    #[inline]\n    pub const fn from_bits(v: u64) -> Self {\n        // It turns out the safety issues with sNaN were overblown! Hooray!\n        // SAFETY: `u64` is a plain old datatype so we can always transmute from it.\n        unsafe { mem::transmute(v) }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[must_use]\n    #[inline]\n    pub const fn from_bits(v: u64) -> Self {\n        // It turns out the safety issues with sNaN were overblown! Hooray!\n        // SAFETY: `u64` is a plain old datatype so we can always transmute from it\n        // ...sorta.\n        //\n        // It turns out that at runtime, it is possible for a floating point number\n        // to be subject to floating point modes that alter nonzero subnormal numbers\n        // to zero on reads and writes, aka \"denormals are zero\" and \"flush to zero\".\n        // This is not a problem usually, but at least one tier2 platform for Rust\n        // actually exhibits an FTZ behavior by default: thumbv7neon\n        // aka \"the Neon FPU in AArch32 state\"\n        //\n        // Even with this, not all instructions exhibit the FTZ behaviors on thumbv7neon,\n        // so this should load the same bits if LLVM emits the \"correct\" instructions,\n        // but LLVM sometimes makes interesting choices about float optimization,\n        // and other FPUs may do similar. Thus, it is wise to indulge luxuriously in caution.\n        //\n        // In addition, on x86 targets with SSE or SSE2 disabled and the x87 FPU enabled,\n        // i.e. not soft-float, the way Rust does parameter passing can actually alter\n        // a number that is \"not infinity\" to have the same exponent as infinity,\n        // in a slightly unpredictable manner.\n        //\n        // And, of course evaluating to a NaN value is fairly nondeterministic.\n        // More precisely: when NaN should be returned is knowable, but which NaN?\n        // So far that's defined by a combination of LLVM and the CPU, not Rust.\n        // This function, however, allows observing the bitstring of a NaN,\n        // thus introspection on CTFE.\n        //\n        // In order to preserve, at least for the moment, const-to-runtime equivalence,\n        // reject any of these possible situations from happening.\n        #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n        const fn ct_u64_to_f64(ct: u64) -> f64 {\n            match f64::classify_bits(ct) {\n                FpCategory::Subnormal => {\n                    panic!(\"const-eval error: cannot use f64::from_bits on a subnormal number\")\n                }\n                FpCategory::Nan => {\n                    panic!(\"const-eval error: cannot use f64::from_bits on NaN\")\n                }\n                FpCategory::Infinite | FpCategory::Normal | FpCategory::Zero => {\n                    // SAFETY: It's not a frumious number\n                    unsafe { mem::transmute::<u64, f64>(ct) }\n                }\n            }\n        }\n\n        #[inline(always)] // See https://github.com/rust-lang/compiler-builtins/issues/491\n        fn rt_u64_to_f64(rt: u64) -> f64 {\n            // SAFETY: `u64` is a plain old datatype so we can always... uh...\n            // ...look, just pretend you forgot what you just read.\n            // Stability concerns.\n            unsafe { mem::transmute::<u64, f64>(rt) }\n        }\n        intrinsics::const_eval_select((v,), ct_u64_to_f64, rt_u64_to_f64)\n    }"
    },
    {
        "name": "binary_search_by",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::slice",
        "type": "function",
        "signature": "pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> Ordering,",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> Ordering,\n    {\n        let mut size = self.len();\n        if size == 0 {\n            return Err(0);\n        }\n        let mut base = 0usize;\n\n        // This loop intentionally doesn't have an early exit if the comparison\n        // returns Equal. We want the number of loop iterations to depend *only*\n        // on the size of the input slice so that the CPU can reliably predict\n        // the loop count.\n        while size > 1 {\n            let half = size / 2;\n            let mid = base + half;\n\n            // SAFETY: the call is made safe by the following inconstants:\n            // - `mid >= 0`: by definition\n            // - `mid < size`: `mid = size / 2 + size / 4 + size / 8 ...`\n            let cmp = f(unsafe { self.get_unchecked(mid) });\n\n            // Binary search interacts poorly with branch prediction, so force\n            // the compiler to use conditional moves if supported by the target\n            // architecture.\n            base = select_unpredictable(cmp == Greater, base, mid);\n\n            // This is imprecise in the case where `size` is odd and the\n            // comparison returns Greater: the mid element still gets included\n            // by `size` even though it's known to be larger than the element\n            // being searched for.\n            //\n            // This is fine though: we gain more performance by keeping the\n            // loop iteration count invariant (and thus predictable) than we\n            // lose from considering one additional element.\n            size -= half;\n        }\n\n        // SAFETY: base is always in [0, size) because base <= mid.\n        let cmp = f(unsafe { self.get_unchecked(base) });\n        if cmp == Equal {\n            // SAFETY: same as the `get_unchecked` above.\n            unsafe { hint::assert_unchecked(base < self.len()) };\n            Ok(base)\n        } else {\n            let result = base + (cmp == Less) as usize;\n            // SAFETY: same as the `get_unchecked` above.\n            // Note that this is `<=`, unlike the assume in the `Ok` path.\n            unsafe { hint::assert_unchecked(result <= self.len()) };\n            Err(result)\n        }\n    }",
        "old_source_code": "    #[inline]\n    pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> Ordering,\n    {\n        // INVARIANTS:\n        // - 0 <= left <= left + size = right <= self.len()\n        // - f returns Less for everything in self[..left]\n        // - f returns Greater for everything in self[right..]\n        let mut size = self.len();\n        let mut left = 0;\n        let mut right = size;\n        while left < right {\n            let mid = left + size / 2;\n\n            // SAFETY: the while condition means `size` is strictly positive, so\n            // `size/2 < size`. Thus `left + size/2 < left + size`, which\n            // coupled with the `left + size <= self.len()` invariant means\n            // we have `left + size/2 < self.len()`, and this is in-bounds.\n            let cmp = f(unsafe { self.get_unchecked(mid) });\n\n            // This control flow produces conditional moves, which results in\n            // fewer branches and instructions than if/else or matching on\n            // cmp::Ordering.\n            // This is x86 asm for u8: https://rust.godbolt.org/z/698eYffTx.\n            left = if cmp == Less { mid + 1 } else { left };\n            right = if cmp == Greater { mid } else { right };\n            if cmp == Equal {\n                // SAFETY: same as the `get_unchecked` above\n                unsafe { hint::assert_unchecked(mid < self.len()) };\n                return Ok(mid);\n            }\n\n            size = right - left;\n        }\n\n        // SAFETY: directly true from the overall invariant.\n        // Note that this is `<=`, unlike the assume in the `Ok` path.\n        unsafe { hint::assert_unchecked(left <= self.len()) };\n        Err(left)\n    }"
    },
    {
        "name": "contains",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub fn contains<P: Pattern>(&self, pat: P) -> bool",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn contains<P: Pattern>(&self, pat: P) -> bool {\n        pat.is_contained_in(self)\n    }",
        "old_source_code": "    #[inline]\n    pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n        pat.is_contained_in(self)\n    }"
    },
    {
        "name": "split_once",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub fn split_once<P: Pattern>(&self, delimiter: P) -> Option<(&'_ str, &'_ str)>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[inline]\n    pub fn split_once<P: Pattern>(&self, delimiter: P) -> Option<(&'_ str, &'_ str)> {\n        let (start, end) = delimiter.into_searcher(self).next_match()?;\n        // SAFETY: `Searcher` is known to return valid indices.\n        unsafe { Some((self.get_unchecked(..start), self.get_unchecked(end..))) }\n    }",
        "old_source_code": "    #[inline]\n    pub fn split_once<'a, P: Pattern<'a>>(&'a self, delimiter: P) -> Option<(&'a str, &'a str)> {\n        let (start, end) = delimiter.into_searcher(self).next_match()?;\n        // SAFETY: `Searcher` is known to return valid indices.\n        unsafe { Some((self.get_unchecked(..start), self.get_unchecked(end..))) }\n    }"
    },
    {
        "name": "split",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub fn split<P: Pattern>(&self, pat: P) -> Split<'_, P>",
        "change_type": "signature",
        "documentation": "Returns an iterator over substrings of this string slice, separated by\ncharacters matched by a pattern.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`] if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., [`char`], but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ\nfrom a forward search, the [`rsplit`] method can be used.\n\n[`rsplit`]: str::rsplit\n",
        "examples": [
            "",
            "Simple patterns:",
            "",
            "```",
            "let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();",
            "assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);",
            "",
            "let v: Vec<&str> = \"\".split('X').collect();",
            "assert_eq!(v, [\"\"]);",
            "",
            "let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();",
            "assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);",
            "",
            "let v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();",
            "assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);",
            "",
            "let v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();",
            "assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);",
            "",
            "let v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();",
            "assert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);",
            "```",
            "",
            "If the pattern is a slice of chars, split on each occurrence of any of the characters:",
            "",
            "```",
            "let v: Vec<&str> = \"2020-11-03 23:59\".split(&['-', ' ', ':', '@'][..]).collect();",
            "assert_eq!(v, [\"2020\", \"11\", \"03\", \"23\", \"59\"]);",
            "```",
            "",
            "A more complex pattern, using a closure:",
            "",
            "```",
            "let v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();",
            "assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);",
            "```",
            "",
            "If a string contains multiple contiguous separators, you will end up",
            "with empty strings in the output:",
            "",
            "```",
            "let x = \"||||a||b|c\".to_string();",
            "let d: Vec<_> = x.split('|').collect();",
            "",
            "assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);",
            "```",
            "",
            "Contiguous separators are separated by the empty string.",
            "",
            "```",
            "let x = \"(///)\".to_string();",
            "let d: Vec<_> = x.split('/').collect();",
            "",
            "assert_eq!(d, &[\"(\", \"\", \"\", \")\"]);",
            "```",
            "",
            "Separators at the start or end of a string are neighbored",
            "by empty strings.",
            "",
            "```",
            "let d: Vec<_> = \"010\".split(\"0\").collect();",
            "assert_eq!(d, &[\"\", \"1\", \"\"]);",
            "```",
            "",
            "When the empty string is used as a separator, it separates",
            "every character in the string, along with the beginning",
            "and end of the string.",
            "",
            "```",
            "let f: Vec<_> = \"rust\".split(\"\").collect();",
            "assert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);",
            "```",
            "",
            "Contiguous separators can lead to possibly surprising behavior",
            "when whitespace is used as the separator. This code is correct:",
            "",
            "```",
            "let x = \"    a  b c\".to_string();",
            "let d: Vec<_> = x.split(' ').collect();",
            "",
            "assert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);",
            "```",
            "",
            "It does _not_ give you:",
            "",
            "```,ignore",
            "assert_eq!(d, &[\"a\", \"b\", \"c\"]);",
            "```",
            "",
            "Use [`split_whitespace`] for this behavior.",
            "",
            "[`split_whitespace`]: str::split_whitespace"
        ],
        "source_code": "    #[inline]\n    pub fn split<P: Pattern>(&self, pat: P) -> Split<'_, P> {\n        Split(SplitInternal {\n            start: 0,\n            end: self.len(),\n            matcher: pat.into_searcher(self),\n            allow_trailing_empty: true,\n            finished: false,\n        })\n    }",
        "old_source_code": "    #[inline]\n    pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n        Split(SplitInternal {\n            start: 0,\n            end: self.len(),\n            matcher: pat.into_searcher(self),\n            allow_trailing_empty: true,\n            finished: false,\n        })\n    }"
    },
    {
        "name": "into_raw",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "alloc::sync",
        "type": "method",
        "signature": "pub fn into_raw(self) -> *const T",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn into_raw(self) -> *const T {\n        ManuallyDrop::new(self).as_ptr()\n    }",
        "old_source_code": "    pub fn into_raw(self) -> *const T {\n        let result = self.as_ptr();\n        mem::forget(self);\n        result\n    }"
    },
    {
        "name": "align_offset",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "std::mem::align_of",
        "type": "method",
        "signature": "pub fn align_offset(self, align: usize) -> usize\n    where\n        T: Sized,",
        "change_type": "signature",
        "documentation": "Computes the offset that needs to be applied to the pointer in order to make it aligned to\n`align`.\n\nIf it is not possible to align the pointer, the implementation returns\n`usize::MAX`.\n\nThe offset is expressed in number of `T` elements, and not bytes.\n\nThere are no guarantees whatsoever that offsetting the pointer will not overflow or go\nbeyond the allocation that the pointer points into. It is up to the caller to ensure that\nthe returned offset is correct in all terms other than alignment.\n\nWhen this is called during compile-time evaluation (which is unstable), the implementation\nmay return `usize::MAX` in cases where that can never happen at runtime. This is because the\nactual alignment of pointers is not known yet during compile-time, so an offset with\nguaranteed alignment can sometimes not be computed. For example, a buffer declared as `[u8;\nN]` might be allocated at an odd or an even address, but at compile-time this is not yet\nknown, so the execution has to be correct for either choice. It is therefore impossible to\nfind an offset that is guaranteed to be 2-aligned. (This behavior is subject to change, as usual\nfor unstable APIs.)\n\n# Panics\n\nThe function panics if `align` is not a power-of-two.\n\n# unsafe {\nlet x = [5_u8, 6, 7, 8, 9];\nlet ptr = NonNull::new(x.as_ptr() as *mut u8).unwrap();\nlet offset = ptr.align_offset(align_of::<u16>());\n\nif offset < x.len() - 1 {\nlet u16_ptr = ptr.add(offset).cast::<u16>();\nassert!(u16_ptr.read() == u16::from_ne_bytes([5, 6]) || u16_ptr.read() == u16::from_ne_bytes([6, 7]));\n} else {\n// while the pointer can be aligned via `offset`, it would point\n// outside the allocation\n}\n# }\n```",
        "examples": [
            "",
            "Accessing adjacent `u8` as `u16`",
            "",
            "```",
            "use std::mem::align_of;",
            "use std::ptr::NonNull;",
            ""
        ],
        "source_code": "    pub fn align_offset(self, align: usize) -> usize\n    where\n        T: Sized,\n    {\n        if !align.is_power_of_two() {\n            panic!(\"align_offset: align is not a power-of-two\");\n        }\n\n        {\n            // SAFETY: `align` has been checked to be a power of 2 above.\n            unsafe { ptr::align_offset(self.pointer, align) }\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_align_offset\", issue = \"90962\")]\n    pub const fn align_offset(self, align: usize) -> usize\n    where\n        T: Sized,\n    {\n        if !align.is_power_of_two() {\n            panic!(\"align_offset: align is not a power-of-two\");\n        }\n\n        {\n            // SAFETY: `align` has been checked to be a power of 2 above.\n            unsafe { ptr::align_offset(self.pointer, align) }\n        }\n    }"
    },
    {
        "name": "into_raw_handle",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "std::os::windows::io::handle",
        "type": "method",
        "signature": "impl IntoRawHandle for OwnedHandle",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl IntoRawHandle for OwnedHandle {\n    #[inline]\n    fn into_raw_handle(self) -> RawHandle {\n        ManuallyDrop::new(self).handle\n    }\n}",
        "old_source_code": "impl IntoRawHandle for OwnedHandle {\n    #[inline]\n    fn into_raw_handle(self) -> RawHandle {\n        let handle = self.handle;\n        forget(self);\n        handle\n    }\n}"
    },
    {
        "name": "trim_matches",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub fn trim_matches<P: Pattern>(&self, pat: P) -> &str\n    where\n        for<'a> P::Searcher<'a>: DoubleEndedSearcher<'a>,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    pub fn trim_matches<P: Pattern>(&self, pat: P) -> &str\n    where\n        for<'a> P::Searcher<'a>: DoubleEndedSearcher<'a>,\n    {\n        let mut i = 0;\n        let mut j = 0;\n        let mut matcher = pat.into_searcher(self);\n        if let Some((a, b)) = matcher.next_reject() {\n            i = a;\n            j = b; // Remember earliest known match, correct it below if\n            // last match is different\n        }\n        if let Some((_, b)) = matcher.next_reject_back() {\n            j = b;\n        }\n        // SAFETY: `Searcher` is known to return valid indices.\n        unsafe { self.get_unchecked(i..j) }\n    }",
        "old_source_code": "    pub fn trim_matches<'a, P>(&'a self, pat: P) -> &'a str\n    where\n        P: Pattern<'a, Searcher: DoubleEndedSearcher<'a>>,\n    {\n        let mut i = 0;\n        let mut j = 0;\n        let mut matcher = pat.into_searcher(self);\n        if let Some((a, b)) = matcher.next_reject() {\n            i = a;\n            j = b; // Remember earliest known match, correct it below if\n            // last match is different\n        }\n        if let Some((_, b)) = matcher.next_reject_back() {\n            j = b;\n        }\n        // SAFETY: `Searcher` is known to return valid indices.\n        unsafe { self.get_unchecked(i..j) }\n    }"
    },
    {
        "name": "skip_until",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "std::io",
        "type": "method",
        "signature": "fn skip_until(&mut self, byte: u8) -> Result<usize>",
        "change_type": "stabilized",
        "documentation": "Skips all bytes until the delimiter `byte` or EOF is reached.\n\nThis function will read (and discard) bytes from the underlying stream until the\ndelimiter or EOF is found.\n\nIf successful, this function will return the total number of bytes read,\nincluding the delimiter byte.\n\nThis is useful for efficiently skipping data such as NUL-terminated strings\nin binary file formats without buffering.\n\nThis function is blocking and should be used carefully: it is possible for\nan attacker to continuously send bytes without ever sending the delimiter\nor EOF.\n\n# Errors\n\nThis function will ignore all instances of [`ErrorKind::Interrupted`] and\nwill otherwise return any errors returned by [`fill_buf`].\n\nIf an I/O error is encountered then all bytes read so far will be\npresent in `buf` and its length will have been adjusted appropriately.\n\n[`fill_buf`]: BufRead::fill_buf\n",
        "examples": [
            "",
            "[`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In",
            "this example, we use [`Cursor`] to read some NUL-terminated information",
            "about Ferris from a binary string, skipping the fun fact:",
            "",
            "```",
            "use std::io::{self, BufRead};",
            "",
            "let mut cursor = io::Cursor::new(b\"Ferris\\0Likes long walks on the beach\\0Crustacean\\0\");",
            "",
            "// read name",
            "let mut name = Vec::new();",
            "let num_bytes = cursor.read_until(b'\\0', &mut name)",
            ".expect(\"reading from cursor won't fail\");",
            "assert_eq!(num_bytes, 7);",
            "assert_eq!(name, b\"Ferris\\0\");",
            "",
            "// skip fun fact",
            "let num_bytes = cursor.skip_until(b'\\0')",
            ".expect(\"reading from cursor won't fail\");",
            "assert_eq!(num_bytes, 30);",
            "",
            "// read animal type",
            "let mut animal = Vec::new();",
            "let num_bytes = cursor.read_until(b'\\0', &mut animal)",
            ".expect(\"reading from cursor won't fail\");",
            "assert_eq!(num_bytes, 11);",
            "assert_eq!(animal, b\"Crustacean\\0\");",
            "```"
        ],
        "source_code": "    fn skip_until(&mut self, byte: u8) -> Result<usize> {\n        skip_until(self, byte)\n    }",
        "old_source_code": ""
    },
    {
        "name": "is_null",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::ptr::const_ptr",
        "type": "method",
        "signature": "pub const fn is_null(self) -> bool",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_ptr_is_null\", since = \"1.84.0\")]\n    #[rustc_diagnostic_item = \"ptr_const_is_null\"]\n    #[inline]\n    #[rustc_allow_const_fn_unstable(const_eval_select)]\n    pub const fn is_null(self) -> bool {\n        // Compare via a cast to a thin pointer, so fat pointers are only\n        // considering their \"data\" part for null-ness.\n        let ptr = self as *const u8;\n        const_eval_select!(\n            @capture { ptr: *const u8 } -> bool:\n            // This use of `const_raw_ptr_comparison` has been explicitly blessed by t-lang.\n            if const #[rustc_allow_const_fn_unstable(const_raw_ptr_comparison)] {\n                match (ptr).guaranteed_eq(null_mut()) {\n                    Some(res) => res,\n                    // To remain maximally convervative, we stop execution when we don't\n                    // know whether the pointer is null or not.\n                    // We can *not* return `false` here, that would be unsound in `NonNull::new`!\n                    None => panic!(\"null-ness of this pointer cannot be determined in const context\"),\n                }\n            } else {\n                ptr.addr() == 0\n            }\n        )\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_ptr_is_null\", issue = \"74939\")]\n    #[rustc_diagnostic_item = \"ptr_const_is_null\"]\n    #[inline]\n    pub const fn is_null(self) -> bool {\n        #[inline]\n        fn runtime_impl(ptr: *const u8) -> bool {\n            ptr.addr() == 0\n        }\n\n        #[inline]\n        const fn const_impl(ptr: *const u8) -> bool {\n            match (ptr).guaranteed_eq(null_mut()) {\n                Some(res) => res,\n                // To remain maximally convervative, we stop execution when we don't\n                // know whether the pointer is null or not.\n                // We can *not* return `false` here, that would be unsound in `NonNull::new`!\n                None => panic!(\"null-ness of this pointer cannot be determined in const context\"),\n            }\n        }\n\n        // Compare via a cast to a thin pointer, so fat pointers are only\n        // considering their \"data\" part for null-ness.\n        const_eval_select((self as *const u8,), const_impl, runtime_impl)\n    }"
    },
    {
        "name": "iter",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn iter(&self) -> Iter<'_, T>",
        "change_type": "signature",
        "documentation": "//////////////////////////////////////////////////////////////////////",
        "source_code": "    pub fn iter(&self) -> Iter<'_, T> {\n        Iter { inner: Item { opt: self.as_ref() } }\n    }",
        "old_source_code": "    pub const fn iter(&self) -> Iter<'_, T> {\n        Iter { inner: Item { opt: self.as_ref() } }\n    }"
    },
    {
        "name": "capacity",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "alloc::vec",
        "type": "method",
        "signature": "pub const fn capacity(&self) -> usize",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[rustc_const_unstable(feature = \"const_vec_string_slice\", issue = \"129041\")]\n    pub const fn capacity(&self) -> usize {\n        self.buf.capacity()\n    }",
        "old_source_code": "    pub fn capacity(&self) -> usize {\n        self.buf.capacity()\n    }"
    },
    {
        "name": "new",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "alloc::collections::vec_deque",
        "type": "function",
        "signature": "pub const fn new() -> VecDeque<T>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_vec_deque_new\", since = \"1.68.0\")]\n    #[must_use]\n    pub const fn new() -> VecDeque<T> {\n        // FIXME(const-hack): This should just be `VecDeque::new_in(Global)` once that hits stable.\n        VecDeque { head: 0, len: 0, buf: RawVec::new() }\n    }",
        "old_source_code": "    #[rustc_const_stable(feature = \"const_vec_deque_new\", since = \"1.68.0\")]\n    #[must_use]\n    pub const fn new() -> VecDeque<T> {\n        // FIXME: This should just be `VecDeque::new_in(Global)` once that hits stable.\n        VecDeque { head: 0, len: 0, buf: RawVec::NEW }\n    }"
    },
    {
        "name": "as_mut_ptr",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub const fn as_mut_ptr(&mut self) -> *mut u8",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[cfg_attr(bootstrap, rustc_allow_const_fn_unstable(const_mut_refs))]\n    #[rustc_const_stable(feature = \"const_str_as_mut\", since = \"1.83.0\")]\n    #[rustc_never_returns_null_ptr]\n    #[must_use]\n    #[inline(always)]\n    pub const fn as_mut_ptr(&mut self) -> *mut u8 {\n        self as *mut str as *mut u8\n    }",
        "old_source_code": "    #[rustc_never_returns_null_ptr]\n    #[must_use]\n    #[inline(always)]\n    pub fn as_mut_ptr(&mut self) -> *mut u8 {\n        self as *mut str as *mut u8\n    }"
    },
    {
        "name": "as_ptr",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "alloc::vec",
        "type": "method",
        "signature": "pub const fn as_ptr(&self) -> *const T",
        "change_type": "signature",
        "documentation": "Returns a raw pointer to the vector's buffer, or a dangling raw pointer\nvalid for zero sized reads if the vector didn't allocate.\n\nThe caller must ensure that the vector outlives the pointer this\nfunction returns, or else it will end up dangling.\nModifying the vector may cause its buffer to be reallocated,\nwhich would also make any pointers to it invalid.\n\nThe caller must also ensure that the memory the pointer (non-transitively) points to\nis never written to (except inside an `UnsafeCell`) using this pointer or any pointer\nderived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\nThis method guarantees that for the purpose of the aliasing model, this method\ndoes not materialize a reference to the underlying slice, and thus the returned pointer\nwill remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\nand [`as_non_null`].\nNote that calling other methods that materialize mutable references to the slice,\nor mutable references to specific elements you are planning on accessing through this pointer,\nas well as writing to those elements, may still invalidate this pointer.\nSee the second example below for how this guarantee can be used.\n\n",
        "examples": [
            "",
            "```",
            "let x = vec![1, 2, 4];",
            "let x_ptr = x.as_ptr();",
            "",
            "unsafe {",
            "for i in 0..x.len() {",
            "assert_eq!(*x_ptr.add(i), 1 << i);",
            "}",
            "}",
            "```",
            "",
            "Due to the aliasing guarantee, the following code is legal:",
            "",
            "```rust",
            "unsafe {",
            "let mut v = vec![0, 1, 2];",
            "let ptr1 = v.as_ptr();",
            "let _ = ptr1.read();",
            "let ptr2 = v.as_mut_ptr().offset(2);",
            "ptr2.write(2);",
            "// Notably, the write to `ptr2` did *not* invalidate `ptr1`",
            "// because it mutated a different element:",
            "let _ = ptr1.read();",
            "}",
            "```",
            "",
            "[`as_mut_ptr`]: Vec::as_mut_ptr",
            "[`as_ptr`]: Vec::as_ptr",
            "[`as_non_null`]: Vec::as_non_null"
        ],
        "source_code": "    #[rustc_const_unstable(feature = \"const_vec_string_slice\", issue = \"129041\")]\n    #[rustc_never_returns_null_ptr]\n    #[inline]\n    pub const fn as_ptr(&self) -> *const T {\n        // We shadow the slice method of the same name to avoid going through\n        // `deref`, which creates an intermediate reference.\n        self.buf.ptr()\n    }",
        "old_source_code": "    #[rustc_never_returns_null_ptr]\n    #[inline]\n    pub fn as_ptr(&self) -> *const T {\n        // We shadow the slice method of the same name to avoid going through\n        // `deref`, which creates an intermediate reference.\n        self.buf.ptr()\n    }"
    },
    {
        "name": "is_empty",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "alloc::string",
        "type": "method",
        "signature": "pub const fn is_empty(&self) -> bool",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[rustc_const_unstable(feature = \"const_vec_string_slice\", issue = \"129041\")]\n    pub const fn is_empty(&self) -> bool {\n        self.len() == 0\n    }",
        "old_source_code": "    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }"
    },
    {
        "name": "encode_utf8",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::char::methods",
        "type": "method",
        "signature": "pub const fn encode_utf8(self, dst: &mut [u8]) -> &mut str",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_char_encode_utf8\", since = \"1.83.0\")]\n    #[inline]\n    #[cfg_attr(bootstrap, rustc_allow_const_fn_unstable(const_mut_refs))]\n    pub const fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n        // SAFETY: `char` is not a surrogate, so this is valid UTF-8.\n        unsafe { from_utf8_unchecked_mut(encode_utf8_raw(self as u32, dst)) }\n    }",
        "old_source_code": "    #[inline]\n    pub fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n        // SAFETY: `char` is not a surrogate, so this is valid UTF-8.\n        unsafe { from_utf8_unchecked_mut(encode_utf8_raw(self as u32, dst)) }\n    }"
    },
    {
        "name": "copied",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::result",
        "type": "method",
        "signature": "pub const fn copied(self) -> Result<T, E>\n    where\n        T: Copy,",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_result\", since = \"1.83.0\")]\n    #[cfg_attr(bootstrap, rustc_allow_const_fn_unstable(const_mut_refs))]\n    #[rustc_allow_const_fn_unstable(const_precise_live_drops)]\n    pub const fn copied(self) -> Result<T, E>\n    where\n        T: Copy,\n    {\n        // FIXME(const-hack): this implementation, which sidesteps using `Result::map` since it's not const\n        // ready yet, should be reverted when possible to avoid code repetition\n        match self {\n            Ok(&mut v) => Ok(v),\n            Err(e) => Err(e),\n        }\n    }",
        "old_source_code": "    pub fn copied(self) -> Result<T, E>\n    where\n        T: Copy,\n    {\n        self.map(|&mut t| t)\n    }"
    },
    {
        "name": "len",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "alloc::vec",
        "type": "method",
        "signature": "pub const fn len(&self) -> usize",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[rustc_const_unstable(feature = \"const_vec_string_slice\", issue = \"129041\")]\n    #[rustc_confusables(\"length\", \"size\")]\n    pub const fn len(&self) -> usize {\n        self.len\n    }",
        "old_source_code": "    #[rustc_confusables(\"length\", \"size\")]\n    pub fn len(&self) -> usize {\n        self.len\n    }"
    },
    {
        "name": "len_utf16",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::char::methods",
        "type": "method",
        "signature": "pub const fn len_utf16(self) -> usize",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_char_len_utf\", since = \"1.52.0\")]\n    #[inline]\n    #[must_use]\n    pub const fn len_utf16(self) -> usize {\n        len_utf16(self as u32)\n    }",
        "old_source_code": "    #[rustc_const_stable(feature = \"const_char_len_utf\", since = \"1.52.0\")]\n    #[inline]\n    pub const fn len_utf16(self) -> usize {\n        let ch = self as u32;\n        if (ch & 0xFFFF) == ch { 1 } else { 2 }\n    }"
    },
    {
        "name": "new_cyclic",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "alloc::sync",
        "type": "function",
        "signature": "pub fn new_cyclic<F>(data_fn: F) -> Arc<T>\n    where\n        F: FnOnce(&Weak<T>) -> T,",
        "change_type": "implicit",
        "documentation": "Constructs a new `Arc<T>` while giving you a `Weak<T>` to the allocation,\nto allow you to construct a `T` which holds a weak pointer to itself.\n\nGenerally, a structure circularly referencing itself, either directly or\nindirectly, should not hold a strong reference to itself to prevent a memory leak.\nUsing this function, you get access to the weak pointer during the\ninitialization of `T`, before the `Arc<T>` is created, such that you can\nclone and store it inside the `T`.\n\n`new_cyclic` first allocates the managed allocation for the `Arc<T>`,\nthen calls your closure, giving it a `Weak<T>` to this allocation,\nand only afterwards completes the construction of the `Arc<T>` by placing\nthe `T` returned from your closure into the allocation.\n\nSince the new `Arc<T>` is not fully-constructed until `Arc<T>::new_cyclic`\nreturns, calling [`upgrade`] on the weak reference inside your closure will\nfail and result in a `None` value.\n\n# Panics\n\nIf `data_fn` panics, the panic is propagated to the caller, and the\ntemporary [`Weak<T>`] is dropped normally.\n\n# #![allow(dead_code)]\nuse std::sync::{Arc, Weak};\n\nstruct Gadget {\nme: Weak<Gadget>,\n}\n\nimpl Gadget {\n/// Constructs a reference counted Gadget.\nfn new() -> Arc<Self> {\n// `me` is a `Weak<Gadget>` pointing at the new allocation of the\n// `Arc` we're constructing.\nArc::new_cyclic(|me| {\n// Create the actual struct here.\nGadget { me: me.clone() }\n})\n}\n\n/// Returns a reference counted pointer to Self.\nfn me(&self) -> Arc<Self> {\nself.me.upgrade().unwrap()\n}\n}\n```\n[`upgrade`]: Weak::upgrade",
        "examples": [
            "",
            "```"
        ],
        "source_code": "    pub fn new_cyclic<F>(data_fn: F) -> Arc<T>\n    where\n        F: FnOnce(&Weak<T>) -> T,\n    {\n        Self::new_cyclic_in(data_fn, Global)\n    }",
        "old_source_code": "    pub fn new_cyclic<F>(data_fn: F) -> Arc<T>\n    where\n        F: FnOnce(&Weak<T>) -> T,\n    {\n        // Construct the inner in the \"uninitialized\" state with a single\n        // weak reference.\n        let uninit_ptr: NonNull<_> = Box::leak(Box::new(ArcInner {\n            strong: atomic::AtomicUsize::new(0),\n            weak: atomic::AtomicUsize::new(1),\n            data: mem::MaybeUninit::<T>::uninit(),\n        }))\n        .into();\n        let init_ptr: NonNull<ArcInner<T>> = uninit_ptr.cast();\n\n        let weak = Weak { ptr: init_ptr, alloc: Global };\n\n        // It's important we don't give up ownership of the weak pointer, or\n        // else the memory might be freed by the time `data_fn` returns. If\n        // we really wanted to pass ownership, we could create an additional\n        // weak pointer for ourselves, but this would result in additional\n        // updates to the weak reference count which might not be necessary\n        // otherwise.\n        let data = data_fn(&weak);\n\n        // Now we can properly initialize the inner value and turn our weak\n        // reference into a strong reference.\n        let strong = unsafe {\n            let inner = init_ptr.as_ptr();\n            ptr::write(ptr::addr_of_mut!((*inner).data), data);\n\n            // The above write to the data field must be visible to any threads which\n            // observe a non-zero strong count. Therefore we need at least \"Release\" ordering\n            // in order to synchronize with the `compare_exchange_weak` in `Weak::upgrade`.\n            //\n            // \"Acquire\" ordering is not required. When considering the possible behaviours\n            // of `data_fn` we only need to look at what it could do with a reference to a\n            // non-upgradeable `Weak`:\n            // - It can *clone* the `Weak`, increasing the weak reference count.\n            // - It can drop those clones, decreasing the weak reference count (but never to zero).\n            //\n            // These side effects do not impact us in any way, and no other side effects are\n            // possible with safe code alone.\n            let prev_value = (*inner).strong.fetch_add(1, Release);\n            debug_assert_eq!(prev_value, 0, \"No prior strong references should exist\");\n\n            Arc::from_inner(init_ptr)\n        };\n\n        // Strong references should collectively own a shared weak reference,\n        // so don't run the destructor for our old weak reference.\n        mem::forget(weak);\n        strong\n    }"
    },
    {
        "name": "capacity",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "alloc::string",
        "type": "method",
        "signature": "pub const fn capacity(&self) -> usize",
        "change_type": "signature",
        "documentation": "",
        "source_code": "    #[rustc_const_unstable(feature = \"const_vec_string_slice\", issue = \"129041\")]\n    pub const fn capacity(&self) -> usize {\n        self.vec.capacity()\n    }",
        "old_source_code": "    pub fn capacity(&self) -> usize {\n        self.vec.capacity()\n    }"
    },
    {
        "name": "default",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "std::collections::hash::set",
        "type": "function",
        "signature": "impl<K> Default for IntoIter<K>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<K> Default for IntoIter<K> {\n    #[inline]\n    fn default() -> Self {\n        IntoIter { base: Default::default() }\n    }\n}",
        "old_source_code": "impl<T, S> Default for HashSet<T, S>\nwhere\n    S: Default,\n{\n    /// Creates an empty `HashSet<T, S>` with the `Default` value for the hasher.\n    #[inline]\n    fn default() -> HashSet<T, S> {\n        HashSet { base: Default::default() }\n    }\n}"
    },
    {
        "name": "as_mut_ptr",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "alloc::vec",
        "type": "method",
        "signature": "pub const fn as_mut_ptr(&mut self) -> *mut T",
        "change_type": "signature",
        "documentation": "Returns a raw mutable pointer to the vector's buffer, or a dangling\nraw pointer valid for zero sized reads if the vector didn't allocate.\n\nThe caller must ensure that the vector outlives the pointer this\nfunction returns, or else it will end up dangling.\nModifying the vector may cause its buffer to be reallocated,\nwhich would also make any pointers to it invalid.\n\nThis method guarantees that for the purpose of the aliasing model, this method\ndoes not materialize a reference to the underlying slice, and thus the returned pointer\nwill remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\nand [`as_non_null`].\nNote that calling other methods that materialize references to the slice,\nor references to specific elements you are planning on accessing through this pointer,\nmay still invalidate this pointer.\nSee the second example below for how this guarantee can be used.\n",
        "examples": [
            "",
            "```",
            "// Allocate vector big enough for 4 elements.",
            "let size = 4;",
            "let mut x: Vec<i32> = Vec::with_capacity(size);",
            "let x_ptr = x.as_mut_ptr();",
            "",
            "// Initialize elements via raw pointer writes, then set length.",
            "unsafe {",
            "for i in 0..size {",
            "*x_ptr.add(i) = i as i32;",
            "}",
            "x.set_len(size);",
            "}",
            "assert_eq!(&*x, &[0, 1, 2, 3]);",
            "```",
            "",
            "Due to the aliasing guarantee, the following code is legal:",
            "",
            "```rust",
            "unsafe {",
            "let mut v = vec![0];",
            "let ptr1 = v.as_mut_ptr();",
            "ptr1.write(1);",
            "let ptr2 = v.as_mut_ptr();",
            "ptr2.write(2);",
            "// Notably, the write to `ptr2` did *not* invalidate `ptr1`:",
            "ptr1.write(3);",
            "}",
            "```",
            "",
            "[`as_mut_ptr`]: Vec::as_mut_ptr",
            "[`as_ptr`]: Vec::as_ptr",
            "[`as_non_null`]: Vec::as_non_null"
        ],
        "source_code": "    #[rustc_const_unstable(feature = \"const_vec_string_slice\", issue = \"129041\")]\n    #[rustc_never_returns_null_ptr]\n    #[inline]\n    pub const fn as_mut_ptr(&mut self) -> *mut T {\n        // We shadow the slice method of the same name to avoid going through\n        // `deref_mut`, which creates an intermediate reference.\n        self.buf.ptr()\n    }",
        "old_source_code": "    #[rustc_never_returns_null_ptr]\n    #[inline]\n    pub fn as_mut_ptr(&mut self) -> *mut T {\n        // We shadow the slice method of the same name to avoid going through\n        // `deref_mut`, which creates an intermediate reference.\n        self.buf.ptr()\n    }"
    },
    {
        "name": "to_uppercase",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "alloc::str",
        "type": "method",
        "signature": "pub fn to_uppercase(&self) -> String",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    pub fn to_uppercase(&self) -> String {\n        let (mut s, rest) = convert_while_ascii(self, u8::to_ascii_uppercase);\n\n        for c in rest.chars() {\n            match conversions::to_upper(c) {\n                [a, '\\0', _] => s.push(a),\n                [a, b, '\\0'] => {\n                    s.push(a);\n                    s.push(b);\n                }\n                [a, b, c] => {\n                    s.push(a);\n                    s.push(b);\n                    s.push(c);\n                }\n            }\n        }\n        s\n    }",
        "old_source_code": "    pub fn to_uppercase(&self) -> String {\n        let out = convert_while_ascii(self.as_bytes(), u8::to_ascii_uppercase);\n\n        // Safety: we know this is a valid char boundary since\n        // out.len() is only progressed if ascii bytes are found\n        let rest = unsafe { self.get_unchecked(out.len()..) };\n\n        // Safety: We have written only valid ASCII to our vec\n        let mut s = unsafe { String::from_utf8_unchecked(out) };\n\n        for c in rest.chars() {\n            match conversions::to_upper(c) {\n                [a, '\\0', _] => s.push(a),\n                [a, b, '\\0'] => {\n                    s.push(a);\n                    s.push(b);\n                }\n                [a, b, c] => {\n                    s.push(a);\n                    s.push(b);\n                    s.push(c);\n                }\n            }\n        }\n        s\n    }"
    },
    {
        "name": "new_cyclic",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "alloc::rc",
        "type": "function",
        "signature": "pub fn new_cyclic<F>(data_fn: F) -> Rc<T>\n    where\n        F: FnOnce(&Weak<T>) -> T,",
        "change_type": "implicit",
        "documentation": "Constructs a new `Rc<T>` while giving you a `Weak<T>` to the allocation,\nto allow you to construct a `T` which holds a weak pointer to itself.\n\nGenerally, a structure circularly referencing itself, either directly or\nindirectly, should not hold a strong reference to itself to prevent a memory leak.\nUsing this function, you get access to the weak pointer during the\ninitialization of `T`, before the `Rc<T>` is created, such that you can\nclone and store it inside the `T`.\n\n`new_cyclic` first allocates the managed allocation for the `Rc<T>`,\nthen calls your closure, giving it a `Weak<T>` to this allocation,\nand only afterwards completes the construction of the `Rc<T>` by placing\nthe `T` returned from your closure into the allocation.\n\nSince the new `Rc<T>` is not fully-constructed until `Rc<T>::new_cyclic`\nreturns, calling [`upgrade`] on the weak reference inside your closure will\nfail and result in a `None` value.\n\n# Panics\n\nIf `data_fn` panics, the panic is propagated to the caller, and the\ntemporary [`Weak<T>`] is dropped normally.\n\n# #![allow(dead_code)]\nuse std::rc::{Rc, Weak};\n\nstruct Gadget {\nme: Weak<Gadget>,\n}\n\nimpl Gadget {\n/// Constructs a reference counted Gadget.\nfn new() -> Rc<Self> {\n// `me` is a `Weak<Gadget>` pointing at the new allocation of the\n// `Rc` we're constructing.\nRc::new_cyclic(|me| {\n// Create the actual struct here.\nGadget { me: me.clone() }\n})\n}\n\n/// Returns a reference counted pointer to Self.\nfn me(&self) -> Rc<Self> {\nself.me.upgrade().unwrap()\n}\n}\n```\n[`upgrade`]: Weak::upgrade",
        "examples": [
            "",
            "```"
        ],
        "source_code": "    pub fn new_cyclic<F>(data_fn: F) -> Rc<T>\n    where\n        F: FnOnce(&Weak<T>) -> T,\n    {\n        Self::new_cyclic_in(data_fn, Global)\n    }",
        "old_source_code": "    pub fn new_cyclic<F>(data_fn: F) -> Rc<T>\n    where\n        F: FnOnce(&Weak<T>) -> T,\n    {\n        // Construct the inner in the \"uninitialized\" state with a single\n        // weak reference.\n        let uninit_ptr: NonNull<_> = Box::leak(Box::new(RcBox {\n            strong: Cell::new(0),\n            weak: Cell::new(1),\n            value: mem::MaybeUninit::<T>::uninit(),\n        }))\n        .into();\n\n        let init_ptr: NonNull<RcBox<T>> = uninit_ptr.cast();\n\n        let weak = Weak { ptr: init_ptr, alloc: Global };\n\n        // It's important we don't give up ownership of the weak pointer, or\n        // else the memory might be freed by the time `data_fn` returns. If\n        // we really wanted to pass ownership, we could create an additional\n        // weak pointer for ourselves, but this would result in additional\n        // updates to the weak reference count which might not be necessary\n        // otherwise.\n        let data = data_fn(&weak);\n\n        let strong = unsafe {\n            let inner = init_ptr.as_ptr();\n            ptr::write(ptr::addr_of_mut!((*inner).value), data);\n\n            let prev_value = (*inner).strong.get();\n            debug_assert_eq!(prev_value, 0, \"No prior strong references should exist\");\n            (*inner).strong.set(1);\n\n            Rc::from_inner(init_ptr)\n        };\n\n        // Strong references should collectively own a shared weak reference,\n        // so don't run the destructor for our old weak reference.\n        mem::forget(weak);\n        strong\n    }"
    },
    {
        "name": "is_unique_local",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::net::ip_addr",
        "type": "method",
        "signature": "pub const fn is_unique_local(&self) -> bool",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"ipv6_is_unique_local\", since = \"1.84.0\")]\n    pub const fn is_unique_local(&self) -> bool {\n        (self.segments()[0] & 0xfe00) == 0xfc00\n    }",
        "old_source_code": ""
    },
    {
        "name": "is_unicast_link_local",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::net::ip_addr",
        "type": "method",
        "signature": "pub const fn is_unicast_link_local(&self) -> bool",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"ipv6_is_unique_local\", since = \"1.84.0\")]\n    pub const fn is_unicast_link_local(&self) -> bool {\n        (self.segments()[0] & 0xffc0) == 0xfe80\n    }",
        "old_source_code": ""
    },
    {
        "name": "checked_isqrt",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::num::int_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn checked_isqrt(self) -> Option<Self>",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_isqrt(self) -> Option<Self> {\n            if self < 0 {\n                None\n            } else {\n                // SAFETY: Input is nonnegative in this `else` branch.\n                let result = unsafe {\n                    crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT\n                };\n\n                // Inform the optimizer what the range of outputs is. If\n                // testing `core` crashes with no panic message and a\n                // `num::int_sqrt::i*` test failed, it's because your edits\n                // caused these assertions to become false.\n                //\n                // SAFETY: Integer square root is a monotonically nondecreasing\n                // function, which means that increasing the input will never\n                // cause the output to decrease. Thus, since the input for\n                // nonnegative signed integers is bounded by\n                // `[0, <$ActualT>::MAX]`, sqrt(n) will be bounded by\n                // `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n                unsafe {\n                    // SAFETY: `<$ActualT>::MAX` is nonnegative.\n                    const MAX_RESULT: $SelfT = unsafe {\n                        crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT\n                    };\n\n                    crate::hint::assert_unchecked(result >= 0);\n                    crate::hint::assert_unchecked(result <= MAX_RESULT);\n                }\n\n                Some(result)\n            }\n        }",
        "old_source_code": ""
    },
    {
        "name": "isqrt",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::num::int_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn isqrt(self) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn isqrt(self) -> Self {\n            match self.checked_isqrt() {\n                Some(sqrt) => sqrt,\n                None => crate::num::int_sqrt::panic_for_negative_argument(),\n            }\n        }",
        "old_source_code": ""
    },
    {
        "name": "isqrt",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::num::uint_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn isqrt(self) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }",
        "old_source_code": ""
    },
    {
        "name": "addr",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::ptr::const_ptr",
        "type": "method",
        "signature": "pub fn addr(self) -> usize",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "with_addr",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::ptr::const_ptr",
        "type": "method",
        "signature": "pub fn with_addr(self, addr: usize) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    pub fn with_addr(self, addr: usize) -> Self {\n        // This should probably be an intrinsic to avoid doing any sort of arithmetic, but\n        // meanwhile, we can implement it with `wrapping_offset`, which preserves the pointer's\n        // provenance.\n        let self_addr = self.addr() as isize;\n        let dest_addr = addr as isize;\n        let offset = dest_addr.wrapping_sub(self_addr);\n        self.wrapping_byte_offset(offset)\n    }",
        "old_source_code": ""
    },
    {
        "name": "map_addr",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::ptr::const_ptr",
        "type": "method",
        "signature": "pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self {\n        self.with_addr(f(self.addr()))\n    }",
        "old_source_code": ""
    },
    {
        "name": "addr",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::ptr::mut_ptr",
        "type": "method",
        "signature": "pub fn addr(self) -> usize",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "with_addr",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::ptr::mut_ptr",
        "type": "method",
        "signature": "pub fn with_addr(self, addr: usize) -> Self",
        "change_type": "stabilized",
        "documentation": "",
        "source_code": "    pub fn with_addr(self, addr: usize) -> Self {\n        // This should probably be an intrinsic to avoid doing any sort of arithmetic, but\n        // meanwhile, we can implement it with `wrapping_offset`, which preserves the pointer's\n        // provenance.\n        let self_addr = self.addr() as isize;\n        let dest_addr = addr as isize;\n        let offset = dest_addr.wrapping_sub(self_addr);\n        self.wrapping_byte_offset(offset)\n    }",
        "old_source_code": ""
    },
    {
        "name": "is_finite",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::num::f32",
        "type": "method",
        "signature": "pub const fn is_finite(self) -> bool",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_float_classify\", since = \"1.83.0\")]\n    #[inline]\n    #[rustc_allow_const_fn_unstable(const_float_methods)] // for `abs`\n    pub const fn is_finite(self) -> bool {\n        // There's no need to handle NaN separately: if self is NaN,\n        // the comparison is not true, exactly as desired.\n        self.abs() < Self::INFINITY\n    }",
        "old_source_code": "    #[rustc_const_stable(feature = \"const_float_classify\", since = \"1.83.0\")]\n    #[inline]\n    pub const fn is_finite(self) -> bool {\n        // There's no need to handle NaN separately: if self is NaN,\n        // the comparison is not true, exactly as desired.\n        self.abs_private() < Self::INFINITY\n    }"
    },
    {
        "name": "from",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "std::path",
        "type": "function",
        "signature": "impl From<&mut Path> for Rc<Path>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl From<&mut Path> for Rc<Path> {\n    /// Converts a [`Path`] into an [`Rc`] by copying the [`Path`] data into a new [`Rc`] buffer.\n    #[inline]\n    fn from(s: &mut Path) -> Rc<Path> {\n        Rc::from(&*s)\n    }\n}",
        "old_source_code": "impl From<&Path> for Rc<Path> {\n    /// Converts a [`Path`] into an [`Rc`] by copying the [`Path`] data into a new [`Rc`] buffer.\n    #[inline]\n    fn from(s: &Path) -> Rc<Path> {\n        let rc: Rc<OsStr> = Rc::from(s.as_os_str());\n        unsafe { Rc::from_raw(Rc::into_raw(rc) as *const Path) }\n    }\n}"
    },
    {
        "name": "clone",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "alloc::boxed",
        "type": "method",
        "signature": "impl Clone for Box<str>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl Clone for Box<str> {\n    fn clone(&self) -> Self {\n        // this makes a copy of the data\n        let buf: Box<[u8]> = self.as_bytes().into();\n        unsafe { from_boxed_utf8_unchecked(buf) }\n    }\n}",
        "old_source_code": "impl<T: Clone, A: Allocator + Clone> Clone for Box<[T], A> {\n    fn clone(&self) -> Self {\n        let alloc = Box::allocator(self).clone();\n        self.to_vec_in(alloc).into_boxed_slice()\n    }\n\n    /// Copies `source`'s contents into `self` without creating a new allocation,\n    /// so long as the two are of the same length.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Box::new([5, 6, 7]);\n    /// let mut y = Box::new([8, 9, 10]);\n    /// let yp: *const [i32] = &*y;\n    ///\n    /// y.clone_from(&x);\n    ///\n    /// // The value is the same\n    /// assert_eq!(x, y);\n    ///\n    /// // And no allocation occurred\n    /// assert_eq!(yp, &*y);\n    /// ```\n    fn clone_from(&mut self, source: &Self) {\n        if self.len() == source.len() {\n            self.clone_from_slice(&source);\n        } else {\n            *self = source.clone();\n        }\n    }\n}"
    },
    {
        "name": "is_finite",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::num::f64",
        "type": "method",
        "signature": "pub const fn is_finite(self) -> bool",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "    #[rustc_const_stable(feature = \"const_float_classify\", since = \"1.83.0\")]\n    #[inline]\n    #[rustc_allow_const_fn_unstable(const_float_methods)] // for `abs`\n    pub const fn is_finite(self) -> bool {\n        // There's no need to handle NaN separately: if self is NaN,\n        // the comparison is not true, exactly as desired.\n        self.abs() < Self::INFINITY\n    }",
        "old_source_code": "    #[rustc_const_stable(feature = \"const_float_classify\", since = \"1.83.0\")]\n    #[inline]\n    pub const fn is_finite(self) -> bool {\n        // There's no need to handle NaN separately: if self is NaN,\n        // the comparison is not true, exactly as desired.\n        self.abs_private() < Self::INFINITY\n    }"
    },
    {
        "name": "from",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "alloc::vec",
        "type": "function",
        "signature": "impl From<&str> for Vec<u8>",
        "change_type": "implicit",
        "documentation": "",
        "source_code": "impl From<&str> for Vec<u8> {\n    /// Allocates a `Vec<u8>` and fills it with a UTF-8 string.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(Vec::from(\"123\"), vec![b'1', b'2', b'3']);\n    /// ```\n    #[track_caller]\n    fn from(s: &str) -> Vec<u8> {\n        From::from(s.as_bytes())\n    }\n}",
        "old_source_code": "impl From<&str> for Vec<u8> {\n    /// Allocates a `Vec<u8>` and fills it with a UTF-8 string.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(Vec::from(\"123\"), vec![b'1', b'2', b'3']);\n    /// ```\n    fn from(s: &str) -> Vec<u8> {\n        From::from(s.as_bytes())\n    }\n}"
    },
    {
        "name": "fmt",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "alloc::boxed",
        "type": "method",
        "signature": "impl<T: ?Sized, A: Allocator> fmt::Pointer for Box<T, A>",
        "change_type": "signature",
        "documentation": "",
        "source_code": "impl<T: ?Sized, A: Allocator> fmt::Pointer for Box<T, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // It's not possible to extract the inner Uniq directly from the Box,\n        // instead we cast it to a *const which aliases the Unique\n        let ptr: *const T = &**self;\n        fmt::Pointer::fmt(&ptr, f)\n    }\n}",
        "old_source_code": "impl<'a, E: Error + Send + Sync + 'a> From<E> for Box<dyn Error + Send + Sync + 'a> {\n    /// Converts a type of [`Error`] + [`Send`] + [`Sync`] into a box of\n    /// dyn [`Error`] + [`Send`] + [`Sync`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::fmt;\n    /// use std::mem;\n    ///\n    /// #[derive(Debug)]\n    /// struct AnError;\n    ///\n    /// impl fmt::Display for AnError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f, \"An error\")\n    ///     }\n    /// }\n    ///\n    /// impl Error for AnError {}\n    ///\n    /// unsafe impl Send for AnError {}\n    ///\n    /// unsafe impl Sync for AnError {}\n    ///\n    /// let an_error = AnError;\n    /// assert!(0 == mem::size_of_val(&an_error));\n    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(an_error);\n    /// assert!(\n    ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: E) -> Box<dyn Error + Send + Sync + 'a> {\n        Box::new(err)\n    }\n}"
    },
    {
        "name": "write_bytes",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "std::ptr",
        "type": "function",
        "signature": "pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize)",
        "change_type": "implicit",
        "documentation": "Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n`val`.\n\n`write_bytes` is similar to C's [`memset`], but sets `count *\nsize_of::<T>()` bytes to `val`.\n\n[`memset`]: https://en.cppreference.com/w/c/string/byte/memset\n\n# Safety\n\nBehavior is undefined if any of the following conditions are violated:\n\n* `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n* `dst` must be properly aligned.\n\nNote that even if the effectively copied size (`count * size_of::<T>()`) is\n`0`, the pointer must be properly aligned.\n\nAdditionally, note that changing `*dst` in this way can easily lead to undefined behavior (UB)\nlater if the written bytes are not a valid representation of some `T`. For instance, the\nfollowing is an **incorrect** use of this function:\n\n```rust,no_run\nunsafe {\nlet mut value: u8 = 0;\nlet ptr: *mut bool = &mut value as *mut u8 as *mut bool;\nlet _bool = ptr.read(); // This is fine, `ptr` points to a valid `bool`.\nptr.write_bytes(42u8, 1); // This function itself does not cause UB...\nlet _bool = ptr.read(); // ...but it makes this operation UB! \n}\n```\n\n[valid]: crate::ptr#safety\n",
        "examples": [
            "",
            "Basic usage:",
            "",
            "```",
            "use std::ptr;",
            "",
            "let mut vec = vec![0u32; 4];",
            "unsafe {",
            "let vec_ptr = vec.as_mut_ptr();",
            "ptr::write_bytes(vec_ptr, 0xfe, 2);",
            "}",
            "assert_eq!(vec, [0xfefefefe, 0xfefefefe, 0, 0]);",
            "```"
        ],
        "source_code": "#[rustc_allowed_through_unstable_modules]\n#[rustc_const_stable(feature = \"const_ptr_write\", since = \"1.83.0\")]\n#[inline(always)]\n#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n#[rustc_diagnostic_item = \"ptr_write_bytes\"]\npub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n    #[cfg_attr(bootstrap, rustc_const_stable(feature = \"const_ptr_write\", since = \"1.83.0\"))]\n    #[cfg_attr(not(bootstrap), rustc_intrinsic_const_stable_indirect)]\n    #[rustc_nounwind]\n    #[rustc_intrinsic]\n    #[rustc_intrinsic_must_be_overridden]\n    const unsafe fn write_bytes<T>(_dst: *mut T, _val: u8, _count: usize) {\n        unreachable!()\n    }\n\n    // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::write_bytes requires that the destination pointer is aligned and non-null\",\n            (\n                addr: *const () = dst as *const (),\n                align: usize = align_of::<T>(),\n                zero_size: bool = T::IS_ZST || count == 0,\n            ) => ub_checks::maybe_is_aligned_and_not_null(addr, align, zero_size)\n        );\n        write_bytes(dst, val, count)\n    }\n}",
        "old_source_code": "#[rustc_allowed_through_unstable_modules]\n#[rustc_const_stable(feature = \"const_ptr_write\", since = \"1.83.0\")]\n#[inline(always)]\n#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n#[rustc_diagnostic_item = \"ptr_write_bytes\"]\npub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n    extern \"rust-intrinsic\" {\n        #[rustc_const_stable(feature = \"const_ptr_write\", since = \"1.83.0\")]\n        #[rustc_nounwind]\n        fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n    }\n\n    // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::write_bytes requires that the destination pointer is aligned and non-null\",\n            (\n                addr: *const () = dst as *const (),\n                align: usize = align_of::<T>(),\n            ) => ub_checks::is_aligned_and_not_null(addr, align)\n        );\n        write_bytes(dst, val, count)\n    }\n}"
    },
    {
        "name": "assume_init_mut",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::mem::maybe_uninit",
        "type": "method",
        "signature": "feature = \"const_maybe_uninit_assume_init\",\n        since = \"1.84.0\"\n    )]\n    pub const unsafe fn assume_init_mut(&mut self) -> &mut T",
        "change_type": "signature",
        "documentation": "Gets a mutable (unique) reference to the contained value.\n\nThis can be useful when we want to access a `MaybeUninit` that has been\ninitialized but don't have ownership of the `MaybeUninit` (preventing the use\nof `.assume_init()`).\n\n# Safety\n\nCalling this when the content is not yet fully initialized causes undefined\nbehavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really\nis in an initialized state. For instance, `.assume_init_mut()` cannot be used to\ninitialize a `MaybeUninit`.\n\n# #![allow(unexpected_cfgs)]\nuse std::mem::MaybeUninit;\n\n# unsafe extern \"C\" fn initialize_buffer(buf: *mut [u8; 1024]) { *buf = [0; 1024] }\n# #[cfg(FALSE)]\nextern \"C\" {\n/// Initializes *all* the bytes of the input buffer.\nfn initialize_buffer(buf: *mut [u8; 1024]);\n}\n\nlet mut buf = MaybeUninit::<[u8; 1024]>::uninit();\n\n// Initialize `buf`:\nunsafe { initialize_buffer(buf.as_mut_ptr()); }\n// Now we know that `buf` has been initialized, so we could `.assume_init()` it.\n// However, using `.assume_init()` may trigger a `memcpy` of the 1024 bytes.\n// To assert our buffer has been initialized without copying it, we upgrade\n// the `&mut MaybeUninit<[u8; 1024]>` to a `&mut [u8; 1024]`:\nlet buf: &mut [u8; 1024] = unsafe {\n// SAFETY: `buf` has been initialized.\nbuf.assume_init_mut()\n};\n\n// Now we can use `buf` as a normal slice:\nbuf.sort_unstable();\nassert!(\nbuf.windows(2).all(|pair| pair[0] <= pair[1]),\n\"buffer is sorted\",\n);\n```\n\n### *Incorrect* usages of this method:\n\nYou cannot use `.assume_init_mut()` to initialize a value:\n\n```rust,no_run\nuse std::mem::MaybeUninit;\n\nlet mut b = MaybeUninit::<bool>::uninit();\nunsafe {\n*b.assume_init_mut() = true;\n// We have created a (mutable) reference to an uninitialized `bool`!\n// This is undefined behavior. \n}\n```\n\nFor instance, you cannot [`Read`] into an uninitialized buffer:\n\n[`Read`]: ../../std/io/trait.Read.html\n\n```rust,no_run\nuse std::{io, mem::MaybeUninit};\n\nfn read_chunk (reader: &'_ mut dyn io::Read) -> io::Result<[u8; 64]>\n{\nlet mut buffer = MaybeUninit::<[u8; 64]>::uninit();\nreader.read_exact(unsafe { buffer.assume_init_mut() })?;\n// ^^^^^^^^^^^^^^^^^^^^^^^^\n// (mutable) reference to uninitialized memory!\n// This is undefined behavior.\nOk(unsafe { buffer.assume_init() })\n}\n```\n\nNor can you use direct field access to do field-by-field gradual initialization:\n\n```rust,no_run\nuse std::{mem::MaybeUninit, ptr};\n\nstruct Foo {\na: u32,\nb: u8,\n}\n\nlet foo: Foo = unsafe {\nlet mut foo = MaybeUninit::<Foo>::uninit();\nptr::write(&mut foo.assume_init_mut().a as *mut u32, 1337);\n// ^^^^^^^^^^^^^^^^^^^^^\n// (mutable) reference to uninitialized memory!\n// This is undefined behavior.\nptr::write(&mut foo.assume_init_mut().b as *mut u8, 42);\n// ^^^^^^^^^^^^^^^^^^^^^\n// (mutable) reference to uninitialized memory!\n// This is undefined behavior.\nfoo.assume_init()\n};\n```",
        "examples": [
            "",
            "### Correct usage of this method:",
            "",
            "```rust"
        ],
        "source_code": "    #[rustc_const_stable(\n        feature = \"const_maybe_uninit_assume_init\",\n        since = \"1.84.0\"\n    )]\n    #[inline(always)]\n    pub const unsafe fn assume_init_mut(&mut self) -> &mut T {\n        // SAFETY: the caller must guarantee that `self` is initialized.\n        // This also means that `self` must be a `value` variant.\n        unsafe {\n            intrinsics::assert_inhabited::<T>();\n            &mut *self.as_mut_ptr()\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_maybe_uninit_assume_init\", issue = \"none\")]\n    #[inline(always)]\n    pub const unsafe fn assume_init_mut(&mut self) -> &mut T {\n        // SAFETY: the caller must guarantee that `self` is initialized.\n        // This also means that `self` must be a `value` variant.\n        unsafe {\n            intrinsics::assert_inhabited::<T>();\n            &mut *self.as_mut_ptr()\n        }\n    }"
    },
    {
        "name": "to_digit",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::char::methods",
        "type": "method",
        "signature": "without modifying the original\"]\n    pub const fn to_digit(self, radix: u32) -> Option<u32>",
        "change_type": "implicit",
        "documentation": "Converts a `char` to a digit in the given radix.\n\nA 'radix' here is sometimes also called a 'base'. A radix of two\nindicates a binary number, a radix of ten, decimal, and a radix of\nsixteen, hexadecimal, to give some common values. Arbitrary\nradices are supported.\n\n'Digit' is defined to be only the following characters:\n\n* `0-9`\n* `a-z`\n* `A-Z`\n\n# Errors\n\nReturns `None` if the `char` does not refer to a digit in the given radix.\n\n# Panics\n\nPanics if given a radix smaller than 2 or larger than 36.\n",
        "examples": [
            "",
            "Basic usage:",
            "",
            "```",
            "assert_eq!('1'.to_digit(10), Some(1));",
            "assert_eq!('f'.to_digit(16), Some(15));",
            "```",
            "",
            "Passing a non-digit results in failure:",
            "",
            "```",
            "assert_eq!('f'.to_digit(10), None);",
            "assert_eq!('z'.to_digit(16), None);",
            "```",
            "",
            "Passing a large radix, causing a panic:",
            "",
            "```should_panic",
            "// this panics",
            "let _ = '1'.to_digit(37);",
            "```",
            "Passing a small radix, causing a panic:",
            "",
            "```should_panic",
            "// this panics",
            "let _ = '1'.to_digit(1);",
            "```"
        ],
        "source_code": "    #[rustc_const_stable(feature = \"const_char_convert\", since = \"1.67.0\")]\n    #[must_use = \"this returns the result of the operation, \\\n                  without modifying the original\"]\n    #[inline]\n    pub const fn to_digit(self, radix: u32) -> Option<u32> {\n        assert!(\n            radix >= 2 && radix <= 36,\n            \"to_digit: invalid radix -- radix must be in the range 2 to 36 inclusive\"\n        );\n        // check radix to remove letter handling code when radix is a known constant\n        let value = if self > '9' && radix > 10 {\n            // convert ASCII letters to lowercase\n            let lower = self as u32 | 0x20;\n            // convert an ASCII letter to the corresponding value,\n            // non-letters convert to values > 36\n            lower.wrapping_sub('a' as u32) as u64 + 10\n        } else {\n            // convert digit to value, non-digits wrap to values > 36\n            (self as u32).wrapping_sub('0' as u32) as u64\n        };\n        // FIXME(const-hack): once then_some is const fn, use it here\n        if value < radix as u64 { Some(value as u32) } else { None }\n    }",
        "old_source_code": "    #[rustc_const_stable(feature = \"const_char_convert\", since = \"1.67.0\")]\n    #[must_use = \"this returns the result of the operation, \\\n                  without modifying the original\"]\n    #[inline]\n    pub const fn to_digit(self, radix: u32) -> Option<u32> {\n        // If not a digit, a number greater than radix will be created.\n        let mut digit = (self as u32).wrapping_sub('0' as u32);\n        if radix > 10 {\n            assert!(radix <= 36, \"to_digit: radix is too high (maximum 36)\");\n            if digit < 10 {\n                return Some(digit);\n            }\n            // Force the 6th bit to be set to ensure ascii is lower case.\n            digit = (self as u32 | 0b10_0000).wrapping_sub('a' as u32).saturating_add(10);\n        }\n        // FIXME(const-hack): once then_some is const fn, use it here\n        if digit < radix { Some(digit) } else { None }\n    }"
    },
    {
        "name": "from",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::tuple",
        "type": "function",
        "signature": "impl<T> From<($($",
        "change_type": "stabilized",
        "source_code": "        impl<T> From<($(${ignore(T)} T,)+)> for [T; ${count(T)}] {\n            #[inline]\n            #[allow(non_snake_case)]\n            fn from(tuple: ($(${ignore(T)} T,)+)) -> Self {\n                let ($($T,)+) = tuple;\n                [$($T,)+]\n            }\n        }",
        "old_source_code": ""
    },
    {
        "name": "is_positive",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "pub const fn is_positive(self) -> bool",
        "change_type": "stabilized",
        "source_code": "                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n                pub const fn is_positive(self) -> bool {\n                    self.get().is_positive()\n                }",
        "old_source_code": ""
    },
    {
        "name": "overflowing_neg",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "pub const fn overflowing_neg(self) -> (Self, bool)",
        "change_type": "signature",
        "source_code": "        #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            let (result, overflow) = self.get().overflowing_neg();\n            // SAFETY: negation of nonzero cannot yield zero values.\n            ((unsafe { Self::new_unchecked(result) }), overflow)\n        }",
        "old_source_code": "                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n                pub const fn overflowing_neg(self) -> ($Ty, bool) {\n                    let (result, overflow) = self.get().overflowing_neg();\n                    // SAFETY: negation of nonzero cannot yield zero values.\n                    ((unsafe { $Ty::new_unchecked(result) }), overflow)\n                }"
    },
    {
        "name": "saturating_neg",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "pub const fn saturating_neg(self) -> Self",
        "change_type": "signature",
        "source_code": "        #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        pub const fn saturating_neg(self) -> Self {\n            if let Some(result) = self.checked_neg() {\n                return result;\n            }\n            Self::MAX\n        }",
        "old_source_code": "                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n                pub const fn saturating_neg(self) -> $Ty {\n                    if let Some(result) = self.checked_neg() {\n                        return result;\n                    }\n                    $Ty::MAX\n                }"
    },
    {
        "name": "wrapping_neg",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "pub const fn wrapping_neg(self) -> Self",
        "change_type": "signature",
        "source_code": "        #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n        pub const fn wrapping_neg(self) -> Self {\n            let result = self.get().wrapping_neg();\n            // SAFETY: negation of nonzero cannot yield zero values.\n            unsafe { Self::new_unchecked(result) }\n        }",
        "old_source_code": "                #[rustc_const_stable(feature = \"nonzero_negation_ops\", since = \"1.71.0\")]\n                pub const fn wrapping_neg(self) -> $Ty {\n                    let result = self.get().wrapping_neg();\n                    // SAFETY: negation of nonzero cannot yield zero values.\n                    unsafe { $Ty::new_unchecked(result) }\n                }"
    },
    {
        "name": "offset",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::ptr::mut_ptr",
        "type": "method",
        "signature": "pub const unsafe fn offset(self, count: isize) -> *mut T\n    where\n        T: Sized,",
        "change_type": "implicit",
        "source_code": "    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n    #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n    #[inline(always)]\n    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n    pub const unsafe fn offset(self, count: isize) -> *mut T\n    where\n        T: Sized,\n    {\n        #[inline]\n        const fn runtime_offset_nowrap(this: *const (), count: isize, size: usize) -> bool {\n            #[inline]\n            fn runtime(this: *const (), count: isize, size: usize) -> bool {\n                // `size` is the size of a Rust type, so we know that\n                // `size <= isize::MAX` and thus `as` cast here is not lossy.\n                let Some(byte_offset) = count.checked_mul(size as isize) else {\n                    return false;\n                };\n                let (_, overflow) = this.addr().overflowing_add_signed(byte_offset);\n                !overflow\n            }\n\n            const fn comptime(_: *const (), _: isize, _: usize) -> bool {\n                true\n            }\n\n            // We can use const_eval_select here because this is only for UB checks.\n            intrinsics::const_eval_select((this, count, size), comptime, runtime)\n        }\n\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset requires the address calculation to not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: isize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_offset_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // The obtained pointer is valid for writes since the caller must\n        // guarantee that it points to the same allocated object as `self`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
        "old_source_code": "    #[must_use = \"returns a new pointer rather than modifying its argument\"]\n    #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n    #[inline(always)]\n    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n    pub const unsafe fn offset(self, count: isize) -> *mut T\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // The obtained pointer is valid for writes since the caller must\n        // guarantee that it points to the same allocated object as `self`.\n        unsafe { intrinsics::offset(self, count) }\n    }"
    },
    {
        "name": "get_unchecked",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output",
        "change_type": "signature",
        "source_code": "    #[inline]\n    pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n        // the slice is dereferenceable because `self` is a safe reference.\n        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n        unsafe { &*i.get_unchecked(self) }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n    #[inline]\n    pub const unsafe fn get_unchecked<I: ~const SliceIndex<str>>(&self, i: I) -> &I::Output {\n        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n        // the slice is dereferenceable because `self` is a safe reference.\n        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n        unsafe { &*i.get_unchecked(self) }\n    }"
    },
    {
        "name": "try_from_secs_f64",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "std::time::Duration",
        "type": "function",
        "signature": "pub fn try_from_secs_f64(secs: f64) -> Result<Duration, TryFromFloatSecsError>",
        "change_type": "signature",
        "documentation": "The checked version of [`from_secs_f64`].\n\n[`from_secs_f64`]: Duration::from_secs_f64\n\nThis constructor will return an `Err` if `secs` is negative, overflows `Duration` or not finite.\n",
        "examples": [
            "```",
            "use std::time::Duration;",
            "",
            "let res = Duration::try_from_secs_f64(0.0);",
            "assert_eq!(res, Ok(Duration::new(0, 0)));",
            "let res = Duration::try_from_secs_f64(1e-20);",
            "assert_eq!(res, Ok(Duration::new(0, 0)));",
            "let res = Duration::try_from_secs_f64(4.2e-7);",
            "assert_eq!(res, Ok(Duration::new(0, 420)));",
            "let res = Duration::try_from_secs_f64(2.7);",
            "assert_eq!(res, Ok(Duration::new(2, 700_000_000)));",
            "let res = Duration::try_from_secs_f64(3e10);",
            "assert_eq!(res, Ok(Duration::new(30_000_000_000, 0)));",
            "// subnormal float",
            "let res = Duration::try_from_secs_f64(f64::from_bits(1));",
            "assert_eq!(res, Ok(Duration::new(0, 0)));",
            "",
            "let res = Duration::try_from_secs_f64(-5.0);",
            "assert!(res.is_err());",
            "let res = Duration::try_from_secs_f64(f64::NAN);",
            "assert!(res.is_err());",
            "let res = Duration::try_from_secs_f64(2e19);",
            "assert!(res.is_err());",
            "",
            "// the conversion uses rounding with tie resolution to even",
            "let res = Duration::try_from_secs_f64(0.999e-9);",
            "assert_eq!(res, Ok(Duration::new(0, 1)));",
            "let res = Duration::try_from_secs_f64(0.999_999_999_499);",
            "assert_eq!(res, Ok(Duration::new(0, 999_999_999)));",
            "let res = Duration::try_from_secs_f64(0.999_999_999_501);",
            "assert_eq!(res, Ok(Duration::new(1, 0)));",
            "let res = Duration::try_from_secs_f64(42.999_999_999_499);",
            "assert_eq!(res, Ok(Duration::new(42, 999_999_999)));",
            "let res = Duration::try_from_secs_f64(42.999_999_999_501);",
            "assert_eq!(res, Ok(Duration::new(43, 0)));",
            "",
            "// this float represents exactly 976562.5e-9",
            "let val = f64::from_bits(0x3F50_0000_0000_0000);",
            "let res = Duration::try_from_secs_f64(val);",
            "assert_eq!(res, Ok(Duration::new(0, 976_562)));",
            "",
            "// this float represents exactly 2929687.5e-9",
            "let val = f64::from_bits(0x3F68_0000_0000_0000);",
            "let res = Duration::try_from_secs_f64(val);",
            "assert_eq!(res, Ok(Duration::new(0, 2_929_688)));",
            "",
            "// this float represents exactly 1.000_976_562_5",
            "let val = f64::from_bits(0x3FF0_0400_0000_0000);",
            "let res = Duration::try_from_secs_f64(val);",
            "assert_eq!(res, Ok(Duration::new(1, 976_562)));",
            "",
            "// this float represents exactly 1.002_929_687_5",
            "let val = f64::from_bits(0x3_FF00_C000_0000_000);",
            "let res = Duration::try_from_secs_f64(val);",
            "assert_eq!(res, Ok(Duration::new(1, 2_929_688)));",
            "```"
        ],
        "source_code": "    #[inline]\n    pub fn try_from_secs_f64(secs: f64) -> Result<Duration, TryFromFloatSecsError> {\n        try_from_secs!(\n            secs = secs,\n            mantissa_bits = 52,\n            exponent_bits = 11,\n            offset = 44,\n            bits_ty = u64,\n            double_ty = u128,\n        )\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n    #[inline]\n    pub const fn try_from_secs_f64(secs: f64) -> Result<Duration, TryFromFloatSecsError> {\n        try_from_secs!(\n            secs = secs,\n            mantissa_bits = 52,\n            exponent_bits = 11,\n            offset = 44,\n            bits_ty = u64,\n            double_ty = u128,\n        )\n    }"
    },
    {
        "name": "sub_assign",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::ops::arith",
        "type": "method",
        "signature": "impl SubAssign for $t",
        "change_type": "signature",
        "source_code": "        impl SubAssign for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn sub_assign(&mut self, other: $t) { *self -= other }\n        }",
        "old_source_code": "        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n        impl const SubAssign for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn sub_assign(&mut self, other: $t) { *self -= other }\n        }"
    },
    {
        "name": "write",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "std::collections::hash::map",
        "type": "method",
        "signature": "impl Hasher for DefaultHasher",
        "change_type": "signature",
        "source_code": "impl Hasher for DefaultHasher {\n    // The underlying `SipHasher13` doesn't override the other\n    // `write_*` methods, so it's ok not to forward them here.\n\n    #[inline]\n    fn write(&mut self, msg: &[u8]) {\n        self.0.write(msg)\n    }\n\n    #[inline]\n    fn write_str(&mut self, s: &str) {\n        self.0.write_str(s);\n    }\n\n    #[inline]\n    fn finish(&self) -> u64 {\n        self.0.finish()\n    }\n}",
        "old_source_code": "#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\nimpl const Hasher for DefaultHasher {\n    // The underlying `SipHasher13` doesn't override the other\n    // `write_*` methods, so it's ok not to forward them here.\n\n    #[inline]\n    fn write(&mut self, msg: &[u8]) {\n        self.0.write(msg)\n    }\n\n    #[inline]\n    fn write_str(&mut self, s: &str) {\n        self.0.write_str(s);\n    }\n\n    #[inline]\n    fn finish(&self) -> u64 {\n        self.0.finish()\n    }\n}"
    },
    {
        "name": "try_from_secs_f32",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "std::time::Duration",
        "type": "function",
        "signature": "pub fn try_from_secs_f32(secs: f32) -> Result<Duration, TryFromFloatSecsError>",
        "change_type": "signature",
        "documentation": "The checked version of [`from_secs_f32`].\n\n[`from_secs_f32`]: Duration::from_secs_f32\n\nThis constructor will return an `Err` if `secs` is negative, overflows `Duration` or not finite.\n",
        "examples": [
            "```",
            "use std::time::Duration;",
            "",
            "let res = Duration::try_from_secs_f32(0.0);",
            "assert_eq!(res, Ok(Duration::new(0, 0)));",
            "let res = Duration::try_from_secs_f32(1e-20);",
            "assert_eq!(res, Ok(Duration::new(0, 0)));",
            "let res = Duration::try_from_secs_f32(4.2e-7);",
            "assert_eq!(res, Ok(Duration::new(0, 420)));",
            "let res = Duration::try_from_secs_f32(2.7);",
            "assert_eq!(res, Ok(Duration::new(2, 700_000_048)));",
            "let res = Duration::try_from_secs_f32(3e10);",
            "assert_eq!(res, Ok(Duration::new(30_000_001_024, 0)));",
            "// subnormal float:",
            "let res = Duration::try_from_secs_f32(f32::from_bits(1));",
            "assert_eq!(res, Ok(Duration::new(0, 0)));",
            "",
            "let res = Duration::try_from_secs_f32(-5.0);",
            "assert!(res.is_err());",
            "let res = Duration::try_from_secs_f32(f32::NAN);",
            "assert!(res.is_err());",
            "let res = Duration::try_from_secs_f32(2e19);",
            "assert!(res.is_err());",
            "",
            "// the conversion uses rounding with tie resolution to even",
            "let res = Duration::try_from_secs_f32(0.999e-9);",
            "assert_eq!(res, Ok(Duration::new(0, 1)));",
            "",
            "// this float represents exactly 976562.5e-9",
            "let val = f32::from_bits(0x3A80_0000);",
            "let res = Duration::try_from_secs_f32(val);",
            "assert_eq!(res, Ok(Duration::new(0, 976_562)));",
            "",
            "// this float represents exactly 2929687.5e-9",
            "let val = f32::from_bits(0x3B40_0000);",
            "let res = Duration::try_from_secs_f32(val);",
            "assert_eq!(res, Ok(Duration::new(0, 2_929_688)));",
            "",
            "// this float represents exactly 1.000_976_562_5",
            "let val = f32::from_bits(0x3F802000);",
            "let res = Duration::try_from_secs_f32(val);",
            "assert_eq!(res, Ok(Duration::new(1, 976_562)));",
            "",
            "// this float represents exactly 1.002_929_687_5",
            "let val = f32::from_bits(0x3F806000);",
            "let res = Duration::try_from_secs_f32(val);",
            "assert_eq!(res, Ok(Duration::new(1, 2_929_688)));",
            "```"
        ],
        "source_code": "    #[inline]\n    pub fn try_from_secs_f32(secs: f32) -> Result<Duration, TryFromFloatSecsError> {\n        try_from_secs!(\n            secs = secs,\n            mantissa_bits = 23,\n            exponent_bits = 8,\n            offset = 41,\n            bits_ty = u32,\n            double_ty = u64,\n        )\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n    #[inline]\n    pub const fn try_from_secs_f32(secs: f32) -> Result<Duration, TryFromFloatSecsError> {\n        try_from_secs!(\n            secs = secs,\n            mantissa_bits = 23,\n            exponent_bits = 8,\n            offset = 41,\n            bits_ty = u32,\n            double_ty = u64,\n        )\n    }"
    },
    {
        "name": "alloc",
        "from_version": "1.71.1",
        "to_version": "1.72.0",
        "module": "alloc::alloc",
        "type": "function",
        "signature": "pub unsafe fn alloc(layout: Layout) -> *mut u8",
        "change_type": "implicit",
        "source_code": "#[must_use = \"losing the pointer will leak memory\"]\n#[inline]\npub unsafe fn alloc(layout: Layout) -> *mut u8 {\n    unsafe {\n        // Make sure we don't accidentally allow omitting the allocator shim in\n        // stable code until it is actually stabilized.\n        core::ptr::read_volatile(&__rust_no_alloc_shim_is_unstable);\n\n        __rust_alloc(layout.size(), layout.align())\n    }\n}",
        "old_source_code": "#[must_use = \"losing the pointer will leak memory\"]\n#[inline]\npub unsafe fn alloc(layout: Layout) -> *mut u8 {\n    unsafe {\n        // Make sure we don't accidentally allow omitting the allocator shim in\n        // stable code until it is actually stabilized.\n        #[cfg(not(bootstrap))]\n        core::ptr::read_volatile(&__rust_no_alloc_shim_is_unstable);\n\n        __rust_alloc(layout.size(), layout.align())\n    }\n}"
    },
    {
        "name": "div",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::num::wrapping",
        "type": "method",
        "signature": "impl Div for Wrapping<$t>",
        "change_type": "signature",
        "source_code": "        impl Div for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                Wrapping(self.0.wrapping_div(other.0))\n            }\n        }",
        "old_source_code": "        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n        impl const Div for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                Wrapping(self.0.wrapping_div(other.0))\n            }\n        }"
    },
    {
        "name": "from_secs_f32",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "core::time",
        "type": "function",
        "signature": "pub fn from_secs_f32(secs: f32) -> Duration",
        "change_type": "signature",
        "source_code": "    #[must_use]\n    #[inline]\n    pub fn from_secs_f32(secs: f32) -> Duration {\n        match Duration::try_from_secs_f32(secs) {\n            Ok(v) => v,\n            Err(e) => panic!(\"{}\", e.description()),\n        }\n    }",
        "old_source_code": "    #[must_use]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n    pub const fn from_secs_f32(secs: f32) -> Duration {\n        match Duration::try_from_secs_f32(secs) {\n            Ok(v) => v,\n            Err(e) => panic!(\"{}\", e.description()),\n        }\n    }"
    },
    {
        "name": "new",
        "from_version": "1.70.0",
        "to_version": "1.71.0",
        "module": "alloc::collections::linked_list",
        "type": "function",
        "signature": "pub const fn new() -> Self",
        "change_type": "implicit",
        "source_code": "    #[must_use]\n    pub const fn new() -> Self {\n        LinkedList { head: None, tail: None, len: 0, alloc: Global, marker: PhantomData }\n    }",
        "old_source_code": "    #[must_use]\n    pub const fn new() -> Self {\n        LinkedList { head: None, tail: None, len: 0, marker: PhantomData }\n    }"
    },
    {
        "name": "retain",
        "from_version": "1.71.1",
        "to_version": "1.72.0",
        "module": "alloc::collections::btree::set",
        "type": "method",
        "signature": "pub fn retain<F>(&mut self, mut f: F)\n    where\n        T: Ord,\n        F: FnMut(&T) -> bool,",
        "change_type": "implicit",
        "source_code": "    pub fn retain<F>(&mut self, mut f: F)\n    where\n        T: Ord,\n        F: FnMut(&T) -> bool,\n    {\n        self.extract_if(|v| !f(v)).for_each(drop);\n    }",
        "old_source_code": "    pub fn retain<F>(&mut self, mut f: F)\n    where\n        T: Ord,\n        F: FnMut(&T) -> bool,\n    {\n        self.drain_filter(|v| !f(v));\n    }"
    },
    {
        "name": "from_encoded_bytes_unchecked",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "std::ffi::os_str",
        "type": "function",
        "signature": "pub unsafe fn from_encoded_bytes_unchecked(bytes: &[u8]) -> &Self",
        "change_type": "stabilized",
        "source_code": "    pub unsafe fn from_encoded_bytes_unchecked(bytes: &[u8]) -> &Self {\n        Self::from_inner(Slice::from_encoded_bytes_unchecked(bytes))\n    }",
        "old_source_code": ""
    },
    {
        "name": "fmt",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::num::saturating",
        "type": "method",
        "signature": "impl<T: fmt::UpperHex> fmt::UpperHex for Saturating<T>",
        "change_type": "stabilized",
        "source_code": "impl<T: fmt::UpperHex> fmt::UpperHex for Saturating<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}",
        "old_source_code": ""
    },
    {
        "name": "rotate_left",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::num::saturating",
        "type": "method",
        "signature": "pub const fn rotate_left(self, n: u32) -> Self",
        "change_type": "stabilized",
        "source_code": "            pub const fn rotate_left(self, n: u32) -> Self {\n                Saturating(self.0.rotate_left(n))\n            }",
        "old_source_code": ""
    },
    {
        "name": "swap_bytes",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::num::saturating",
        "type": "method",
        "signature": "pub const fn swap_bytes(self) -> Self",
        "change_type": "stabilized",
        "source_code": "            pub const fn swap_bytes(self) -> Self {\n                Saturating(self.0.swap_bytes())\n            }",
        "old_source_code": ""
    },
    {
        "name": "to_le",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::num::saturating",
        "type": "method",
        "signature": "without modifying the original\"]\n            pub const fn to_le(self) -> Self",
        "change_type": "stabilized",
        "source_code": "            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            pub const fn to_le(self) -> Self {\n                Saturating(self.0.to_le())\n            }",
        "old_source_code": ""
    },
    {
        "name": "abs",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::num::saturating",
        "type": "method",
        "signature": "without modifying the original\"]\n            pub const fn abs(self) -> Saturating<$t>",
        "change_type": "stabilized",
        "source_code": "            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            pub const fn abs(self) -> Saturating<$t> {\n                Saturating(self.0.saturating_abs())\n            }",
        "old_source_code": ""
    },
    {
        "name": "signum",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "core::num::saturating",
        "type": "method",
        "signature": "without modifying the original\"]\n            pub const fn signum(self) -> Saturating<$t>",
        "change_type": "stabilized",
        "source_code": "            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            pub const fn signum(self) -> Saturating<$t> {\n                Saturating(self.0.signum())\n            }",
        "old_source_code": ""
    },
    {
        "name": "creation_flags",
        "from_version": "1.73.0",
        "to_version": "1.74.0",
        "module": "std::os::windows::process",
        "type": "method",
        "signature": "impl CommandExt for process::Command",
        "change_type": "implicit",
        "source_code": "impl CommandExt for process::Command {\n    fn creation_flags(&mut self, flags: u32) -> &mut process::Command {\n        self.as_inner_mut().creation_flags(flags);\n        self\n    }\n\n    fn force_quotes(&mut self, enabled: bool) -> &mut process::Command {\n        self.as_inner_mut().force_quotes(enabled);\n        self\n    }\n\n    fn raw_arg<S: AsRef<OsStr>>(&mut self, raw_text: S) -> &mut process::Command {\n        self.as_inner_mut().raw_arg(raw_text.as_ref());\n        self\n    }\n\n    fn async_pipes(&mut self, always_async: bool) -> &mut process::Command {\n        // FIXME: This currently has an intentional no-op implementation.\n        // For the time being our side of the pipes will always be async.\n        // Once the ecosystem has adjusted, we may then be able to start making\n        // use of synchronous pipes within the standard library.\n        let _ = always_async;\n        self\n    }\n\n    unsafe fn raw_attribute<T: Copy + Send + Sync + 'static>(\n        &mut self,\n        attribute: usize,\n        value: T,\n    ) -> &mut process::Command {\n        self.as_inner_mut().raw_attribute(attribute, value);\n        self\n    }\n}",
        "old_source_code": "impl CommandExt for process::Command {\n    fn creation_flags(&mut self, flags: u32) -> &mut process::Command {\n        self.as_inner_mut().creation_flags(flags);\n        self\n    }\n\n    fn force_quotes(&mut self, enabled: bool) -> &mut process::Command {\n        self.as_inner_mut().force_quotes(enabled);\n        self\n    }\n\n    fn raw_arg<S: AsRef<OsStr>>(&mut self, raw_text: S) -> &mut process::Command {\n        self.as_inner_mut().raw_arg(raw_text.as_ref());\n        self\n    }\n\n    fn async_pipes(&mut self, always_async: bool) -> &mut process::Command {\n        // FIXME: This currently has an intentional no-op implementation.\n        // For the time being our side of the pipes will always be async.\n        // Once the ecosystem has adjusted, we may then be able to start making\n        // use of synchronous pipes within the standard library.\n        let _ = always_async;\n        self\n    }\n}"
    },
    {
        "name": "set",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "std::sync::once_lock",
        "type": "method",
        "signature": "pub fn set(&self, value: T) -> Result<(), T>",
        "change_type": "implicit",
        "source_code": "    pub fn set(&self, value: T) -> Result<(), T> {\n        match self.try_insert(value) {\n            Ok(_) => Ok(()),\n            Err((_, value)) => Err(value),\n        }\n    }",
        "old_source_code": "    pub fn set(&self, value: T) -> Result<(), T> {\n        let mut value = Some(value);\n        self.get_or_init(|| value.take().unwrap());\n        match value {\n            None => Ok(()),\n            Some(value) => Err(value),\n        }\n    }"
    },
    {
        "name": "to_ipv4_mapped",
        "from_version": "1.74.1",
        "to_version": "1.75.0",
        "module": "core::net::ip_addr",
        "type": "method",
        "signature": "pub const fn to_ipv4_mapped(&self) -> Option<Ipv4Addr>",
        "change_type": "signature",
        "source_code": "    #[rustc_const_stable(feature = \"const_ipv6_to_ipv4_mapped\", since = \"1.75.0\")]\n    pub const fn to_ipv4_mapped(&self) -> Option<Ipv4Addr> {\n        match self.octets() {\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, a, b, c, d] => {\n                Some(Ipv4Addr::new(a, b, c, d))\n            }\n            _ => None,\n        }\n    }",
        "old_source_code": "    #[must_use = \"this returns the result of the operation, \\\n                  without modifying the original\"]\n    #[inline]\n    pub const fn to_ipv4_mapped(&self) -> Option<Ipv4Addr> {\n        match self.octets() {\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, a, b, c, d] => {\n                Some(Ipv4Addr::new(a, b, c, d))\n            }\n            _ => None,\n        }\n    }"
    },
    {
        "name": "description",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "alloc::boxed",
        "type": "method",
        "signature": "impl<E: Error> Error for Box<E>",
        "change_type": "signature",
        "source_code": "impl<E: Error> Error for Box<E> {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n        Error::description(&**self)\n    }\n\n    #[allow(deprecated)]\n    fn cause(&self) -> Option<&dyn Error> {\n        Error::cause(&**self)\n    }\n\n    fn source(&self) -> Option<&(dyn Error + 'static)> {\n        Error::source(&**self)\n    }\n\n    fn provide<'b>(&'b self, request: &mut error::Request<'b>) {\n        Error::provide(&**self, request);\n    }\n}",
        "old_source_code": "impl<T: core::error::Error> core::error::Error for Box<T> {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n        core::error::Error::description(&**self)\n    }\n\n    #[allow(deprecated)]\n    fn cause(&self) -> Option<&dyn core::error::Error> {\n        core::error::Error::cause(&**self)\n    }\n\n    fn source(&self) -> Option<&(dyn core::error::Error + 'static)> {\n        core::error::Error::source(&**self)\n    }\n\n    fn provide<'b>(&'b self, request: &mut core::error::Request<'b>) {\n        core::error::Error::provide(&**self, request);\n    }\n}"
    },
    {
        "name": "cmp",
        "from_version": "1.75.0",
        "to_version": "1.76.0",
        "module": "core::ptr::const_ptr",
        "type": "method",
        "signature": "impl<T: ?Sized> Ord for *const T",
        "change_type": "implicit",
        "source_code": "impl<T: ?Sized> Ord for *const T {\n    #[inline]\n    #[cfg_attr(not(bootstrap), allow(ambiguous_wide_pointer_comparisons))]\n    fn cmp(&self, other: &*const T) -> Ordering {\n        if self < other {\n            Less\n        } else if self == other {\n            Equal\n        } else {\n            Greater\n        }\n    }\n}",
        "old_source_code": "impl<T: ?Sized> Ord for *const T {\n    #[inline]\n    fn cmp(&self, other: &*const T) -> Ordering {\n        if self < other {\n            Less\n        } else if self == other {\n            Equal\n        } else {\n            Greater\n        }\n    }\n}"
    },
    {
        "name": "each_ref",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::array",
        "type": "method",
        "signature": "pub fn each_ref(&self) -> [&T; N]",
        "change_type": "stabilized",
        "source_code": "    pub fn each_ref(&self) -> [&T; N] {\n        from_trusted_iterator(self.iter())\n    }",
        "old_source_code": ""
    },
    {
        "name": "first_chunk_mut",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub const fn first_chunk_mut<const N: usize>(&mut self) -> Option<&mut [T; N]>",
        "change_type": "stabilized",
        "source_code": "    #[rustc_const_unstable(feature = \"const_slice_first_last_chunk\", issue = \"111774\")]\n    pub const fn first_chunk_mut<const N: usize>(&mut self) -> Option<&mut [T; N]> {\n        if self.len() < N {\n            None\n        } else {\n            // SAFETY: We explicitly check for the correct number of elements,\n            //   do not let the reference outlive the slice,\n            //   and require exclusive access to the entire slice to mutate the chunk.\n            Some(unsafe { &mut *(self.as_mut_ptr().cast::<[T; N]>()) })\n        }\n    }",
        "old_source_code": ""
    },
    {
        "name": "split_first_chunk",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub const fn split_first_chunk<const N: usize>(&self) -> Option<(&[T; N], &[T])>",
        "change_type": "stabilized",
        "source_code": "    #[rustc_const_stable(feature = \"slice_first_last_chunk\", since = \"1.77.0\")]\n    pub const fn split_first_chunk<const N: usize>(&self) -> Option<(&[T; N], &[T])> {\n        if self.len() < N {\n            None\n        } else {\n            // SAFETY: We manually verified the bounds of the split.\n            let (first, tail) = unsafe { self.split_at_unchecked(N) };\n\n            // SAFETY: We explicitly check for the correct number of elements,\n            //   and do not let the references outlive the slice.\n            Some((unsafe { &*(first.as_ptr().cast::<[T; N]>()) }, tail))\n        }\n    }",
        "old_source_code": ""
    },
    {
        "name": "split_first_chunk_mut",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub const fn split_first_chunk_mut<const N: usize>(\n        &mut self,\n    ) -> Option<(&mut [T; N], &mut [T])>",
        "change_type": "stabilized",
        "source_code": "    #[rustc_const_unstable(feature = \"const_slice_first_last_chunk\", issue = \"111774\")]\n    pub const fn split_first_chunk_mut<const N: usize>(\n        &mut self,\n    ) -> Option<(&mut [T; N], &mut [T])> {\n        if self.len() < N {\n            None\n        } else {\n            // SAFETY: We manually verified the bounds of the split.\n            let (first, tail) = unsafe { self.split_at_mut_unchecked(N) };\n\n            // SAFETY: We explicitly check for the correct number of elements,\n            //   do not let the reference outlive the slice,\n            //   and enforce exclusive mutability of the chunk by the split.\n            Some((unsafe { &mut *(first.as_mut_ptr().cast::<[T; N]>()) }, tail))\n        }\n    }",
        "old_source_code": ""
    },
    {
        "name": "split_last_chunk",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub const fn split_last_chunk<const N: usize>(&self) -> Option<(&[T], &[T; N])>",
        "change_type": "stabilized",
        "source_code": "    #[rustc_const_stable(feature = \"slice_first_last_chunk\", since = \"1.77.0\")]\n    pub const fn split_last_chunk<const N: usize>(&self) -> Option<(&[T], &[T; N])> {\n        if self.len() < N {\n            None\n        } else {\n            // SAFETY: We manually verified the bounds of the split.\n            let (init, last) = unsafe { self.split_at_unchecked(self.len() - N) };\n\n            // SAFETY: We explicitly check for the correct number of elements,\n            //   and do not let the references outlive the slice.\n            Some((init, unsafe { &*(last.as_ptr().cast::<[T; N]>()) }))\n        }\n    }",
        "old_source_code": ""
    },
    {
        "name": "split_last_chunk_mut",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub const fn split_last_chunk_mut<const N: usize>(\n        &mut self,\n    ) -> Option<(&mut [T], &mut [T; N])>",
        "change_type": "stabilized",
        "source_code": "    #[rustc_const_unstable(feature = \"const_slice_first_last_chunk\", issue = \"111774\")]\n    pub const fn split_last_chunk_mut<const N: usize>(\n        &mut self,\n    ) -> Option<(&mut [T], &mut [T; N])> {\n        if self.len() < N {\n            None\n        } else {\n            // SAFETY: We manually verified the bounds of the split.\n            let (init, last) = unsafe { self.split_at_mut_unchecked(self.len() - N) };\n\n            // SAFETY: We explicitly check for the correct number of elements,\n            //   do not let the reference outlive the slice,\n            //   and enforce exclusive mutability of the chunk by the split.\n            Some((init, unsafe { &mut *(last.as_mut_ptr().cast::<[T; N]>()) }))\n        }\n    }",
        "old_source_code": ""
    },
    {
        "name": "overflowing_abs",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn overflowing_abs(self) -> (Self, bool)",
        "change_type": "signature",
        "source_code": "        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_abs(self) -> (Self, bool) {\n            let (nz, flag) = self.get().overflowing_abs();\n            (\n                // SAFETY: absolute value of nonzero cannot yield zero values.\n                unsafe { Self::new_unchecked(nz) },\n                flag,\n            )\n        }",
        "old_source_code": "                #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n                #[must_use = \"this returns the result of the operation, \\\n                              without modifying the original\"]\n                #[inline]\n                pub const fn overflowing_abs(self) -> ($Ty, bool) {\n                    let (nz, flag) = self.get().overflowing_abs();\n                    (\n                        // SAFETY: absolute value of nonzero cannot yield zero values.\n                        unsafe { $Ty::new_unchecked(nz) },\n                        flag,\n                    )\n                }"
    },
    {
        "name": "saturating_mul",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "without modifying the original\"]\n            pub const fn saturating_mul(self, other: Self) -> Self",
        "change_type": "signature",
        "source_code": "            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn saturating_mul(self, other: Self) -> Self {\n                // SAFETY:\n                // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,\n                //   all of which are non-zero\n                // - `self` and `other` are non-zero\n                // - the only way to get zero from a multiplication without overflow is for one\n                //   of the sides to be zero\n                //\n                // So the result cannot be zero.\n                unsafe { Self::new_unchecked(self.get().saturating_mul(other.get())) }\n            }",
        "old_source_code": "                #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n                #[must_use = \"this returns the result of the operation, \\\n                              without modifying the original\"]\n                #[inline]\n                pub const fn saturating_mul(self, other: $Ty) -> $Ty {\n                    // SAFETY:\n                    // - `saturating_mul` returns `u*::MAX`/`i*::MAX`/`i*::MIN` on overflow/underflow,\n                    //   all of which are non-zero\n                    // - `self` and `other` are non-zero\n                    // - the only way to get zero from a multiplication without overflow is for one\n                    //   of the sides to be zero\n                    //\n                    // So the result cannot be zero.\n                    unsafe { $Ty::new_unchecked(self.get().saturating_mul(other.get())) }\n                }"
    },
    {
        "name": "checked_pow",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "without modifying the original\"]\n            pub const fn checked_pow(self, other: u32) -> Option<Self>",
        "change_type": "signature",
        "source_code": "            #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn checked_pow(self, other: u32) -> Option<Self> {\n                if let Some(result) = self.get().checked_pow(other) {\n                    // SAFETY:\n                    // - `checked_pow` returns `None` on overflow/underflow\n                    // - `self` is non-zero\n                    // - the only way to get zero from an exponentiation without overflow is\n                    //   for base to be zero\n                    //\n                    // So the result cannot be zero.\n                    Some(unsafe { Self::new_unchecked(result) })\n                } else {\n                    None\n                }\n            }",
        "old_source_code": "                #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n                #[must_use = \"this returns the result of the operation, \\\n                              without modifying the original\"]\n                #[inline]\n                pub const fn checked_pow(self, other: u32) -> Option<$Ty> {\n                    if let Some(result) = self.get().checked_pow(other) {\n                        // SAFETY:\n                        // - `checked_pow` returns `None` on overflow/underflow\n                        // - `self` is non-zero\n                        // - the only way to get zero from an exponentiation without overflow is\n                        //   for base to be zero\n                        //\n                        // So the result cannot be zero.\n                        Some(unsafe { $Ty::new_unchecked(result) })\n                    } else {\n                        None\n                    }\n                }"
    },
    {
        "name": "checked_add",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn checked_add(self, other: $Int) -> Option<Self>",
        "change_type": "signature",
        "source_code": "        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, other: $Int) -> Option<Self> {\n            if let Some(result) = self.get().checked_add(other) {\n                // SAFETY:\n                // - `checked_add` returns `None` on overflow\n                // - `self` is non-zero\n                // - the only way to get zero from an addition without overflow is for both\n                //   sides to be zero\n                //\n                // So the result cannot be zero.\n                Some(unsafe { Self::new_unchecked(result) })\n            } else {\n                None\n            }\n        }",
        "old_source_code": "                #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n                #[must_use = \"this returns the result of the operation, \\\n                              without modifying the original\"]\n                #[inline]\n                pub const fn checked_add(self, other: $Int) -> Option<$Ty> {\n                    if let Some(result) = self.get().checked_add(other) {\n                        // SAFETY:\n                        // - `checked_add` returns `None` on overflow\n                        // - `self` is non-zero\n                        // - the only way to get zero from an addition without overflow is for both\n                        //   sides to be zero\n                        //\n                        // So the result cannot be zero.\n                        Some(unsafe { $Ty::new_unchecked(result) })\n                    } else {\n                        None\n                    }\n                }"
    },
    {
        "name": "abs",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn abs(self) -> Self",
        "change_type": "signature",
        "source_code": "        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs(self) -> Self {\n            // SAFETY: This cannot overflow to zero.\n            unsafe { Self::new_unchecked(self.get().abs()) }\n        }",
        "old_source_code": "                #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n                #[must_use = \"this returns the result of the operation, \\\n                              without modifying the original\"]\n                #[inline]\n                pub const fn abs(self) -> $Ty {\n                    // SAFETY: This cannot overflow to zero.\n                    unsafe { $Ty::new_unchecked(self.get().abs()) }\n                }"
    },
    {
        "name": "checked_abs",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn checked_abs(self) -> Option<Self>",
        "change_type": "signature",
        "source_code": "        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_abs(self) -> Option<Self> {\n            if let Some(nz) = self.get().checked_abs() {\n                // SAFETY: absolute value of nonzero cannot yield zero values.\n                Some(unsafe { Self::new_unchecked(nz) })\n            } else {\n                None\n            }\n        }",
        "old_source_code": "                #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n                #[must_use = \"this returns the result of the operation, \\\n                              without modifying the original\"]\n                #[inline]\n                pub const fn checked_abs(self) -> Option<$Ty> {\n                    if let Some(nz) = self.get().checked_abs() {\n                        // SAFETY: absolute value of nonzero cannot yield zero values.\n                        Some(unsafe { $Ty::new_unchecked(nz) })\n                    } else {\n                        None\n                    }\n                }"
    },
    {
        "name": "wrapping_abs",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn wrapping_abs(self) -> Self",
        "change_type": "signature",
        "source_code": "        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_abs(self) -> Self {\n            // SAFETY: absolute value of nonzero cannot yield zero values.\n            unsafe { Self::new_unchecked(self.get().wrapping_abs()) }\n        }",
        "old_source_code": "                #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n                #[must_use = \"this returns the result of the operation, \\\n                              without modifying the original\"]\n                #[inline]\n                pub const fn wrapping_abs(self) -> $Ty {\n                    // SAFETY: absolute value of nonzero cannot yield zero values.\n                    unsafe { $Ty::new_unchecked(self.get().wrapping_abs()) }\n                }"
    },
    {
        "name": "saturating_add",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn saturating_add(self, other: $Int) -> Self",
        "change_type": "signature",
        "source_code": "        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add(self, other: $Int) -> Self {\n            // SAFETY:\n            // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero\n            // - `self` is non-zero\n            // - the only way to get zero from an addition without overflow is for both\n            //   sides to be zero\n            //\n            // So the result cannot be zero.\n            unsafe { Self::new_unchecked(self.get().saturating_add(other)) }\n        }",
        "old_source_code": "                #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n                #[must_use = \"this returns the result of the operation, \\\n                              without modifying the original\"]\n                #[inline]\n                pub const fn saturating_add(self, other: $Int) -> $Ty {\n                    // SAFETY:\n                    // - `saturating_add` returns `u*::MAX` on overflow, which is non-zero\n                    // - `self` is non-zero\n                    // - the only way to get zero from an addition without overflow is for both\n                    //   sides to be zero\n                    //\n                    // So the result cannot be zero.\n                    unsafe { $Ty::new_unchecked(self.get().saturating_add(other)) }\n                }"
    },
    {
        "name": "checked_next_power_of_two",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self>",
        "change_type": "signature",
        "source_code": "        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            if let Some(nz) = self.get().checked_next_power_of_two() {\n                // SAFETY: The next power of two is positive\n                // and overflow is checked.\n                Some(unsafe { Self::new_unchecked(nz) })\n            } else {\n                None\n            }\n        }",
        "old_source_code": "                #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n                #[must_use = \"this returns the result of the operation, \\\n                              without modifying the original\"]\n                #[inline]\n                pub const fn checked_next_power_of_two(self) -> Option<$Ty> {\n                    if let Some(nz) = self.get().checked_next_power_of_two() {\n                        // SAFETY: The next power of two is positive\n                        // and overflow is checked.\n                        Some(unsafe { $Ty::new_unchecked(nz) })\n                    } else {\n                        None\n                    }\n                }"
    },
    {
        "name": "saturating_abs",
        "from_version": "1.76.0",
        "to_version": "1.77.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn saturating_abs(self) -> Self",
        "change_type": "signature",
        "source_code": "        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_abs(self) -> Self {\n            // SAFETY: absolute value of nonzero cannot yield zero values.\n            unsafe { Self::new_unchecked(self.get().saturating_abs()) }\n        }",
        "old_source_code": "                #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n                #[must_use = \"this returns the result of the operation, \\\n                              without modifying the original\"]\n                #[inline]\n                pub const fn saturating_abs(self) -> $Ty {\n                    // SAFETY: absolute value of nonzero cannot yield zero values.\n                    unsafe { $Ty::new_unchecked(self.get().saturating_abs()) }\n                }"
    },
    {
        "name": "available_parallelism",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "std::thread",
        "type": "function",
        "signature": "pub fn available_parallelism() -> io::Result<NonZero<usize>>",
        "change_type": "signature",
        "documentation": "Returns an estimate of the default amount of parallelism a program should use.\n\nParallelism is a resource. A given machine provides a certain capacity for\nparallelism, i.e., a bound on the number of computations it can perform\nsimultaneously. This number often corresponds to the amount of CPUs a\ncomputer has, but it may diverge in various cases.\n\nHost environments such as VMs or container orchestrators may want to\nrestrict the amount of parallelism made available to programs in them. This\nis often done to limit the potential impact of (unintentionally)\nresource-intensive programs on other programs running on the same machine.\n\n# Limitations\n\nThe purpose of this API is to provide an easy and portable way to query\nthe default amount of parallelism the program should use. Among other things it\ndoes not expose information on NUMA regions, does not account for\ndifferences in (co)processor capabilities or current system load,\nand will not modify the program's global state in order to more accurately\nquery the amount of available parallelism.\n\nWhere both fixed steady-state and burst limits are available the steady-state\ncapacity will be used to ensure more predictable latencies.\n\nResource limits can be changed during the runtime of a program, therefore the value is\nnot cached and instead recomputed every time this function is called. It should not be\ncalled from hot code.\n\nThe value returned by this function should be considered a simplified\napproximation of the actual amount of parallelism available at any given\ntime. To get a more detailed or precise overview of the amount of\nparallelism available to the program, you may wish to use\nplatform-specific APIs as well. The following platform limitations currently\napply to `available_parallelism`:\n\nOn Windows:\n- It may undercount the amount of parallelism available on systems with more\nthan 64 logical CPUs. However, programs typically need specific support to\ntake advantage of more than 64 logical CPUs, and in the absence of such\nsupport, the number returned by this function accurately reflects the\nnumber of logical CPUs the program can use by default.\n- It may overcount the amount of parallelism available on systems limited by\nprocess-wide affinity masks, or job object limitations.\n\nOn Linux:\n- It may overcount the amount of parallelism available when limited by a\nprocess-wide affinity mask or cgroup quotas and `sched_getaffinity()` or cgroup fs can't be\nqueried, e.g. due to sandboxing.\n- It may undercount the amount of parallelism if the current thread's affinity mask\ndoes not reflect the process' cpuset, e.g. due to pinned threads.\n- If the process is in a cgroup v1 cpu controller, this may need to\nscan mountpoints to find the corresponding cgroup v1 controller,\nwhich may take time on systems with large numbers of mountpoints.\n(This does not apply to cgroup v2, or to processes not in a\ncgroup.)\n\nOn all targets:\n- It may overcount the amount of parallelism available when running in a VM\nwith CPU usage limits (e.g. an overcommitted host).\n\n# Errors\n\nThis function will, but is not limited to, return errors in the following\ncases:\n\n- If the amount of parallelism is not known for the target platform.\n- If the program lacks permission to query the amount of parallelism made\navailable to it.\n\n# #![allow(dead_code)]\nuse std::{io, thread};\n\nfn main() -> io::Result<()> {\nlet count = thread::available_parallelism()?.get();\nassert!(count >= 1_usize);\nOk(())\n}\n```",
        "examples": [
            "",
            "```"
        ],
        "source_code": "pub fn available_parallelism() -> io::Result<NonZero<usize>> {\n    imp::available_parallelism()\n}",
        "old_source_code": "pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n    imp::available_parallelism()\n}"
    },
    {
        "name": "copy_nonoverlapping",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "std::ptr",
        "type": "function",
        "signature": "pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize)",
        "change_type": "implicit",
        "documentation": "Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\nand destination must *not* overlap.\n\nFor regions of memory which might overlap, use [`copy`] instead.\n\n`copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\nwith the argument order swapped.\n\nThe copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\nrequirements of `T`. The initialization state is preserved exactly.\n\n[`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n# Safety\n\nBehavior is undefined if any of the following conditions are violated:\n\n* `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n* `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n* Both `src` and `dst` must be properly aligned.\n\n* The region of memory beginning at `src` with a size of `count *\nsize_of::<T>()` bytes must *not* overlap with the region of memory\nbeginning at `dst` with the same size.\n\nLike [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\nwhether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\nin the region beginning at `*src` and the region beginning at `*dst` can\n[violate memory safety][read-ownership].\n\nNote that even if the effectively copied size (`count * size_of::<T>()`) is\n`0`, the pointers must be properly aligned.\n\n[`read`]: crate::ptr::read\n[read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n[valid]: crate::ptr#safety\n",
        "examples": [
            "",
            "Manually implement [`Vec::append`]:",
            "",
            "```",
            "use std::ptr;",
            "",
            "/// Moves all the elements of `src` into `dst`, leaving `src` empty.",
            "fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {",
            "let src_len = src.len();",
            "let dst_len = dst.len();",
            "",
            "// Ensure that `dst` has enough capacity to hold all of `src`.",
            "dst.reserve(src_len);",
            "",
            "unsafe {",
            "// The call to add is always safe because `Vec` will never",
            "// allocate more than `isize::MAX` bytes.",
            "let dst_ptr = dst.as_mut_ptr().add(dst_len);",
            "let src_ptr = src.as_ptr();",
            "",
            "// Truncate `src` without dropping its contents. We do this first,",
            "// to avoid problems in case something further down panics.",
            "src.set_len(0);",
            "",
            "// The two regions cannot overlap because mutable references do",
            "// not alias, and two different vectors cannot own the same",
            "// memory.",
            "ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);",
            "",
            "// Notify `dst` that it now holds the contents of `src`.",
            "dst.set_len(dst_len + src_len);",
            "}",
            "}",
            "",
            "let mut a = vec!['r'];",
            "let mut b = vec!['u', 's', 't'];",
            "",
            "append(&mut a, &mut b);",
            "",
            "assert_eq!(a, &['r', 'u', 's', 't']);",
            "assert!(b.is_empty());",
            "```",
            "",
            "[`Vec::append`]: ../../std/vec/struct.Vec.html#method.append"
        ],
        "source_code": "#[rustc_allowed_through_unstable_modules]\n#[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.83.0\")]\n#[inline(always)]\n#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n#[rustc_diagnostic_item = \"ptr_copy_nonoverlapping\"]\npub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n    #[cfg_attr(bootstrap, rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.83.0\"))]\n    #[cfg_attr(not(bootstrap), rustc_intrinsic_const_stable_indirect)]\n    #[rustc_nounwind]\n    #[rustc_intrinsic]\n    #[rustc_intrinsic_must_be_overridden]\n    const unsafe fn copy_nonoverlapping<T>(_src: *const T, _dst: *mut T, _count: usize) {\n        unreachable!()\n    }\n\n    ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null \\\n        and the specified memory ranges do not overlap\",\n        (\n            src: *const () = src as *const (),\n            dst: *mut () = dst as *mut (),\n            size: usize = size_of::<T>(),\n            align: usize = align_of::<T>(),\n            count: usize = count,\n        ) => {\n            let zero_size = count == 0 || size == 0;\n            ub_checks::maybe_is_aligned_and_not_null(src, align, zero_size)\n                && ub_checks::maybe_is_aligned_and_not_null(dst, align, zero_size)\n                && ub_checks::maybe_is_nonoverlapping(src, dst, size, count)\n        }\n    );\n\n    // SAFETY: the safety contract for `copy_nonoverlapping` must be\n    // upheld by the caller.\n    unsafe { copy_nonoverlapping(src, dst, count) }\n}",
        "old_source_code": "#[rustc_allowed_through_unstable_modules]\n#[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.83.0\")]\n#[inline(always)]\n#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n#[rustc_diagnostic_item = \"ptr_copy_nonoverlapping\"]\npub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n    extern \"rust-intrinsic\" {\n        #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.83.0\")]\n        #[rustc_nounwind]\n        pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n    }\n\n    ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null \\\n        and the specified memory ranges do not overlap\",\n        (\n            src: *const () = src as *const (),\n            dst: *mut () = dst as *mut (),\n            size: usize = size_of::<T>(),\n            align: usize = align_of::<T>(),\n            count: usize = count,\n        ) =>\n        ub_checks::is_aligned_and_not_null(src, align)\n            && ub_checks::is_aligned_and_not_null(dst, align)\n            && ub_checks::is_nonoverlapping(src, dst, size, count)\n    );\n\n    // SAFETY: the safety contract for `copy_nonoverlapping` must be\n    // upheld by the caller.\n    unsafe { copy_nonoverlapping(src, dst, count) }\n}"
    },
    {
        "name": "write_fmt",
        "from_version": "1.77.2",
        "to_version": "1.78.0",
        "module": "core::fmt",
        "type": "method",
        "signature": "pub fn write_fmt(&mut self, fmt: Arguments<'_>) -> Result",
        "change_type": "implicit",
        "source_code": "    #[inline]\n    pub fn write_fmt(&mut self, fmt: Arguments<'_>) -> Result {\n        if let Some(s) = fmt.as_const_str() { self.buf.write_str(s) } else { write(self.buf, fmt) }\n    }",
        "old_source_code": "    pub fn write_fmt(&mut self, fmt: Arguments<'_>) -> Result {\n        write(self.buf, fmt)\n    }"
    },
    {
        "name": "invalid",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "core::str::lossy",
        "type": "method",
        "signature": "pub fn invalid(&self) -> &'a [u8]",
        "change_type": "stabilized",
        "source_code": "    pub fn invalid(&self) -> &'a [u8] {\n        self.invalid\n    }",
        "old_source_code": ""
    },
    {
        "name": "kind",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "core::num::error",
        "type": "method",
        "signature": "pub const fn kind(&self) -> &IntErrorKind",
        "change_type": "signature",
        "source_code": "    pub const fn kind(&self) -> &IntErrorKind {\n        &self.kind\n    }",
        "old_source_code": "    pub fn kind(&self) -> &IntErrorKind {\n        &self.kind\n    }"
    },
    {
        "name": "pop_back",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "alloc::collections::vec_deque",
        "type": "method",
        "signature": "pub fn pop_back(&mut self) -> Option<T>",
        "change_type": "implicit",
        "source_code": "    pub fn pop_back(&mut self) -> Option<T> {\n        if self.is_empty() {\n            None\n        } else {\n            self.len -= 1;\n            unsafe {\n                core::hint::assert_unchecked(self.len < self.capacity());\n                Some(self.buffer_read(self.to_physical_idx(self.len)))\n            }\n        }\n    }",
        "old_source_code": "    pub fn pop_back(&mut self) -> Option<T> {\n        if self.is_empty() {\n            None\n        } else {\n            self.len -= 1;\n            Some(unsafe { self.buffer_read(self.to_physical_idx(self.len)) })\n        }\n    }"
    },
    {
        "name": "next",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "core::char",
        "type": "method",
        "signature": "impl Iterator for $ITER_NAME",
        "change_type": "signature",
        "source_code": "        impl Iterator for $ITER_NAME {\n            type Item = char;\n            fn next(&mut self) -> Option<char> {\n                self.0.next()\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                self.0.size_hint()\n            }\n\n            fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n            where\n                Fold: FnMut(Acc, Self::Item) -> Acc,\n            {\n                self.0.fold(init, fold)\n            }\n\n            fn count(self) -> usize {\n                self.0.count()\n            }\n\n            fn last(self) -> Option<Self::Item> {\n                self.0.last()\n            }\n\n            fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                self.0.advance_by(n)\n            }\n\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: just forwarding requirements to caller\n                unsafe { self.0.__iterator_get_unchecked(idx) }\n            }\n        }",
        "old_source_code": "impl Iterator for ToUppercase {\n    type Item = char;\n    fn next(&mut self) -> Option<char> {\n        self.0.next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}"
    },
    {
        "name": "get",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "pub const fn get(self) -> T",
        "change_type": "implicit",
        "source_code": "    #[rustc_const_stable(feature = \"const_nonzero_get\", since = \"1.34.0\")]\n    #[inline]\n    pub const fn get(self) -> T {\n        // FIXME: This can be changed to simply `self.0` once LLVM supports `!range` metadata\n        // for function arguments: https://github.com/llvm/llvm-project/issues/76628\n        //\n        // Rustc can set range metadata only if it loads `self` from\n        // memory somewhere. If the value of `self` was from by-value argument\n        // of some not-inlined function, LLVM don't have range metadata\n        // to understand that the value cannot be zero.\n        //\n        // For now, using the transmute `assume`s the range at runtime.\n        //\n        // SAFETY: `ZeroablePrimitive` guarantees that the size and bit validity\n        // of `.0` is such that this transmute is sound.\n        unsafe { intrinsics::transmute_unchecked(self) }\n    }",
        "old_source_code": "    #[rustc_const_stable(feature = \"const_nonzero_get\", since = \"1.34.0\")]\n    #[inline]\n    pub const fn get(self) -> T {\n        // FIXME: This can be changed to simply `self.0` once LLVM supports `!range` metadata\n        // for function arguments: https://github.com/llvm/llvm-project/issues/76628\n        //\n        // Rustc can set range metadata only if it loads `self` from\n        // memory somewhere. If the value of `self` was from by-value argument\n        // of some not-inlined function, LLVM don't have range metadata\n        // to understand that the value cannot be zero.\n        match Self::new(self.0) {\n            Some(Self(n)) => n,\n            None => {\n                // SAFETY: `NonZero` is guaranteed to only contain non-zero values, so this is unreachable.\n                unsafe { intrinsics::unreachable() }\n            }\n        }\n    }"
    },
    {
        "name": "pop_front",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "alloc::collections::vec_deque",
        "type": "method",
        "signature": "pub fn pop_front(&mut self) -> Option<T>",
        "change_type": "implicit",
        "source_code": "    pub fn pop_front(&mut self) -> Option<T> {\n        if self.is_empty() {\n            None\n        } else {\n            let old_head = self.head;\n            self.head = self.to_physical_idx(1);\n            self.len -= 1;\n            unsafe {\n                core::hint::assert_unchecked(self.len < self.capacity());\n                Some(self.buffer_read(old_head))\n            }\n        }\n    }",
        "old_source_code": "    pub fn pop_front(&mut self) -> Option<T> {\n        if self.is_empty() {\n            None\n        } else {\n            let old_head = self.head;\n            self.head = self.to_physical_idx(1);\n            self.len -= 1;\n            Some(unsafe { self.buffer_read(old_head) })\n        }\n    }"
    },
    {
        "name": "checked_ilog",
        "from_version": "1.78.0",
        "to_version": "1.79.0",
        "module": "core::num::uint_macros",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32>",
        "change_type": "implicit",
        "source_code": "        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else {\n                let mut n = 0;\n                let mut r = 1;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else {\n                let mut n = 0;\n                let mut r = self;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    let b = Self::ilog2(self) / (Self::ilog2(base) + 1);\n                    n += b;\n                    r /= base.pow(b as u32);\n                }\n\n                while r >= base {\n                    r /= base;\n                    n += 1;\n                }\n                Some(n)\n            }\n        }"
    },
    {
        "name": "LazyLock",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "std::sync::lazy_lock",
        "type": "struct",
        "signature": "pub struct LazyLock<T, F = fn() -> T>",
        "change_type": "stabilized",
        "source_code": "pub struct LazyLock<T, F = fn() -> T> {\n    once: Once,\n    data: UnsafeCell<Data<T, F>>,\n}",
        "old_source_code": ""
    },
    {
        "name": "new",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "std::sync::lazy_lock",
        "type": "function",
        "signature": "pub const fn new(f: F) -> LazyLock<T, F>",
        "change_type": "stabilized",
        "source_code": "    #[rustc_const_stable(feature = \"lazy_cell\", since = \"1.80.0\")]\n    pub const fn new(f: F) -> LazyLock<T, F> {\n        LazyLock { once: Once::new(), data: UnsafeCell::new(Data { f: ManuallyDrop::new(f) }) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "force",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "std::sync::lazy_lock",
        "type": "function",
        "signature": "pub fn force(this: &LazyLock<T, F>) -> &T",
        "change_type": "stabilized",
        "source_code": "    pub fn force(this: &LazyLock<T, F>) -> &T {\n        this.once.call_once(|| {\n            // SAFETY: `call_once` only runs this closure once, ever.\n            let data = unsafe { &mut *this.data.get() };\n            let f = unsafe { ManuallyDrop::take(&mut data.f) };\n            let value = f();\n            data.value = ManuallyDrop::new(value);\n        });\n\n        // SAFETY:\n        // There are four possible scenarios:\n        // * the closure was called and initialized `value`.\n        // * the closure was called and panicked, so this point is never reached.\n        // * the closure was not called, but a previous call initialized `value`.\n        // * the closure was not called because the Once is poisoned, so this point\n        //   is never reached.\n        // So `value` has definitely been initialized and will not be modified again.\n        unsafe { &*(*this.data.get()).value }\n    }",
        "old_source_code": ""
    },
    {
        "name": "div_duration_f64",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::time",
        "type": "method",
        "signature": "without modifying the original\"]\n    pub const fn div_duration_f64(self, rhs: Duration) -> f64",
        "change_type": "stabilized",
        "source_code": "    #[must_use = \"this returns the result of the operation, \\\n                  without modifying the original\"]\n    #[inline]\n    #[rustc_const_unstable(feature = \"duration_consts_float\", issue = \"72440\")]\n    pub const fn div_duration_f64(self, rhs: Duration) -> f64 {\n        let self_nanos = (self.secs as f64) * (NANOS_PER_SEC as f64) + (self.nanos.0 as f64);\n        let rhs_nanos = (rhs.secs as f64) * (NANOS_PER_SEC as f64) + (rhs.nanos.0 as f64);\n        self_nanos / rhs_nanos\n    }",
        "old_source_code": ""
    },
    {
        "name": "from_bits",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::net::ip_addr",
        "type": "function",
        "signature": "pub const fn from_bits(bits: u128) -> Ipv6Addr",
        "change_type": "stabilized",
        "source_code": "    #[must_use]\n    #[inline]\n    pub const fn from_bits(bits: u128) -> Ipv6Addr {\n        Ipv6Addr { octets: bits.to_be_bytes() }\n    }",
        "old_source_code": ""
    },
    {
        "name": "offset",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "std::ptr::NonNull",
        "type": "method",
        "signature": "pub const unsafe fn offset(self, count: isize) -> Self\n    where\n        T: Sized,",
        "change_type": "stabilized",
        "documentation": "Calculates the offset from a pointer.\n\n`count` is in units of T; e.g., a `count` of 3 represents a pointer\noffset of `3 * size_of::<T>()` bytes.\n\n# Safety\n\nIf any of the following conditions are violated, the result is Undefined\nBehavior:\n\n* Both the starting and resulting pointer must be either in bounds or one\nbyte past the end of the same [allocated object].\n\n* The computed offset, **in bytes**, cannot overflow an `isize`.\n\n* The offset being in bounds cannot rely on \"wrapping around\" the address\nspace. That is, the infinite-precision sum, **in bytes** must fit in a usize.\n\nThe compiler and standard library generally tries to ensure allocations\nnever reach a size where an offset is a concern. For instance, `Vec`\nand `Box` ensure they never allocate more than `isize::MAX` bytes, so\n`vec.as_ptr().add(vec.len())` is always safe.\n\nMost platforms fundamentally can't even construct such an allocation.\nFor instance, no known 64-bit platform can ever serve a request\nfor 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\nHowever, some 32-bit and 16-bit platforms may successfully serve a request for\nmore than `isize::MAX` bytes with things like Physical Address\nExtension. As such, memory acquired directly from allocators or memory\nmapped files *may* be too large to handle with this function.\n\n[allocated object]: crate::ptr#allocated-object\n",
        "examples": [
            "",
            "```",
            "use std::ptr::NonNull;",
            "",
            "let mut s = [1, 2, 3];",
            "let ptr: NonNull<u32> = NonNull::new(s.as_mut_ptr()).unwrap();",
            "",
            "unsafe {",
            "println!(\"{}\", ptr.offset(1).read());",
            "println!(\"{}\", ptr.offset(2).read());",
            "}",
            "```"
        ],
        "source_code": "    #[rustc_const_stable(feature = \"non_null_convenience\", since = \"1.80.0\")]\n    pub const unsafe fn offset(self, count: isize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.pointer, count) } }\n    }",
        "old_source_code": ""
    },
    {
        "name": "byte_add",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::ptr::non_null",
        "type": "method",
        "signature": "pub const unsafe fn byte_add(self, count: usize) -> Self",
        "change_type": "stabilized",
        "source_code": "    #[rustc_const_stable(feature = \"non_null_convenience\", since = \"1.80.0\")]\n    pub const unsafe fn byte_add(self, count: usize) -> Self {\n        // SAFETY: the caller must uphold the safety contract for `add` and `byte_add` has the same\n        // safety contract.\n        // Additionally safety contract of `add` guarantees that the resulting pointer is pointing\n        // to an allocation, there can't be an allocation at null, thus it's safe to construct\n        // `NonNull`.\n        unsafe { NonNull { pointer: self.pointer.byte_add(count) } }\n    }",
        "old_source_code": ""
    },
    {
        "name": "byte_sub",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::ptr::non_null",
        "type": "method",
        "signature": "pub const unsafe fn byte_sub(self, count: usize) -> Self",
        "change_type": "stabilized",
        "source_code": "    #[rustc_const_stable(feature = \"non_null_convenience\", since = \"1.80.0\")]\n    pub const unsafe fn byte_sub(self, count: usize) -> Self {\n        // SAFETY: the caller must uphold the safety contract for `sub` and `byte_sub` has the same\n        // safety contract.\n        // Additionally safety contract of `sub` guarantees that the resulting pointer is pointing\n        // to an allocation, there can't be an allocation at null, thus it's safe to construct\n        // `NonNull`.\n        unsafe { NonNull { pointer: self.pointer.byte_sub(count) } }\n    }",
        "old_source_code": ""
    },
    {
        "name": "align_offset",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::ptr::non_null",
        "type": "method",
        "signature": "pub const fn align_offset(self, align: usize) -> usize\n    where\n        T: Sized,",
        "change_type": "stabilized",
        "source_code": "    #[rustc_const_unstable(feature = \"const_align_offset\", issue = \"90962\")]\n    pub const fn align_offset(self, align: usize) -> usize\n    where\n        T: Sized,\n    {\n        if !align.is_power_of_two() {\n            panic!(\"align_offset: align is not a power-of-two\");\n        }\n\n        {\n            // SAFETY: `align` has been checked to be a power of 2 above.\n            unsafe { ptr::align_offset(self.pointer, align) }\n        }\n    }",
        "old_source_code": ""
    },
    {
        "name": "as_flattened",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub const fn as_flattened(&self) -> &[T]",
        "change_type": "stabilized",
        "source_code": "    #[rustc_const_unstable(feature = \"const_slice_flatten\", issue = \"95629\")]\n    pub const fn as_flattened(&self) -> &[T] {\n        let len = if T::IS_ZST {\n            self.len().checked_mul(N).expect(\"slice len overflow\")\n        } else {\n            // SAFETY: `self.len() * N` cannot overflow because `self` is\n            // already in the address space.\n            unsafe { self.len().unchecked_mul(N) }\n        };\n        // SAFETY: `[T]` is layout-identical to `[T; N]`\n        unsafe { from_raw_parts(self.as_ptr().cast(), len) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "into_flattened",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "alloc::vec",
        "type": "method",
        "signature": "pub fn into_flattened(self) -> Vec<T, A>",
        "change_type": "stabilized",
        "source_code": "    pub fn into_flattened(self) -> Vec<T, A> {\n        let (ptr, len, cap, alloc) = self.into_raw_parts_with_alloc();\n        let (new_len, new_cap) = if T::IS_ZST {\n            (len.checked_mul(N).expect(\"vec len overflow\"), usize::MAX)\n        } else {\n            // SAFETY:\n            // - `cap * N` cannot overflow because the allocation is already in\n            // the address space.\n            // - Each `[T; N]` has `N` valid elements, so there are `len * N`\n            // valid elements in the allocation.\n            unsafe { (len.unchecked_mul(N), cap.unchecked_mul(N)) }\n        };\n        // SAFETY:\n        // - `ptr` was allocated by `self`\n        // - `ptr` is well-aligned because `[T; N]` has the same alignment as `T`.\n        // - `new_cap` refers to the same sized allocation as `cap` because\n        // `new_cap * size_of::<T>()` == `cap * size_of::<[T; N]>()`\n        // - `len` <= `cap`, so `len * N` <= `cap * N`.\n        unsafe { Vec::<T, A>::from_raw_parts_in(ptr.cast(), new_len, new_cap, alloc) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "from_millis",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::time",
        "type": "function",
        "signature": "pub const fn from_millis(millis: u64) -> Duration",
        "change_type": "implicit",
        "source_code": "    #[must_use]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_millis(millis: u64) -> Duration {\n        let secs = millis / MILLIS_PER_SEC;\n        let subsec_millis = (millis % MILLIS_PER_SEC) as u32;\n        // SAFETY: (x % 1_000) * 1_000_000 < 1_000_000_000\n        //         => x % 1_000 < 1_000\n        let subsec_nanos = unsafe { Nanoseconds(subsec_millis * NANOS_PER_MILLI) };\n\n        Duration { secs, nanos: subsec_nanos }\n    }",
        "old_source_code": "    #[must_use]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_millis(millis: u64) -> Duration {\n        Duration::new(millis / MILLIS_PER_SEC, ((millis % MILLIS_PER_SEC) as u32) * NANOS_PER_MILLI)\n    }"
    },
    {
        "name": "from_micros",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::time",
        "type": "function",
        "signature": "pub const fn from_micros(micros: u64) -> Duration",
        "change_type": "implicit",
        "source_code": "    #[must_use]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_micros(micros: u64) -> Duration {\n        let secs = micros / MICROS_PER_SEC;\n        let subsec_micros = (micros % MICROS_PER_SEC) as u32;\n        // SAFETY: (x % 1_000_000) * 1_000 < 1_000_000_000\n        //         => x % 1_000_000 < 1_000_000\n        let subsec_nanos = unsafe { Nanoseconds(subsec_micros * NANOS_PER_MICRO) };\n\n        Duration { secs, nanos: subsec_nanos }\n    }",
        "old_source_code": "    #[must_use]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_micros(micros: u64) -> Duration {\n        Duration::new(micros / MICROS_PER_SEC, ((micros % MICROS_PER_SEC) as u32) * NANOS_PER_MICRO)\n    }"
    },
    {
        "name": "from_secs",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::time",
        "type": "function",
        "signature": "pub const fn from_secs(secs: u64) -> Duration",
        "change_type": "implicit",
        "source_code": "    #[must_use]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_secs(secs: u64) -> Duration {\n        Duration { secs, nanos: Nanoseconds::ZERO }\n    }",
        "old_source_code": "    #[must_use]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_secs(secs: u64) -> Duration {\n        Duration::new(secs, 0)\n    }"
    },
    {
        "name": "unsigned_abs",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn unsigned_abs(self) -> NonZero<$Uint>",
        "change_type": "signature",
        "source_code": "        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unsigned_abs(self) -> NonZero<$Uint> {\n            // SAFETY: absolute value of nonzero cannot yield zero values.\n            unsafe { NonZero::new_unchecked(self.get().unsigned_abs()) }\n        }",
        "old_source_code": "        #[rustc_const_stable(feature = \"const_nonzero_checked_ops\", since = \"1.64.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unsigned_abs(self) -> $Uty {\n            // SAFETY: absolute value of nonzero cannot yield zero values.\n            unsafe { $Uty::new_unchecked(self.get().unsigned_abs()) }\n        }"
    },
    {
        "name": "set_extension",
        "from_version": "1.79.0",
        "to_version": "1.80.0",
        "module": "std::path::{Path, PathBuf}",
        "type": "method",
        "signature": "pub fn set_extension<S: AsRef<OsStr>>(&mut self, extension: S) -> bool",
        "change_type": "implicit",
        "documentation": "Updates [`self.extension`] to `Some(extension)` or to `None` if\n`extension` is empty.\n\nReturns `false` and does nothing if [`self.file_name`] is [`None`],\nreturns `true` and updates the extension otherwise.\n\nIf [`self.extension`] is [`None`], the extension is added; otherwise\nit is replaced.\n\nIf `extension` is the empty string, [`self.extension`] will be [`None`]\nafterwards, not `Some(\"\")`.\n\n# Panics\n\nPanics if the passed extension contains a path separator (see\n[`is_separator`]).\n\n# Caveats\n\nThe new `extension` may contain dots and will be used in its entirety,\nbut only the part after the final dot will be reflected in\n[`self.extension`].\n\nIf the file stem contains internal dots and `extension` is empty, part\nof the old file stem will be considered the new [`self.extension`].\n\nSee the examples below.\n\n[`self.file_name`]: Path::file_name\n[`self.extension`]: Path::extension\n",
        "examples": [
            "",
            "```",
            "use std::path::{Path, PathBuf};",
            "",
            "let mut p = PathBuf::from(\"/feel/the\");",
            "",
            "p.set_extension(\"force\");",
            "assert_eq!(Path::new(\"/feel/the.force\"), p.as_path());",
            "",
            "p.set_extension(\"dark.side\");",
            "assert_eq!(Path::new(\"/feel/the.dark.side\"), p.as_path());",
            "",
            "p.set_extension(\"cookie\");",
            "assert_eq!(Path::new(\"/feel/the.dark.cookie\"), p.as_path());",
            "",
            "p.set_extension(\"\");",
            "assert_eq!(Path::new(\"/feel/the.dark\"), p.as_path());",
            "",
            "p.set_extension(\"\");",
            "assert_eq!(Path::new(\"/feel/the\"), p.as_path());",
            "",
            "p.set_extension(\"\");",
            "assert_eq!(Path::new(\"/feel/the\"), p.as_path());",
            "```"
        ],
        "source_code": "    pub fn set_extension<S: AsRef<OsStr>>(&mut self, extension: S) -> bool {\n        self._set_extension(extension.as_ref())\n    }",
        "old_source_code": "    pub fn set_extension<S: AsRef<OsStr>>(&mut self, extension: S) -> bool {\n        self._set_extension(extension.as_ref())\n    }"
    },
    {
        "name": "abs_diff",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::time",
        "type": "method",
        "signature": "without modifying the original\"]\n    pub const fn abs_diff(self, other: Duration) -> Duration",
        "change_type": "stabilized",
        "source_code": "    #[rustc_const_stable(feature = \"duration_abs_diff\", since = \"1.81.0\")]\n    #[rustc_allow_const_fn_unstable(const_option)]\n    #[must_use = \"this returns the result of the operation, \\\n                  without modifying the original\"]\n    #[inline]\n    pub const fn abs_diff(self, other: Duration) -> Duration {\n        if let Some(res) = self.checked_sub(other) { res } else { other.checked_sub(self).unwrap() }\n    }",
        "old_source_code": ""
    },
    {
        "name": "sort_unstable_by",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub fn sort_unstable_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,",
        "change_type": "implicit",
        "source_code": "    #[inline]\n    pub fn sort_unstable_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n        sort::unstable::sort(self, &mut |a, b| compare(a, b) == Ordering::Less);\n    }",
        "old_source_code": "    #[inline]\n    pub fn sort_unstable_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n        sort::quicksort(self, |a, b| compare(a, b) == Ordering::Less);\n    }"
    },
    {
        "name": "fmt",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::any",
        "type": "method",
        "signature": "impl fmt::Debug for TypeId",
        "change_type": "signature",
        "source_code": "impl fmt::Debug for TypeId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n        write!(f, \"TypeId({:#034x})\", self.as_u128())\n    }\n}",
        "old_source_code": "impl fmt::Debug for dyn Any + Send + Sync {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Any\").finish_non_exhaustive()\n    }\n}"
    },
    {
        "name": "is_sign_negative",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::num::f64",
        "type": "method",
        "signature": "pub const fn is_sign_negative(self) -> bool",
        "change_type": "implicit",
        "source_code": "    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_sign_negative(self) -> bool {\n        // IEEE754 says: isSignMinus(x) is true if and only if x has negative sign. isSignMinus\n        // applies to zeros and NaNs as well.\n        // SAFETY: This is just transmuting to get the sign bit, it's fine.\n        unsafe { mem::transmute::<f64, u64>(self) & Self::SIGN_MASK != 0 }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    #[inline]\n    pub const fn is_sign_negative(self) -> bool {\n        // IEEE754 says: isSignMinus(x) is true if and only if x has negative sign. isSignMinus\n        // applies to zeros and NaNs as well.\n        // SAFETY: This is just transmuting to get the sign bit, it's fine.\n        unsafe { mem::transmute::<f64, u64>(self) & 0x8000_0000_0000_0000 != 0 }\n    }"
    },
    {
        "name": "sort_unstable",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub fn sort_unstable(&mut self)\n    where\n        T: Ord,",
        "change_type": "implicit",
        "source_code": "    #[inline]\n    pub fn sort_unstable(&mut self)\n    where\n        T: Ord,\n    {\n        sort::unstable::sort(self, &mut T::lt);\n    }",
        "old_source_code": "    #[inline]\n    pub fn sort_unstable(&mut self)\n    where\n        T: Ord,\n    {\n        sort::quicksort(self, T::lt);\n    }"
    },
    {
        "name": "sort_unstable_by_key",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub fn sort_unstable_by_key<K, F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> K,\n        K: Ord,",
        "change_type": "implicit",
        "source_code": "    #[inline]\n    pub fn sort_unstable_by_key<K, F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> K,\n        K: Ord,\n    {\n        sort::unstable::sort(self, &mut |a, b| f(a).lt(&f(b)));\n    }",
        "old_source_code": "    #[inline]\n    pub fn sort_unstable_by_key<K, F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> K,\n        K: Ord,\n    {\n        sort::quicksort(self, |a, b| f(a).lt(&f(b)));\n    }"
    },
    {
        "name": "sort",
        "from_version": "1.80.1",
        "to_version": "1.81.0",
        "module": "alloc::slice",
        "type": "method",
        "signature": "pub fn sort(&mut self)\n    where\n        T: Ord,",
        "change_type": "implicit",
        "documentation": "Sorts the slice, preserving initial order of equal elements.\n\nThis sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*))\nworst-case.\n\nIf the implementation of [`Ord`] for `T` does not implement a [total order] the resulting\norder of elements in the slice is unspecified. All original elements will remain in the\nslice and any possible modifications via interior mutability are observed in the input. Same\nis true if the implementation of [`Ord`] for `T` panics.\n\nWhen applicable, unstable sorting is preferred because it is generally faster than stable\nsorting and it doesn't allocate auxiliary memory. See\n[`sort_unstable`](slice::sort_unstable). The exception are partially sorted slices, which\nmay be better served with `slice::sort`.\n\nSorting types that only implement [`PartialOrd`] such as [`f32`] and [`f64`] require\nadditional precautions. For example, `f32::NAN != f32::NAN`, which doesn't fulfill the\nreflexivity requirement of [`Ord`]. By using an alternative comparison function with\n`slice::sort_by` such as [`f32::total_cmp`] or [`f64::total_cmp`] that defines a [total\norder] users can sort slices containing floating-point values. Alternatively, if all values\nin the slice are guaranteed to be in a subset for which [`PartialOrd::partial_cmp`] forms a\n[total order], it's possible to sort the slice with `sort_by(|a, b|\na.partial_cmp(b).unwrap())`.\n\n# Current implementation\n\nThe current implementation is based on [driftsort] by Orson Peters and Lukas Bergdoll, which\ncombines the fast average case of quicksort with the fast worst case and partial run\ndetection of mergesort, achieving linear time on fully sorted and reversed inputs. On inputs\nwith k distinct elements, the expected time to sort the data is *O*(*n* \\* log(*k*)).\n\nThe auxiliary memory allocation behavior depends on the input length. Short slices are\nhandled without allocation, medium sized slices allocate `self.len()` and beyond that it\nclamps at `self.len() / 2`.\n\n# Panics\n\nMay panic if the implementation of [`Ord`] for `T` does not implement a [total order].\n",
        "examples": [
            "",
            "```",
            "let mut v = [4, -5, 1, -3, 2];",
            "",
            "v.sort();",
            "assert_eq!(v, [-5, -3, 1, 2, 4]);",
            "```",
            "",
            "[driftsort]: https://github.com/Voultapher/driftsort",
            "[total order]: https://en.wikipedia.org/wiki/Total_order"
        ],
        "source_code": "    #[inline]\n    pub fn sort(&mut self)\n    where\n        T: Ord,\n    {\n        stable_sort(self, T::lt);\n    }",
        "old_source_code": "    #[inline]\n    pub fn sort(&mut self)\n    where\n        T: Ord,\n    {\n        stable_sort(self, T::lt);\n    }"
    },
    {
        "name": "new_uninit_slice",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "alloc::boxed",
        "type": "function",
        "signature": "pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]>",
        "change_type": "stabilized",
        "source_code": "    #[must_use]\n    pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n        unsafe { RawVec::with_capacity(len).into_box(len) }\n    }",
        "old_source_code": ""
    },
    {
        "name": "Triangle",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::fmt",
        "type": "struct",
        "signature": "Center,\n}\n\npub use self::builders::",
        "change_type": "implicit",
        "source_code": "    Center,\n}\n\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub use self::builders::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n#[unstable(feature = \"debug_closure_helpers\", issue = \"117729\")]\npub use self::builders::{FromFn, from_fn};\n\n/// The type returned by formatter methods.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// #[derive(Debug)]\n/// struct Triangle {",
        "old_source_code": "    Center,\n}\n\n#[unstable(feature = \"debug_closure_helpers\", issue = \"117729\")]\npub use self::builders::{from_fn, FromFn};\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub use self::builders::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n\n/// The type returned by formatter methods.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// #[derive(Debug)]\n/// struct Triangle {"
    },
    {
        "name": "into_raw_socket",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "std::os::windows::io::socket",
        "type": "method",
        "signature": "impl IntoRawSocket for OwnedSocket",
        "change_type": "implicit",
        "source_code": "impl IntoRawSocket for OwnedSocket {\n    #[inline]\n    fn into_raw_socket(self) -> RawSocket {\n        ManuallyDrop::new(self).socket\n    }\n}",
        "old_source_code": "impl IntoRawSocket for OwnedSocket {\n    #[inline]\n    fn into_raw_socket(self) -> RawSocket {\n        let socket = self.socket;\n        forget(self);\n        socket\n    }\n}"
    },
    {
        "name": "classify",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::num::f64",
        "type": "method",
        "signature": "pub const fn classify(self) -> FpCategory",
        "change_type": "implicit",
        "source_code": "    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    pub const fn classify(self) -> FpCategory {\n        // A previous implementation tried to only use bitmask-based checks,\n        // using f64::to_bits to transmute the float to its bit repr and match on that.\n        // If we only cared about being \"technically\" correct, that's an entirely legit\n        // implementation.\n        //\n        // Unfortunately, there is hardware out there that does not correctly implement the IEEE\n        // float semantics Rust relies on: x87 uses a too-large exponent, and some hardware flushes\n        // subnormals to zero. These are platforms bugs, and Rust will misbehave on such hardware,\n        // but we can at least try to make things seem as sane as possible by being careful here.\n        //\n        // FIXME(jubilee): Using x87 operations is never necessary in order to function\n        // on x86 processors for Rust-to-Rust calls, so this issue should not happen.\n        // Code generation should be adjusted to use non-C calling conventions, avoiding this.\n        //\n        // Thus, a value may compare unequal to infinity, despite having a \"full\" exponent mask.\n        // And it may not be NaN, as it can simply be an \"overextended\" finite value.\n        if self.is_nan() {\n            FpCategory::Nan\n        } else {\n            // However, std can't simply compare to zero to check for zero, either,\n            // as correctness requires avoiding equality tests that may be Subnormal == -0.0\n            // because it may be wrong under \"denormals are zero\" and \"flush to zero\" modes.\n            // Most of std's targets don't use those, but they are used for thumbv7neon.\n            // So, this does use bitpattern matching for the rest. On x87, due to the incorrect\n            // float codegen on this hardware, this doesn't actually return a right answer for NaN\n            // because it cannot correctly discern between a floating point NaN, and some normal\n            // floating point numbers truncated from an x87 FPU -- but we took care of NaN above, so\n            // we are fine.\n            let b = self.to_bits();\n            match (b & Self::MAN_MASK, b & Self::EXP_MASK) {\n                (0, Self::EXP_MASK) => FpCategory::Infinite,\n                (0, 0) => FpCategory::Zero,\n                (_, 0) => FpCategory::Subnormal,\n                _ => FpCategory::Normal,\n            }\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_float_classify\", issue = \"72505\")]\n    pub const fn classify(self) -> FpCategory {\n        // A previous implementation tried to only use bitmask-based checks,\n        // using f64::to_bits to transmute the float to its bit repr and match on that.\n        // Unfortunately, floating point numbers can be much worse than that.\n        // This also needs to not result in recursive evaluations of f64::to_bits.\n        //\n        // On some processors, in some cases, LLVM will \"helpfully\" lower floating point ops,\n        // in spite of a request for them using f32 and f64, to things like x87 operations.\n        // These have an f64's mantissa, but can have a larger than normal exponent.\n        // FIXME(jubilee): Using x87 operations is never necessary in order to function\n        // on x86 processors for Rust-to-Rust calls, so this issue should not happen.\n        // Code generation should be adjusted to use non-C calling conventions, avoiding this.\n        //\n        // Thus, a value may compare unequal to infinity, despite having a \"full\" exponent mask.\n        // And it may not be NaN, as it can simply be an \"overextended\" finite value.\n        if self.is_nan() {\n            FpCategory::Nan\n        } else {\n            // However, std can't simply compare to zero to check for zero, either,\n            // as correctness requires avoiding equality tests that may be Subnormal == -0.0\n            // because it may be wrong under \"denormals are zero\" and \"flush to zero\" modes.\n            // Most of std's targets don't use those, but they are used for thumbv7neon.\n            // So, this does use bitpattern matching for the rest.\n\n            // SAFETY: f64 to u64 is fine. Usually.\n            // If control flow has gotten this far, the value is definitely in one of the categories\n            // that f64::partial_classify can correctly analyze.\n            unsafe { f64::partial_classify(self) }\n        }\n    }"
    },
    {
        "name": "from_bits",
        "from_version": "1.81.0",
        "to_version": "1.82.0",
        "module": "core::num::f32",
        "type": "function",
        "signature": "pub const fn from_bits(v: u32) -> Self",
        "change_type": "implicit",
        "source_code": "    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[must_use]\n    #[inline]\n    pub const fn from_bits(v: u32) -> Self {\n        // It turns out the safety issues with sNaN were overblown! Hooray!\n        // SAFETY: `u32` is a plain old datatype so we can always transmute from it.\n        unsafe { mem::transmute(v) }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n    #[must_use]\n    #[inline]\n    pub const fn from_bits(v: u32) -> Self {\n        // It turns out the safety issues with sNaN were overblown! Hooray!\n        // SAFETY: `u32` is a plain old datatype so we can always transmute from it\n        // ...sorta.\n        //\n        // It turns out that at runtime, it is possible for a floating point number\n        // to be subject to floating point modes that alter nonzero subnormal numbers\n        // to zero on reads and writes, aka \"denormals are zero\" and \"flush to zero\".\n        // This is not a problem usually, but at least one tier2 platform for Rust\n        // actually exhibits this behavior by default: thumbv7neon\n        // aka \"the Neon FPU in AArch32 state\"\n        //\n        // In addition, on x86 targets with SSE or SSE2 disabled and the x87 FPU enabled,\n        // i.e. not soft-float, the way Rust does parameter passing can actually alter\n        // a number that is \"not infinity\" to have the same exponent as infinity,\n        // in a slightly unpredictable manner.\n        //\n        // And, of course evaluating to a NaN value is fairly nondeterministic.\n        // More precisely: when NaN should be returned is knowable, but which NaN?\n        // So far that's defined by a combination of LLVM and the CPU, not Rust.\n        // This function, however, allows observing the bitstring of a NaN,\n        // thus introspection on CTFE.\n        //\n        // In order to preserve, at least for the moment, const-to-runtime equivalence,\n        // reject any of these possible situations from happening.\n        #[rustc_const_unstable(feature = \"const_float_bits_conv\", issue = \"72447\")]\n        const fn ct_u32_to_f32(ct: u32) -> f32 {\n            match f32::classify_bits(ct) {\n                FpCategory::Subnormal => {\n                    panic!(\"const-eval error: cannot use f32::from_bits on a subnormal number\")\n                }\n                FpCategory::Nan => {\n                    panic!(\"const-eval error: cannot use f32::from_bits on NaN\")\n                }\n                FpCategory::Infinite | FpCategory::Normal | FpCategory::Zero => {\n                    // SAFETY: It's not a frumious number\n                    unsafe { mem::transmute::<u32, f32>(ct) }\n                }\n            }\n        }\n\n        #[inline(always)] // See https://github.com/rust-lang/compiler-builtins/issues/491\n        fn rt_u32_to_f32(x: u32) -> f32 {\n            // SAFETY: `u32` is a plain old datatype so we can always... uh...\n            // ...look, just pretend you forgot what you just read.\n            // Stability concerns.\n            unsafe { mem::transmute(x) }\n        }\n        intrinsics::const_eval_select((v,), ct_u32_to_f32, rt_u32_to_f32)\n    }"
    },
    {
        "name": "get_or_insert_default",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::option",
        "type": "method",
        "signature": "pub fn get_or_insert_default(&mut self) -> &mut T\n    where\n        T: Default,",
        "change_type": "stabilized",
        "source_code": "    pub fn get_or_insert_default(&mut self) -> &mut T\n    where\n        T: Default,\n    {\n        self.get_or_insert_with(T::default)\n    }",
        "old_source_code": ""
    },
    {
        "name": "make_ascii_uppercase",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub const fn make_ascii_uppercase(&mut self)",
        "change_type": "signature",
        "source_code": "    #[rustc_const_unstable(feature = \"const_make_ascii\", issue = \"130698\")]\n    #[inline]\n    pub const fn make_ascii_uppercase(&mut self) {\n        // SAFETY: changing ASCII letters only does not invalidate UTF-8.\n        let me = unsafe { self.as_bytes_mut() };\n        me.make_ascii_uppercase()\n    }",
        "old_source_code": "    #[inline]\n    pub fn make_ascii_uppercase(&mut self) {\n        // SAFETY: changing ASCII letters only does not invalidate UTF-8.\n        let me = unsafe { self.as_bytes_mut() };\n        me.make_ascii_uppercase()\n    }"
    },
    {
        "name": "swap",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::slice",
        "type": "method",
        "signature": "pub const fn swap(&mut self, a: usize, b: usize)",
        "change_type": "implicit",
        "source_code": "    #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n    #[inline]\n    #[track_caller]\n    pub const fn swap(&mut self, a: usize, b: usize) {\n        // FIXME: use swap_unchecked here (https://github.com/rust-lang/rust/pull/88540#issuecomment-944344343)\n        // Can't take two mutable loans from one vector, so instead use raw pointers.\n        let pa = &raw mut self[a];\n        let pb = &raw mut self[b];\n        // SAFETY: `pa` and `pb` have been created from safe mutable references and refer\n        // to elements in the slice and therefore are guaranteed to be valid and aligned.\n        // Note that accessing the elements behind `a` and `b` is checked and will\n        // panic when out of bounds.\n        unsafe {\n            ptr::swap(pa, pb);\n        }\n    }",
        "old_source_code": "    #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n    #[inline]\n    #[track_caller]\n    pub const fn swap(&mut self, a: usize, b: usize) {\n        // FIXME: use swap_unchecked here (https://github.com/rust-lang/rust/pull/88540#issuecomment-944344343)\n        // Can't take two mutable loans from one vector, so instead use raw pointers.\n        let pa = ptr::addr_of_mut!(self[a]);\n        let pb = ptr::addr_of_mut!(self[b]);\n        // SAFETY: `pa` and `pb` have been created from safe mutable references and refer\n        // to elements in the slice and therefore are guaranteed to be valid and aligned.\n        // Note that accessing the elements behind `a` and `b` is checked and will\n        // panic when out of bounds.\n        unsafe {\n            ptr::swap(pa, pb);\n        }\n    }"
    },
    {
        "name": "alloc_zeroed",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "alloc::alloc",
        "type": "function",
        "signature": "pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8",
        "change_type": "implicit",
        "source_code": "#[must_use = \"losing the pointer will leak memory\"]\n#[inline]\n#[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\npub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n    unsafe {\n        // Make sure we don't accidentally allow omitting the allocator shim in\n        // stable code until it is actually stabilized.\n        core::ptr::read_volatile(&__rust_no_alloc_shim_is_unstable);\n\n        __rust_alloc_zeroed(layout.size(), layout.align())\n    }\n}",
        "old_source_code": "#[must_use = \"losing the pointer will leak memory\"]\n#[inline]\npub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n    unsafe { __rust_alloc_zeroed(layout.size(), layout.align()) }\n}"
    },
    {
        "name": "make_ascii_lowercase",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::slice::ascii",
        "type": "method",
        "signature": "pub const fn make_ascii_lowercase(&mut self)",
        "change_type": "signature",
        "source_code": "    #[rustc_const_unstable(feature = \"const_make_ascii\", issue = \"130698\")]\n    #[inline]\n    pub const fn make_ascii_lowercase(&mut self) {\n        // FIXME(const-hack): We would like to simply iterate using `for` loops but this isn't currently allowed in constant expressions.\n        let mut i = 0;\n        while i < self.len() {\n            let byte = &mut self[i];\n            byte.make_ascii_lowercase();\n            i += 1;\n        }\n    }",
        "old_source_code": "    #[inline]\n    pub fn make_ascii_lowercase(&mut self) {\n        for byte in self {\n            byte.make_ascii_lowercase();\n        }\n    }"
    },
    {
        "name": "make_ascii_lowercase",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::str",
        "type": "method",
        "signature": "pub const fn make_ascii_lowercase(&mut self)",
        "change_type": "signature",
        "source_code": "    #[rustc_const_unstable(feature = \"const_make_ascii\", issue = \"130698\")]\n    #[inline]\n    pub const fn make_ascii_lowercase(&mut self) {\n        // SAFETY: changing ASCII letters only does not invalidate UTF-8.\n        let me = unsafe { self.as_bytes_mut() };\n        me.make_ascii_lowercase()\n    }",
        "old_source_code": "    #[inline]\n    pub fn make_ascii_lowercase(&mut self) {\n        // SAFETY: changing ASCII letters only does not invalidate UTF-8.\n        let me = unsafe { self.as_bytes_mut() };\n        me.make_ascii_lowercase()\n    }"
    },
    {
        "name": "last_write_time",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "std::os::windows::fs",
        "type": "method",
        "signature": "fn last_write_time(&self) -> u64;\n\n    /// Returns the value of the `nFileSize` fields of this\n    /// metadata.\n    ///\n    /// The returned value does not have meaning for directories.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::fs;\n    /// use std::os::windows::prelude::*;\n    ///\n    /// fn main() -> io::Result<()>",
        "change_type": "implicit",
        "source_code": "    fn last_write_time(&self) -> u64;\n\n    /// Returns the value of the `nFileSize` fields of this\n    /// metadata.\n    ///\n    /// The returned value does not have meaning for directories.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::fs;\n    /// use std::os::windows::prelude::*;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///     let file_size = metadata.file_size();\n    ///     Ok(())\n    /// }",
        "old_source_code": "    fn last_write_time(&self) -> u64;\n\n    /// Returns the value of the `nFileSize{High,Low}` fields of this"
    },
    {
        "name": "new",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "alloc::vec",
        "type": "function",
        "signature": "pub const fn new() -> Self",
        "change_type": "implicit",
        "source_code": "    #[must_use]\n    pub const fn new() -> Self {\n        Vec { buf: RawVec::new(), len: 0 }\n    }",
        "old_source_code": "    #[must_use]\n    pub const fn new() -> Self {\n        Vec { buf: RawVec::NEW, len: 0 }\n    }"
    },
    {
        "name": "make_ascii_uppercase",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "core::slice::ascii",
        "type": "method",
        "signature": "pub const fn make_ascii_uppercase(&mut self)",
        "change_type": "signature",
        "source_code": "    #[rustc_const_unstable(feature = \"const_make_ascii\", issue = \"130698\")]\n    #[inline]\n    pub const fn make_ascii_uppercase(&mut self) {\n        // FIXME(const-hack): We would like to simply iterate using `for` loops but this isn't currently allowed in constant expressions.\n        let mut i = 0;\n        while i < self.len() {\n            let byte = &mut self[i];\n            byte.make_ascii_uppercase();\n            i += 1;\n        }\n    }",
        "old_source_code": "    #[inline]\n    pub fn make_ascii_uppercase(&mut self) {\n        for byte in self {\n            byte.make_ascii_uppercase();\n        }\n    }"
    },
    {
        "name": "sort_by",
        "from_version": "1.82.0",
        "to_version": "1.83.0",
        "module": "alloc::slice",
        "type": "method",
        "signature": "pub fn sort_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,",
        "change_type": "implicit",
        "documentation": "Sorts the slice with a comparison function, preserving initial order of equal elements.\n\nThis sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*))\nworst-case.\n\nIf the comparison function `compare` does not implement a [total order], the function may\npanic; even if the function exits normally, the resulting order of elements in the slice is\nunspecified. See also the note on panicking below.\n\nFor example `|a, b| (a - b).cmp(a)` is a comparison function that is neither transitive nor\nreflexive nor total, `a < b < c < a` with `a = 1, b = 2, c = 3`. For more information and\nexamples see the [`Ord`] documentation.\n\n# Current implementation\n\nThe current implementation is based on [driftsort] by Orson Peters and Lukas Bergdoll, which\ncombines the fast average case of quicksort with the fast worst case and partial run\ndetection of mergesort, achieving linear time on fully sorted and reversed inputs. On inputs\nwith k distinct elements, the expected time to sort the data is *O*(*n* \\* log(*k*)).\n\nThe auxiliary memory allocation behavior depends on the input length. Short slices are\nhandled without allocation, medium sized slices allocate `self.len()` and beyond that it\nclamps at `self.len() / 2`.\n\n# Panics\n\nMay panic if `compare` does not implement a [total order], or if `compare` itself panics.\n\nAll safe functions on slices preserve the invariant that even if the function panics, all\noriginal elements will remain in the slice and any possible modifications via interior\nmutability are observed in the input. This ensures that recovery code (for instance inside\nof a `Drop` or following a `catch_unwind`) will still have access to all the original\nelements. For instance, if the slice belongs to a `Vec`, the `Vec::drop` method will be able\nto dispose of all contained elements.\n",
        "examples": [
            "",
            "```",
            "let mut v = [4, -5, 1, -3, 2];",
            "v.sort_by(|a, b| a.cmp(b));",
            "assert_eq!(v, [-5, -3, 1, 2, 4]);",
            "",
            "// reverse sorting",
            "v.sort_by(|a, b| b.cmp(a));",
            "assert_eq!(v, [4, 2, 1, -3, -5]);",
            "```",
            "",
            "[driftsort]: https://github.com/Voultapher/driftsort",
            "[total order]: https://en.wikipedia.org/wiki/Total_order"
        ],
        "source_code": "    #[inline]\n    pub fn sort_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n        stable_sort(self, |a, b| compare(a, b) == Less);\n    }",
        "old_source_code": "    #[inline]\n    pub fn sort_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n        stable_sort(self, |a, b| compare(a, b) == Less);\n    }"
    },
    {
        "name": "isqrt",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::num::nonzero",
        "type": "method",
        "signature": "without modifying the original\"]\n        pub const fn isqrt(self) -> Self",
        "change_type": "stabilized",
        "source_code": "        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = self.get().isqrt();\n\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never cause\n            // the output to decrease. Thus, since the input for nonzero\n            // unsigned integers has a lower bound of 1, the lower bound of the\n            // results will be sqrt(1), which is 1, so a result can't be zero.\n            unsafe { Self::new_unchecked(result) }\n        }",
        "old_source_code": ""
    },
    {
        "name": "get_mut",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "std::io::cursor",
        "type": "method",
        "signature": "pub const fn get_mut(&mut self) -> &mut T",
        "change_type": "signature",
        "source_code": "    #[rustc_const_unstable(feature = \"const_mut_cursor\", issue = \"130801\")]\n    pub const fn get_mut(&mut self) -> &mut T {\n        &mut self.inner\n    }",
        "old_source_code": "    pub fn get_mut(&mut self) -> &mut T {\n        &mut self.inner\n    }"
    },
    {
        "name": "park_timeout",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "std::thread",
        "type": "function",
        "signature": "pub fn park_timeout(dur: Duration)",
        "change_type": "implicit",
        "source_code": "pub fn park_timeout(dur: Duration) {\n    let guard = PanicGuard;\n    // SAFETY: park_timeout is called on the parker owned by this thread.\n    unsafe {\n        current().0.parker().park_timeout(dur);\n    }\n    // No panic occurred, do not abort.\n    forget(guard);\n}",
        "old_source_code": "pub fn park_timeout(dur: Duration) {\n    let guard = PanicGuard;\n    // SAFETY: park_timeout is called on the parker owned by this thread.\n    unsafe {\n        current().inner.as_ref().parker().park_timeout(dur);\n    }\n    // No panic occurred, do not abort.\n    forget(guard);\n}"
    },
    {
        "name": "set_ip",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::net::socket_addr",
        "type": "method",
        "signature": "pub const fn set_ip(&mut self, new_ip: Ipv6Addr)",
        "change_type": "signature",
        "source_code": "    #[rustc_const_unstable(feature = \"const_sockaddr_setters\", issue = \"131714\")]\n    pub const fn set_ip(&mut self, new_ip: Ipv6Addr) {\n        self.ip = new_ip;\n    }",
        "old_source_code": "    #[inline]\n    pub fn set_ip(&mut self, new_ip: Ipv6Addr) {\n        self.ip = new_ip;\n    }"
    },
    {
        "name": "id",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "std::thread",
        "type": "method",
        "signature": "pub fn id(&self) -> ThreadId",
        "change_type": "implicit",
        "source_code": "    #[must_use]\n    pub fn id(&self) -> ThreadId {\n        self.0.id()\n    }",
        "old_source_code": "    #[must_use]\n    pub fn id(&self) -> ThreadId {\n        self.inner.id\n    }"
    },
    {
        "name": "set_port",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "core::net::socket_addr",
        "type": "method",
        "signature": "pub const fn set_port(&mut self, new_port: u16)",
        "change_type": "signature",
        "source_code": "    #[rustc_const_unstable(feature = \"const_sockaddr_setters\", issue = \"131714\")]\n    pub const fn set_port(&mut self, new_port: u16) {\n        self.port = new_port;\n    }",
        "old_source_code": "    #[inline]\n    pub fn set_port(&mut self, new_port: u16) {\n        self.port = new_port;\n    }"
    },
    {
        "name": "get",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "alloc::collections::btree::set",
        "type": "method",
        "signature": "pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n    where\n        T: Borrow<Q> + Ord,\n        Q: Ord,",
        "change_type": "implicit",
        "source_code": "    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n    where\n        T: Borrow<Q> + Ord,\n        Q: Ord,\n    {\n        self.map.get_key_value(value).map(|(k, _)| k)\n    }",
        "old_source_code": "    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n    where\n        T: Borrow<Q> + Ord,\n        Q: Ord,\n    {\n        Recover::get(&self.map, value)\n    }"
    },
    {
        "name": "replace",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "alloc::collections::btree::set",
        "type": "method",
        "signature": "pub fn replace(&mut self, value: T) -> Option<T>\n    where\n        T: Ord,",
        "change_type": "implicit",
        "source_code": "    #[rustc_confusables(\"swap\")]\n    pub fn replace(&mut self, value: T) -> Option<T>\n    where\n        T: Ord,\n    {\n        self.map.replace(value)\n    }",
        "old_source_code": "    #[rustc_confusables(\"swap\")]\n    pub fn replace(&mut self, value: T) -> Option<T>\n    where\n        T: Ord,\n    {\n        Recover::replace(&mut self.map, value)\n    }"
    },
    {
        "name": "new",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "std::hash::random",
        "type": "function",
        "signature": "pub fn new() -> DefaultHasher",
        "change_type": "signature",
        "source_code": "    #[inline]\n    #[allow(deprecated)]\n    #[must_use]\n    pub fn new() -> DefaultHasher {\n        DefaultHasher(SipHasher13::new_with_keys(0, 0))\n    }",
        "old_source_code": "    #[inline]\n    #[allow(deprecated)]\n    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n    #[must_use]\n    pub const fn new() -> DefaultHasher {\n        DefaultHasher(SipHasher13::new_with_keys(0, 0))\n    }"
    },
    {
        "name": "set_position",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "std::io::cursor",
        "type": "method",
        "signature": "pub const fn set_position(&mut self, pos: u64)",
        "change_type": "signature",
        "source_code": "    #[rustc_const_unstable(feature = \"const_mut_cursor\", issue = \"130801\")]\n    pub const fn set_position(&mut self, pos: u64) {\n        self.pos = pos;\n    }",
        "old_source_code": "    pub fn set_position(&mut self, pos: u64) {\n        self.pos = pos;\n    }"
    },
    {
        "name": "take",
        "from_version": "1.83.0",
        "to_version": "1.84.0",
        "module": "alloc::collections::btree::set",
        "type": "method",
        "signature": "pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n    where\n        T: Borrow<Q> + Ord,\n        Q: Ord,",
        "change_type": "implicit",
        "source_code": "    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n    where\n        T: Borrow<Q> + Ord,\n        Q: Ord,\n    {\n        self.map.remove_entry(value).map(|(k, _)| k)\n    }",
        "old_source_code": "    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n    where\n        T: Borrow<Q> + Ord,\n        Q: Ord,\n    {\n        Recover::take(&mut self.map, value)\n    }"
    },
    {
        "crate": "bitflags",
        "name": "Flag",
        "from_version": "2.3.3",
        "to_version": "2.4.0",
        "module": "traits",
        "type": "struct",
        "signature": "struct Flag",
        "documentation": "Metadata for an individual flag.",
        "change_type": "deprecated",
        "changenote": "API removed in version 2.4.0.",
        "old_source_code": "pub struct Flag<B> {\n    name: &'static str,\n    value: B,\n}"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_ETHERNET",
        "from_version": "0.2.146",
        "to_version": "0.2.147",
        "module": "unix::linux_like",
        "type": "constant",
        "signature": "const IPPROTO_ETHERNET: ::c_int  = 143",
        "documentation": "Ethernet-within-IPv6 encapsulation.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.147.",
        "source_code": "pub const IPPROTO_ETHERNET: ::c_int = 143;"
    },
    {
        "crate": "rand_core",
        "name": "read_u32_into",
        "from_version": "0.6.1",
        "to_version": "0.6.2",
        "module": "le",
        "type": "function",
        "signature": "fn read_u32_into(src: &[u8], dst: &mut [u32])",
        "documentation": "Reads unsigned 32 bit integers from `src` into `dst`.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn read_u32_into(src: &[u8], dst: &mut [u32]) {\n    assert!(4 * src.len() >= dst.len());\n    for (out, chunk) in dst.iter_mut().zip(src.chunks_exact(4)) {\n        *out = u32::from_le_bytes(chunk.try_into().unwrap());\n    }",
        "source_code": "pub fn read_u32_into(src: &[u8], dst: &mut [u32]) {\n    assert!(src.len() >= 4 * dst.len());\n    for (out, chunk) in dst.iter_mut().zip(src.chunks_exact(4)) {\n        *out = u32::from_le_bytes(chunk.try_into().unwrap());\n    }"
    },
    {
        "crate": "rand_core",
        "name": "read_u64_into",
        "from_version": "0.6.1",
        "to_version": "0.6.2",
        "module": "le",
        "type": "function",
        "signature": "fn read_u64_into(src: &[u8], dst: &mut [u64])",
        "documentation": "Reads unsigned 64 bit integers from `src` into `dst`.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn read_u64_into(src: &[u8], dst: &mut [u64]) {\n    assert!(8 * src.len() >= dst.len());\n    for (out, chunk) in dst.iter_mut().zip(src.chunks_exact(8)) {\n        *out = u64::from_le_bytes(chunk.try_into().unwrap());\n    }",
        "source_code": "pub fn read_u64_into(src: &[u8], dst: &mut [u64]) {\n    assert!(src.len() >= 8 * dst.len());\n    for (out, chunk) in dst.iter_mut().zip(src.chunks_exact(8)) {\n        *out = u64::from_le_bytes(chunk.try_into().unwrap());\n    }"
    },
    {
        "crate": "rand_core",
        "name": "fill_via_u64_chunks",
        "from_version": "0.6.3",
        "to_version": "0.6.4",
        "module": "impls",
        "type": "function",
        "signature": "fn fill_via_u64_chunks(src: &[u64], dest: &mut [u8]) -> (usize, usize)",
        "documentation": "Implement `fill_bytes` by reading chunks from the output buffer of a block\nbased RNG.\n\nThe return values are `(consumed_u64, filled_u8)`.\n`filled_u8` is the number of filled bytes in `dest`, which may be less than\nthe length of `dest`.\n`consumed_u64` is the number of words consumed from `src`, which is the same\nas `filled_u8 / 8` rounded up.\n\nSee `fill_via_u32_chunks` for an example.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn fill_via_u64_chunks(src: &[u64], dest: &mut [u8]) -> (usize, usize) {\n    fill_via_chunks!(src, dest, u64)\n}",
        "source_code": "pub fn fill_via_u64_chunks(src: &[u64], dest: &mut [u8]) -> (usize, usize) {\n    fill_via_chunks(src, dest)\n}"
    },
    {
        "crate": "rand_core",
        "name": "fill_via_u32_chunks",
        "from_version": "0.6.3",
        "to_version": "0.6.4",
        "module": "impls",
        "type": "function",
        "signature": "fn fill_via_u32_chunks(src: &[u32], dest: &mut [u8]) -> (usize, usize)",
        "documentation": "Implement `fill_bytes` by reading chunks from the output buffer of a block\nbased RNG.\n\nThe return values are `(consumed_u32, filled_u8)`.\n\n`filled_u8` is the number of filled bytes in `dest`, which may be less than\nthe length of `dest`.\n`consumed_u32` is the number of words consumed from `src`, which is the same\nas `filled_u8 / 4` rounded up.\n\n# Example\n(from `IsaacRng`)\n\n```ignore\nfn fill_bytes(&mut self, dest: &mut [u8]) {\n    let mut read_len = 0;\n    while read_len < dest.len() {\n        if self.index >= self.rsl.len() {\n            self.isaac();\n        }\n\n        let (consumed_u32, filled_u8) =\n            impls::fill_via_u32_chunks(&mut self.rsl[self.index..],\n                                       &mut dest[read_len..]);\n\n        self.index += consumed_u32;\n        read_len += filled_u8;\n    }\n}\n```",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn fill_via_u32_chunks(src: &[u32], dest: &mut [u8]) -> (usize, usize) {\n    fill_via_chunks!(src, dest, u32)\n}",
        "source_code": "pub fn fill_via_u32_chunks(src: &[u32], dest: &mut [u8]) -> (usize, usize) {\n    fill_via_chunks(src, dest)\n}"
    },
    {
        "crate": "rand",
        "name": "Distribution",
        "from_version": "0.8.3",
        "to_version": "0.8.4",
        "module": "distributions::distribution",
        "type": "trait",
        "signature": "trait Distribution",
        "documentation": "Types (distributions) that can be used to create a random instance of `T`.\n\nIt is possible to sample from a distribution through both the\n`Distribution` and [`Rng`] traits, via `distr.sample(&mut rng)` and\n`rng.sample(distr)`. They also both offer the [`sample_iter`] method, which\nproduces an iterator that samples from the distribution.\n\nAll implementations are expected to be immutable; this has the significant\nadvantage of not needing to consider thread safety, and for most\ndistributions efficient state-less sampling algorithms are available.\n\nImplementations are typically expected to be portable with reproducible\nresults when used with a PRNG with fixed seed; see the\n[portability chapter](https://rust-random.github.io/book/portability.html)\nof The Rust Rand Book. In some cases this does not apply, e.g. the `usize`\ntype requires different sampling on 32-bit and 64-bit machines.\n\n[`sample_iter`]: Distribution::sample_iter",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.8.4.",
        "source_code": "pub trait Distribution<T> {\n    /// Generate a random value of `T`, using `rng` as the source of randomness.\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> T;\n\n    /// Create an iterator that generates random values of `T`, using `rng` as\n    /// the source of randomness.\n    ///\n    /// Note that this function takes `self` by value. This works since\n    /// `Distribution<T>` is impl'd for `&D` where `D: Distribution<T>`,\n    /// however borrowing is not automatic hence `distr.sample_iter(...)` may\n    /// need to be replaced with `(&distr).sample_iter(...)` to borrow or\n    /// `(&*distr).sample_iter(...)` to reborrow an existing reference.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::thread_rng;\n    /// use rand::distributions::{Distribution, Alphanumeric, Uniform, Standard}"
    },
    {
        "crate": "log",
        "name": "Key",
        "from_version": "0.4.17",
        "to_version": "0.4.18",
        "module": "kv::key",
        "type": "struct",
        "signature": "struct Key",
        "documentation": "A key in a structured key-value pair.",
        "change_type": "deprecated",
        "changenote": "API removed in version 0.4.18.",
        "old_source_code": "pub struct Key<'k> {\n    key: &'k str,\n}"
    },
    {
        "crate": "time",
        "name": "Iso8601",
        "from_version": "0.3.27",
        "to_version": "0.3.28",
        "module": "format_description::well_known::iso8601",
        "type": "struct",
        "signature": "struct Iso8601",
        "documentation": "# use time::format_description::well_known::Iso8601;\n# use time_macros::datetime;\nassert_eq!(\n    datetime!(1997-11-12 9:55:06 -6:00).format(&Iso8601::DEFAULT)?,\n    \"1997-11-12T09:55:06.000000000-06:00\"\n);\n# Ok::<_, time::Error>(())\n```",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.3.28.",
        "source_code": "pub struct Iso8601<const CONFIG: EncodedConfig = { Config::DEFAULT.encode() }>;"
    },
    {
        "crate": "time",
        "name": "ParseFromDescription",
        "from_version": "0.3.27",
        "to_version": "0.3.28",
        "module": "error::parse_from_description",
        "type": "enum",
        "signature": "enum ParseFromDescription",
        "documentation": "An error that occurred while parsing the input into a [`Parsed`](crate::parsing::Parsed) struct.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub enum ParseFromDescription {\n    /// A string literal was not what was expected.\n    #[non_exhaustive]\n    InvalidLiteral,\n    /// A dynamic component was not valid.\n    InvalidComponent(&'static str),\n}",
        "source_code": "pub enum ParseFromDescription {\n    /// A string literal was not what was expected.\n    #[non_exhaustive]\n    InvalidLiteral,\n    /// A dynamic component was not valid.\n    InvalidComponent(&'static str),\n    #[non_exhaustive]\n    UnexpectedTrailingCharacters,\n}"
    },
    {
        "crate": "time",
        "name": "Component",
        "from_version": "0.3.27",
        "to_version": "0.3.28",
        "module": "format_description::component",
        "type": "enum",
        "signature": "enum Component",
        "documentation": "A component of a larger format description.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub enum Component {\n    /// Day of the month.\n    Day(modifier::Day),\n    /// Month of the year.\n    Month(modifier::Month),\n    /// Ordinal day of the year.\n    Ordinal(modifier::Ordinal),\n    /// Day of the week.\n    Weekday(modifier::Weekday),\n    /// Week within the year.\n    WeekNumber(modifier::WeekNumber),\n    /// Year of the date.\n    Year(modifier::Year),\n    /// Hour of the day.\n    Hour(modifier::Hour),\n    /// Minute within the hour.\n    Minute(modifier::Minute),\n    /// AM/PM part of the time.\n    Period(modifier::Period),\n    /// Second within the minute.\n    Second(modifier::Second),\n    /// Subsecond within the second.\n    Subsecond(modifier::Subsecond),\n    /// Hour of the UTC offset.\n    OffsetHour(modifier::OffsetHour),\n    /// Minute within the hour of the UTC offset.\n    OffsetMinute(modifier::OffsetMinute),\n    /// Second within the minute of the UTC offset.\n    OffsetSecond(modifier::OffsetSecond),\n    /// A number of bytes to ignore when parsing. This has no effect on formatting.\n    Ignore(modifier::Ignore),\n    /// A Unix timestamp.\n    UnixTimestamp(modifier::UnixTimestamp),\n}",
        "source_code": "pub enum Component {\n    /// Day of the month.\n    Day(modifier::Day),\n    /// Month of the year.\n    Month(modifier::Month),\n    /// Ordinal day of the year.\n    Ordinal(modifier::Ordinal),\n    /// Day of the week.\n    Weekday(modifier::Weekday),\n    /// Week within the year.\n    WeekNumber(modifier::WeekNumber),\n    /// Year of the date.\n    Year(modifier::Year),\n    /// Hour of the day.\n    Hour(modifier::Hour),\n    /// Minute within the hour.\n    Minute(modifier::Minute),\n    /// AM/PM part of the time.\n    Period(modifier::Period),\n    /// Second within the minute.\n    Second(modifier::Second),\n    /// Subsecond within the second.\n    Subsecond(modifier::Subsecond),\n    /// Hour of the UTC offset.\n    OffsetHour(modifier::OffsetHour),\n    /// Minute within the hour of the UTC offset.\n    OffsetMinute(modifier::OffsetMinute),\n    /// Second within the minute of the UTC offset.\n    OffsetSecond(modifier::OffsetSecond),\n    /// A number of bytes to ignore when parsing. This has no effect on formatting.\n    Ignore(modifier::Ignore),\n    /// A Unix timestamp.\n    UnixTimestamp(modifier::UnixTimestamp),\n    /// The end of input. Parsing this component will fail if there is any input remaining. This\n    /// component neither affects formatting nor consumes any input when parsing.\n    End(modifier::End),\n}"
    },
    {
        "crate": "time",
        "name": "Parse",
        "from_version": "0.3.27",
        "to_version": "0.3.28",
        "module": "error::parse",
        "type": "enum",
        "signature": "enum Parse",
        "documentation": "An error that occurred at some stage of parsing.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub enum Parse {\n    #[allow(clippy::missing_docs_in_private_items)]\n    TryFromParsed(TryFromParsed),\n    #[allow(clippy::missing_docs_in_private_items)]\n    ParseFromDescription(ParseFromDescription),\n    /// The input should have ended, but there were characters remaining.\n    #[non_exhaustive]\n    UnexpectedTrailingCharacters,\n}",
        "source_code": "pub enum Parse {\n    #[allow(clippy::missing_docs_in_private_items)]\n    TryFromParsed(TryFromParsed),\n    #[allow(clippy::missing_docs_in_private_items)]\n    ParseFromDescription(ParseFromDescription),\n    /// The input should have ended, but there were characters remaining.\n    #[non_exhaustive]\n    #[deprecated(\n        since = \"0.3.28\",\n        note = \"no longer output. moved to the `ParseFromDescription` variant\"\n    )]\n    UnexpectedTrailingCharacters,\n}"
    },
    {
        "crate": "time",
        "name": "Month",
        "from_version": "0.3.28",
        "to_version": "0.3.29",
        "module": "month",
        "type": "enum",
        "signature": "enum Month",
        "documentation": "Months of the year.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.3.29.",
        "source_code": "pub enum Month {\n    #[allow(missing_docs)]\n    January = 1,\n    #[allow(missing_docs)]\n    February = 2,\n    #[allow(missing_docs)]\n    March = 3,\n    #[allow(missing_docs)]\n    April = 4,\n    #[allow(missing_docs)]\n    May = 5,\n    #[allow(missing_docs)]\n    June = 6,\n    #[allow(missing_docs)]\n    July = 7,\n    #[allow(missing_docs)]\n    August = 8,\n    #[allow(missing_docs)]\n    September = 9,\n    #[allow(missing_docs)]\n    October = 10,\n    #[allow(missing_docs)]\n    November = 11,\n    #[allow(missing_docs)]\n    December = 12,\n}"
    },
    {
        "crate": "time",
        "name": "ParseFromDescription",
        "from_version": "0.3.28",
        "to_version": "0.3.29",
        "module": "error::parse_from_description",
        "type": "enum",
        "signature": "enum ParseFromDescription",
        "documentation": "An error that occurred while parsing the input into a [`Parsed`](crate::parsing::Parsed) struct.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub enum ParseFromDescription {\n    /// A string literal was not what was expected.\n    #[non_exhaustive]\n    InvalidLiteral,\n    /// A dynamic component was not valid.\n    InvalidComponent(&'static str),\n    #[non_exhaustive]\n    UnexpectedTrailingCharacters,\n}",
        "source_code": "pub enum ParseFromDescription {\n    /// A string literal was not what was expected.\n    #[non_exhaustive]\n    InvalidLiteral,\n    /// A dynamic component was not valid.\n    InvalidComponent(&'static str),\n    /// The input was expected to have ended, but there are characters that remain.\n    #[non_exhaustive]\n    UnexpectedTrailingCharacters,\n}"
    },
    {
        "crate": "time",
        "name": "TimePrecision",
        "from_version": "0.3.28",
        "to_version": "0.3.29",
        "module": "format_description::well_known::iso8601",
        "type": "enum",
        "signature": "enum TimePrecision",
        "documentation": "The precision and number of decimal digits present for the time.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub enum TimePrecision {\n    /// Format the hour only. Minutes, seconds, and nanoseconds will be represented with the\n    /// specified number of decimal digits, if any.\n    Hour {\n        #[allow(clippy::missing_docs_in_private_items)]\n        decimal_digits: Option<NonZeroU8>,\n    }",
        "source_code": "pub enum TimePrecision {\n    /// Format the hour only. Minutes, seconds, and nanoseconds will be represented with the\n    /// specified number of decimal digits, if any.\n    Hour {\n        #[allow(missing_docs)]\n        decimal_digits: Option<NonZeroU8>,\n    }"
    },
    {
        "crate": "time",
        "name": "Date",
        "from_version": "0.3.28",
        "to_version": "0.3.29",
        "module": "date",
        "type": "struct",
        "signature": "struct Date",
        "documentation": "Date in the proleptic Gregorian calendar.\n\nBy default, years between 9999 inclusive are representable. This can be expanded to 999,999\ninclusive by enabling the `large-dates` crate feature. Doing so has performance implications\nand introduces some ambiguities when parsing.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub struct Date {\n    /// Bitpacked field containing both the year and ordinal.\n    // |     xx     | xxxxxxxxxxxxxxxxxxxxx | xxxxxxxxx |\n    // |   2 bits   |        21 bits        |  9 bits   |\n    // | unassigned |         year          |  ordinal  |\n    // The year is 15 bits when `large-dates` is not enabled.\n    value: i32,\n}",
        "source_code": "pub struct Date {\n    /// Bitpacked field containing both the year and ordinal.\n    // |     xx     | xxxxxxxxxxxxxxxxxxxxx | xxxxxxxxx |\n    // |   2 bits   |        21 bits        |  9 bits   |\n    // | unassigned |         year          |  ordinal  |\n    // The year is 15 bits when `large-dates` is not enabled.\n    value: NonZeroI32,\n}"
    },
    {
        "crate": "time",
        "name": "Weekday",
        "from_version": "0.3.28",
        "to_version": "0.3.29",
        "module": "weekday",
        "type": "enum",
        "signature": "enum Weekday",
        "documentation": "Days of the week.\n\nAs order is dependent on context (Sunday could be either two days after or five days before\nFriday), this type does not implement `PartialOrd` or `Ord`.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub enum Weekday {\n    #[allow(clippy::missing_docs_in_private_items)]\n    Monday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Tuesday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Wednesday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Thursday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Friday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Saturday,\n    #[allow(clippy::missing_docs_in_private_items)]\n    Sunday,\n}",
        "source_code": "pub enum Weekday {\n    #[allow(missing_docs)]\n    Monday,\n    #[allow(missing_docs)]\n    Tuesday,\n    #[allow(missing_docs)]\n    Wednesday,\n    #[allow(missing_docs)]\n    Thursday,\n    #[allow(missing_docs)]\n    Friday,\n    #[allow(missing_docs)]\n    Saturday,\n    #[allow(missing_docs)]\n    Sunday,\n}"
    },
    {
        "crate": "time",
        "name": "Parse",
        "from_version": "0.3.28",
        "to_version": "0.3.29",
        "module": "error::parse",
        "type": "enum",
        "signature": "enum Parse",
        "documentation": "An error that occurred at some stage of parsing.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub enum Parse {\n    #[allow(clippy::missing_docs_in_private_items)]\n    TryFromParsed(TryFromParsed),\n    #[allow(clippy::missing_docs_in_private_items)]\n    ParseFromDescription(ParseFromDescription),\n    /// The input should have ended, but there were characters remaining.\n    #[non_exhaustive]\n    #[deprecated(\n        since = \"0.3.28\",\n        note = \"no longer output. moved to the `ParseFromDescription` variant\"\n    )]\n    UnexpectedTrailingCharacters,\n}",
        "source_code": "pub enum Parse {\n    #[allow(missing_docs)]\n    TryFromParsed(TryFromParsed),\n    #[allow(missing_docs)]\n    ParseFromDescription(ParseFromDescription),\n    /// The input should have ended, but there were characters remaining.\n    #[non_exhaustive]\n    #[deprecated(\n        since = \"0.3.28\",\n        note = \"no longer output. moved to the `ParseFromDescription` variant\"\n    )]\n    UnexpectedTrailingCharacters,\n}"
    },
    {
        "crate": "tokio",
        "name": "RuntimeFlavor",
        "from_version": "1.29.1",
        "to_version": "1.30.0",
        "module": "runtime::runtime",
        "type": "enum",
        "signature": "enum RuntimeFlavor",
        "documentation": "The flavor of a `Runtime`.\n\nThis is the return type for [`Handle::runtime_flavor`](crate::runtime::Handle::runtime_flavor()).",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub enum RuntimeFlavor {\n    /// The flavor that executes all tasks on the current thread.\n    CurrentThread,\n    /// The flavor that executes tasks across multiple threads.\n    MultiThread,\n}",
        "source_code": "pub enum RuntimeFlavor {\n    /// The flavor that executes all tasks on the current thread.\n    CurrentThread,\n    /// The flavor that executes tasks across multiple threads.\n    MultiThread,\n    /// The flavor that executes tasks across multiple threads.\n    #[cfg(tokio_unstable)]\n    MultiThreadAlt,\n}"
    },
    {
        "crate": "tokio",
        "name": "Builder",
        "from_version": "1.29.1",
        "to_version": "1.30.0",
        "module": "runtime::builder",
        "type": "struct",
        "signature": "struct Builder",
        "documentation": "Builds Tokio Runtime with custom configuration values.\n\nMethods can be chained in order to set the configuration values. The\nRuntime is constructed by calling [`build`].\n\nNew instances of `Builder` are obtained via [`Builder::new_multi_thread`]\nor [`Builder::new_current_thread`].\n\nSee function level documentation for details on the various configuration\nsettings.\n\n[`build`]: method@Self::build\n[`Builder::new_multi_thread`]: method@Self::new_multi_thread\n[`Builder::new_current_thread`]: method@Self::new_current_thread\n\n# Examples\n\n```\nuse tokio::runtime::Builder;\n\nfn main() {\n    // build runtime\n    let runtime = Builder::new_multi_thread()\n        .worker_threads(4)\n        .thread_name(\"my-custom-name\")\n        .thread_stack_size(3 * 1024 * 1024)\n        .build()\n        .unwrap();\n\n    // use runtime ...\n}\n```",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub struct Builder {\n    /// Runtime type\n    kind: Kind,\n\n    /// Whether or not to enable the I/O driver\n    enable_io: bool,\n    nevents: usize,\n\n    /// Whether or not to enable the time driver\n    enable_time: bool,\n\n    /// Whether or not the clock should start paused.\n    start_paused: bool,\n\n    /// The number of worker threads, used by Runtime.\n    ///\n    /// Only used when not using the current-thread executor.\n    worker_threads: Option<usize>,\n\n    /// Cap on thread usage.\n    max_blocking_threads: usize,\n\n    /// Name fn used for threads spawned by the runtime.\n    pub(super) thread_name: ThreadNameFn,\n\n    /// Stack size used for threads spawned by the runtime.\n    pub(super) thread_stack_size: Option<usize>,\n\n    /// Callback to run after each thread starts.\n    pub(super) after_start: Option<Callback>,\n\n    /// To run before each worker thread stops\n    pub(super) before_stop: Option<Callback>,\n\n    /// To run before each worker thread is parked.\n    pub(super) before_park: Option<Callback>,\n\n    /// To run after each thread is unparked.\n    pub(super) after_unpark: Option<Callback>,\n\n    /// Customizable keep alive timeout for BlockingPool\n    pub(super) keep_alive: Option<Duration>,\n\n    /// How many ticks before pulling a task from the global/remote queue?\n    ///\n    /// When `None`, the value is unspecified and behavior details are left to\n    /// the scheduler. Each scheduler flavor could choose to either pick its own\n    /// default value or use some other strategy to decide when to poll from the\n    /// global queue. For example, the multi-threaded scheduler uses a\n    /// self-tuning strategy based on mean task poll times.\n    pub(super) global_queue_interval: Option<u32>,\n\n    /// How many ticks before yielding to the driver for timer and I/O events?\n    pub(super) event_interval: u32,\n\n    /// When true, the multi-threade scheduler LIFO slot should not be used.\n    ///\n    /// This option should only be exposed as unstable.\n    pub(super) disable_lifo_slot: bool,\n\n    /// Specify a random number generator seed to provide deterministic results\n    pub(super) seed_generator: RngSeedGenerator,\n\n    /// When true, enables task poll count histogram instrumentation.\n    pub(super) metrics_poll_count_histogram_enable: bool,\n\n    /// Configures the task poll count histogram\n    pub(super) metrics_poll_count_histogram: HistogramBuilder,\n\n    #[cfg(tokio_unstable)]\n    pub(super) unhandled_panic: UnhandledPanic,\n}",
        "source_code": "pub struct Builder {\n    /// Runtime type\n    kind: Kind,\n\n    /// Whether or not to enable the I/O driver\n    enable_io: bool,\n    nevents: usize,\n\n    /// Whether or not to enable the time driver\n    enable_time: bool,\n\n    /// Whether or not the clock should start paused.\n    start_paused: bool,\n\n    /// The number of worker threads, used by Runtime.\n    ///\n    /// Only used when not using the current-thread executor.\n    worker_threads: Option<usize>,\n\n    /// Cap on thread usage.\n    max_blocking_threads: usize,\n\n    /// Name fn used for threads spawned by the runtime.\n    pub(super) thread_name: ThreadNameFn,\n\n    /// Stack size used for threads spawned by the runtime.\n    pub(super) thread_stack_size: Option<usize>,\n\n    /// Callback to run after each thread starts.\n    pub(super) after_start: Option<Callback>,\n\n    /// To run before each worker thread stops\n    pub(super) before_stop: Option<Callback>,\n\n    /// To run before each worker thread is parked.\n    pub(super) before_park: Option<Callback>,\n\n    /// To run after each thread is unparked.\n    pub(super) after_unpark: Option<Callback>,\n\n    /// Customizable keep alive timeout for BlockingPool\n    pub(super) keep_alive: Option<Duration>,\n\n    /// How many ticks before pulling a task from the global/remote queue?\n    ///\n    /// When `None`, the value is unspecified and behavior details are left to\n    /// the scheduler. Each scheduler flavor could choose to either pick its own\n    /// default value or use some other strategy to decide when to poll from the\n    /// global queue. For example, the multi-threaded scheduler uses a\n    /// self-tuning strategy based on mean task poll times.\n    pub(super) global_queue_interval: Option<u32>,\n\n    /// How many ticks before yielding to the driver for timer and I/O events?\n    pub(super) event_interval: u32,\n\n    pub(super) local_queue_capacity: usize,\n\n    /// When true, the multi-threade scheduler LIFO slot should not be used.\n    ///\n    /// This option should only be exposed as unstable.\n    pub(super) disable_lifo_slot: bool,\n\n    /// Specify a random number generator seed to provide deterministic results\n    pub(super) seed_generator: RngSeedGenerator,\n\n    /// When true, enables task poll count histogram instrumentation.\n    pub(super) metrics_poll_count_histogram_enable: bool,\n\n    /// Configures the task poll count histogram\n    pub(super) metrics_poll_count_histogram: HistogramBuilder,\n\n    #[cfg(tokio_unstable)]\n    pub(super) unhandled_panic: UnhandledPanic,\n}"
    },
    {
        "crate": "tokio",
        "name": "AsyncFd",
        "from_version": "1.31.0",
        "to_version": "1.32.0",
        "module": "io::async_fd",
        "type": "struct",
        "signature": "struct AsyncFd",
        "documentation": "Associates an IO object backed by a Unix file descriptor with the tokio\nreactor, allowing for readiness to be polled. The file descriptor must be of\na type that can be used with the OS polling facilities (ie, `poll`, `epoll`,\n`kqueue`, etc), such as a network socket or pipe, and the file descriptor\nmust have the nonblocking mode set to true.\n\nCreating an AsyncFd registers the file descriptor with the current tokio\nReactor, allowing you to directly await the file descriptor being readable\nor writable. Once registered, the file descriptor remains registered until\nthe AsyncFd is dropped.\n\nThe AsyncFd takes ownership of an arbitrary object to represent the IO\nobject. It is intended that this object will handle closing the file\ndescriptor when it is dropped, avoiding resource leaks and ensuring that the\nAsyncFd can clean up the registration before closing the file descriptor.\nThe [`AsyncFd::into_inner`] function can be used to extract the inner object\nto retake control from the tokio IO reactor.\n\nThe inner object is required to implement [`AsRawFd`]. This file descriptor\nmust not change while [`AsyncFd`] owns the inner object, i.e. the\n[`AsRawFd::as_raw_fd`] method on the inner type must always return the same\nfile descriptor when called multiple times. Failure to uphold this results\nin unspecified behavior in the IO driver, which may include breaking\nnotifications for other sockets/etc.\n\nPolling for readiness is done by calling the async functions [`readable`]\nand [`writable`]. These functions complete when the associated readiness\ncondition is observed. Any number of tasks can query the same `AsyncFd` in\nparallel, on the same or different conditions.\n\nOn some platforms, the readiness detecting mechanism relies on\nedge-triggered notifications. This means that the OS will only notify Tokio\nwhen the file descriptor transitions from not-ready to ready. For this to\nwork you should first try to read or write and only poll for readiness\nif that fails with an error of [`std::io::ErrorKind::WouldBlock`].\n\nTokio internally tracks when it has received a ready notification, and when\nreadiness checking functions like [`readable`] and [`writable`] are called,\nif the readiness flag is set, these async functions will complete\nimmediately. This however does mean that it is critical to ensure that this\nready flag is cleared when (and only when) the file descriptor ceases to be\nready. The [`AsyncFdReadyGuard`] returned from readiness checking functions\nserves this function; after calling a readiness-checking async function,\nyou must use this [`AsyncFdReadyGuard`] to signal to tokio whether the file\ndescriptor is no longer in a ready state.\n\n## Use with to a poll-based API\n\nIn some cases it may be desirable to use `AsyncFd` from APIs similar to\n[`TcpStream::poll_read_ready`]. The [`AsyncFd::poll_read_ready`] and\n[`AsyncFd::poll_write_ready`] functions are provided for this purpose.\nBecause these functions don't create a future to hold their state, they have\nthe limitation that only one task can wait on each direction (read or write)\nat a time.\n\n# Examples\n\nThis example shows how to turn [`std::net::TcpStream`] asynchronous using\n`AsyncFd`.  It implements the read/write operations both as an `async fn`\nand using the IO traits [`AsyncRead`] and [`AsyncWrite`].\n\n```no_run\nuse futures::ready;\nuse std::io::{self, Read, Write};\nuse std::net::TcpStream;\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\nuse tokio::io::{AsyncRead, AsyncWrite, ReadBuf};\nuse tokio::io::unix::AsyncFd;\n\npub struct AsyncTcpStream {\n    inner: AsyncFd<TcpStream>,\n}\n\nimpl AsyncTcpStream {\n    pub fn new(tcp: TcpStream) -> io::Result<Self> {\n        tcp.set_nonblocking(true)?;\n        Ok(Self {\n            inner: AsyncFd::new(tcp)?,\n        })\n    }\n\n    pub async fn read(&self, out: &mut [u8]) -> io::Result<usize> {\n        loop {\n            let mut guard = self.inner.readable().await?;\n\n            match guard.try_io(|inner| inner.get_ref().read(out)) {\n                Ok(result) => return result,\n                Err(_would_block) => continue,\n            }\n        }\n    }\n\n    pub async fn write(&self, buf: &[u8]) -> io::Result<usize> {\n        loop {\n            let mut guard = self.inner.writable().await?;\n\n            match guard.try_io(|inner| inner.get_ref().write(buf)) {\n                Ok(result) => return result,\n                Err(_would_block) => continue,\n            }\n        }\n    }\n}\n\nimpl AsyncRead for AsyncTcpStream {\n    fn poll_read(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>\n    ) -> Poll<io::Result<()>> {\n        loop {\n            let mut guard = ready!(self.inner.poll_read_ready(cx))?;\n\n            let unfilled = buf.initialize_unfilled();\n            match guard.try_io(|inner| inner.get_ref().read(unfilled)) {\n                Ok(Ok(len)) => {\n                    buf.advance(len);\n                    return Poll::Ready(Ok(()));\n                },\n                Ok(Err(err)) => return Poll::Ready(Err(err)),\n                Err(_would_block) => continue,\n            }\n        }\n    }\n}\n\nimpl AsyncWrite for AsyncTcpStream {\n    fn poll_write(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &[u8]\n    ) -> Poll<io::Result<usize>> {\n        loop {\n            let mut guard = ready!(self.inner.poll_write_ready(cx))?;\n\n            match guard.try_io(|inner| inner.get_ref().write(buf)) {\n                Ok(result) => return Poll::Ready(result),\n                Err(_would_block) => continue,\n            }\n        }\n    }\n\n    fn poll_flush(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n    ) -> Poll<io::Result<()>> {\n        // tcp flush is a no-op\n        Poll::Ready(Ok(()))\n    }\n\n    fn poll_shutdown(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n    ) -> Poll<io::Result<()>> {\n        self.inner.get_ref().shutdown(std::net::Shutdown::Write)?;\n        Poll::Ready(Ok(()))\n    }\n}\n```\n\n[`readable`]: method@Self::readable\n[`writable`]: method@Self::writable\n[`AsyncFdReadyGuard`]: struct@self::AsyncFdReadyGuard\n[`TcpStream::poll_read_ready`]: struct@crate::net::TcpStream\n[`AsyncRead`]: trait@crate::io::AsyncRead\n[`AsyncWrite`]: trait@crate::io::AsyncWrite",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub struct AsyncFd<T: AsRawFd> {\n    registration: Registration,\n    inner: Option<T>,\n}",
        "source_code": "pub struct AsyncFd<T: AsRawFd> {\n    registration: Registration,\n    // The inner value is always present. the Option is required for `drop` and `into_inner`.\n    // In all other methods `unwrap` is valid, and will never panic.\n    inner: Option<T>,\n}"
    },
    {
        "crate": "rustix",
        "name": "set_executable_file",
        "from_version": "0.38.12",
        "to_version": "0.38.13",
        "module": "process::prctl",
        "type": "function",
        "old_signature": "fn set_executable_file(fd: BorrowedFd) -> io::Result<()>",
        "signature": "fn set_executable_file(fd: BorrowedFd<'_>) -> io::Result<()>",
        "documentation": "Supersede the `/proc/pid/exe` symbolic link with a new one pointing to a\nnew executable file.\n\n# References\n - [`prctl(PR_SET_MM,PR_SET_MM_EXE_FILE,...)`]\n\n[`prctl(PR_SET_MM,PR_SET_MM_EXE_FILE,...)`]: https://man7.org/linux/man-pages/man2/prctl.2.html",
        "change_type": "signature",
        "changenote": "Signature changed from 'fn set_executable_file(fd: BorrowedFd) -> io::Result<()>' to 'fn set_executable_file(fd: BorrowedFd<'_>) -> io::Result<()>'.",
        "source_code": "pub fn set_executable_file(fd: BorrowedFd<'_>) -> io::Result<()> {\n    let fd = usize::try_from(fd.as_raw_fd()).map_err(|_r| io::Errno::RANGE)?;\n    unsafe { prctl_3args(PR_SET_MM, PR_SET_MM_EXE_FILE as *mut _, fd as *mut _) }"
    },
    {
        "crate": "rustix",
        "name": "move_into_link_name_space",
        "from_version": "0.38.12",
        "to_version": "0.38.13",
        "module": "thread::setns",
        "type": "function",
        "old_signature": "fn move_into_link_name_space(\n    fd: BorrowedFd,\n    allowed_type: Option<LinkNameSpaceType>,\n) -> io::Result<()>",
        "signature": "fn move_into_link_name_space(\n    fd: BorrowedFd<'_>,\n    allowed_type: Option<LinkNameSpaceType>,\n) -> io::Result<()>",
        "documentation": "Reassociate the calling thread with the namespace associated with link\nreferred to by `fd`.\n\n`fd` must refer to one of the magic links in a `/proc/[pid]/ns/` directory,\nor a bind mount to such a link.\n\n# References\n - [Linux]\n\n[Linux]: https://man7.org/linux/man-pages/man2/setns.2.html",
        "change_type": "signature",
        "changenote": "Signature changed from 'fn move_into_link_name_space(\n    fd: BorrowedFd,\n    allowed_type: Option<LinkNameSpaceType>,\n) -> io::Result<()>' to 'fn move_into_link_name_space(\n    fd: BorrowedFd<'_>,\n    allowed_type: Option<LinkNameSpaceType>,\n) -> io::Result<()>'.",
        "source_code": "pub fn move_into_link_name_space(\n    fd: BorrowedFd<'_>,\n    allowed_type: Option<LinkNameSpaceType>,\n) -> io::Result<()> {\n    let allowed_type = allowed_type.map_or(0, |t| t as c_int);\n    syscalls::setns(fd, allowed_type).map(|_r| ())\n}"
    },
    {
        "crate": "rustix",
        "name": "move_into_thread_name_spaces",
        "from_version": "0.38.12",
        "to_version": "0.38.13",
        "module": "thread::setns",
        "type": "function",
        "old_signature": "fn move_into_thread_name_spaces(\n    fd: BorrowedFd,\n    allowed_types: ThreadNameSpaceType,\n) -> io::Result<()>",
        "signature": "fn move_into_thread_name_spaces(\n    fd: BorrowedFd<'_>,\n    allowed_types: ThreadNameSpaceType,\n) -> io::Result<()>",
        "documentation": "Atomically move the calling thread into one or more of the same namespaces\nas the thread referred to by `fd`.\n\n`fd` must refer to a thread ID. See: `pidfd_open` and `clone`.\n\n# References\n - [Linux]\n\n[Linux]: https://man7.org/linux/man-pages/man2/setns.2.html",
        "change_type": "signature",
        "changenote": "Signature changed from 'fn move_into_thread_name_spaces(\n    fd: BorrowedFd,\n    allowed_types: ThreadNameSpaceType,\n) -> io::Result<()>' to 'fn move_into_thread_name_spaces(\n    fd: BorrowedFd<'_>,\n    allowed_types: ThreadNameSpaceType,\n) -> io::Result<()>'.",
        "source_code": "pub fn move_into_thread_name_spaces(\n    fd: BorrowedFd<'_>,\n    allowed_types: ThreadNameSpaceType,\n) -> io::Result<()> {\n    syscalls::setns(fd, allowed_types.bits() as c_int).map(|_r| ())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_reuseaddr",
        "from_version": "0.38.13",
        "to_version": "0.38.14",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_reuseaddr(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_REUSEADDR)`\n\n# References\n - [POSIX `getsockopt`]\n - [POSIX `sys/socket.h`]\n - [Linux `getsockopt`]\n - [Linux `socket`]\n - [Winsock2 `getsockopt`]\n - [Winsock2 `SOL_SOCKET` options]\n - [Apple]\n - [FreeBSD]\n - [NetBSD]\n - [OpenBSD]\n - [DragonFly BSD]\n - [illumos]\n - [glibc `getsockopt`]\n - [glibc `SOL_SOCKET` Options]\n\n[POSIX `getsockopt`]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockopt.html\n[POSIX `sys/socket.h`]: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_socket.h.html\n[Linux `getsockopt`]: https://man7.org/linux/man-pages/man2/getsockopt.2.html\n[Linux `socket`]: https://man7.org/linux/man-pages/man7/socket.7.html\n[Winsock2 `getsockopt`]: https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-getsockopt\n[Winsock2 `SOL_SOCKET` options]: https://docs.microsoft.com/en-us/windows/win32/winsock/sol-socket-socket-options\n[Apple]: https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/getsockopt.2.html\n[FreeBSD]: https://man.freebsd.org/cgi/man.cgi?query=getsockopt&sektion=2\n[NetBSD]: https://man.netbsd.org/getsockopt.2\n[OpenBSD]: https://man.openbsd.org/getsockopt.2\n[DragonFly BSD]: https://man.dragonflybsd.org/?command=getsockopt&section=2\n[illumos]: https://illumos.org/man/3SOCKET/getsockopt\n[glibc `getsockopt`]: https://www.gnu.org/software/libc/manual/html_node/Socket-Option-Functions.html\n[glibc `SOL_SOCKET` options]: https://www.gnu.org/software/libc/manual/html_node/Socket_002dLevel-Options.html",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.14.",
        "source_code": "pub fn get_socket_reuseaddr<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::syscalls::sockopt::get_socket_reuseaddr(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_domain",
        "from_version": "0.38.13",
        "to_version": "0.38.14",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_domain(fd: Fd) -> io::Result<AddressFamily>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_DOMAIN)`\n\n# References\n - [POSIX `getsockopt`]\n - [POSIX `sys/socket.h`]\n - [Linux `getsockopt`]\n - [Linux `socket`]\n - [Winsock2 `getsockopt`]\n - [Winsock2 `SOL_SOCKET` options]\n - [Apple]\n - [FreeBSD]\n - [NetBSD]\n - [OpenBSD]\n - [DragonFly BSD]\n - [illumos]\n - [glibc `getsockopt`]\n - [glibc `SOL_SOCKET` Options]\n\n[POSIX `getsockopt`]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockopt.html\n[POSIX `sys/socket.h`]: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_socket.h.html\n[Linux `getsockopt`]: https://man7.org/linux/man-pages/man2/getsockopt.2.html\n[Linux `socket`]: https://man7.org/linux/man-pages/man7/socket.7.html\n[Winsock2 `getsockopt`]: https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-getsockopt\n[Winsock2 `SOL_SOCKET` options]: https://docs.microsoft.com/en-us/windows/win32/winsock/sol-socket-socket-options\n[Apple]: https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/getsockopt.2.html\n[FreeBSD]: https://man.freebsd.org/cgi/man.cgi?query=getsockopt&sektion=2\n[NetBSD]: https://man.netbsd.org/getsockopt.2\n[OpenBSD]: https://man.openbsd.org/getsockopt.2\n[DragonFly BSD]: https://man.dragonflybsd.org/?command=getsockopt&section=2\n[illumos]: https://illumos.org/man/3SOCKET/getsockopt\n[glibc `getsockopt`]: https://www.gnu.org/software/libc/manual/html_node/Socket-Option-Functions.html\n[glibc `SOL_SOCKET` options]: https://www.gnu.org/software/libc/manual/html_node/Socket_002dLevel-Options.html",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.14.",
        "source_code": "pub fn get_socket_domain<Fd: AsFd>(fd: Fd) -> io::Result<AddressFamily> {\n    backend::net::syscalls::sockopt::get_socket_domain(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_tcp_keepidle",
        "from_version": "0.38.13",
        "to_version": "0.38.14",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_tcp_keepidle(fd: Fd) -> io::Result<Duration>",
        "documentation": "`getsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE)`\n\n`TCP_KEEPALIVE` on Apple platforms.\n\n# References\n - [POSIX `getsockopt`]\n - [POSIX `netinet/tcp.h`]\n - [Linux `getsockopt`]\n - [Linux `tcp`]\n - [Winsock2 `getsockopt`]\n - [Winsock2 `IPPROTO_TCP` options]\n - [Apple `getsockopt`]\n - [Apple `tcp`]\n - [FreeBSD `getsockopt`]\n - [FreeBSD `tcp`]\n - [NetBSD `getsockopt`]\n - [NetBSD `tcp`]\n - [DragonFly BSD `getsockopt`]\n - [DragonFly BSD `tcp`]\n - [illumos `getsockopt`]\n - [illumos `tcp`]\n\n[POSIX `getsockopt`]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockopt.html\n[POSIX `netinet/tcp.h`]: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/netinet_tcp.h.html\n[Linux `getsockopt`]: https://man7.org/linux/man-pages/man2/getsockopt.2.html\n[Linux `tcp`]: https://man7.org/linux/man-pages/man7/tcp.7.html\n[Winsock2 `getsockopt`]: https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-getsockopt\n[Winsock2 `IPPROTO_TCP` options]: https://docs.microsoft.com/en-us/windows/win32/winsock/ipproto-tcp-socket-options\n[Apple `getsockopt`]: https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/getsockopt.2.html\n[Apple `tcp`]: https://opensource.apple.com/source/xnu/xnu-7195.81.3/bsd/man/man4/tcp.4.auto.html\n[FreeBSD `getsockopt`]: https://man.freebsd.org/cgi/man.cgi?query=getsockopt&sektion=2\n[FreeBSD `tcp`]: https://man.freebsd.org/cgi/man.cgi?query=tcp&sektion=4\n[NetBSD `getsockopt`]: https://man.netbsd.org/getsockopt.2\n[NetBSD `tcp`]: https://man.netbsd.org/tcp.4\n[DragonFly BSD `getsockopt`]: https://man.dragonflybsd.org/?command=getsockopt&section=2\n[DragonFly BSD `tcp`]: https://man.dragonflybsd.org/?command=tcp&section=4\n[illumos `getsockopt`]: https://illumos.org/man/3SOCKET/getsockopt\n[illumos `tcp`]: https://illumos.org/man/4P/tcp",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.14.",
        "source_code": "pub fn get_tcp_keepidle<Fd: AsFd>(fd: Fd) -> io::Result<Duration> {\n    backend::net::syscalls::sockopt::get_tcp_keepidle(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "set_tcp_keepintvl",
        "from_version": "0.38.13",
        "to_version": "0.38.14",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_tcp_keepintvl(fd: Fd, duration: Duration) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, duration)`\n\n# References\n - [POSIX `getsockopt`]\n - [POSIX `netinet/tcp.h`]\n - [Linux `getsockopt`]\n - [Linux `tcp`]\n - [Winsock2 `getsockopt`]\n - [Winsock2 `IPPROTO_TCP` options]\n - [Apple `getsockopt`]\n - [Apple `tcp`]\n - [FreeBSD `getsockopt`]\n - [FreeBSD `tcp`]\n - [NetBSD `getsockopt`]\n - [NetBSD `tcp`]\n - [DragonFly BSD `getsockopt`]\n - [DragonFly BSD `tcp`]\n - [illumos `getsockopt`]\n - [illumos `tcp`]\n\n[POSIX `getsockopt`]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockopt.html\n[POSIX `netinet/tcp.h`]: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/netinet_tcp.h.html\n[Linux `getsockopt`]: https://man7.org/linux/man-pages/man2/getsockopt.2.html\n[Linux `tcp`]: https://man7.org/linux/man-pages/man7/tcp.7.html\n[Winsock2 `getsockopt`]: https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-getsockopt\n[Winsock2 `IPPROTO_TCP` options]: https://docs.microsoft.com/en-us/windows/win32/winsock/ipproto-tcp-socket-options\n[Apple `getsockopt`]: https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/getsockopt.2.html\n[Apple `tcp`]: https://opensource.apple.com/source/xnu/xnu-7195.81.3/bsd/man/man4/tcp.4.auto.html\n[FreeBSD `getsockopt`]: https://man.freebsd.org/cgi/man.cgi?query=getsockopt&sektion=2\n[FreeBSD `tcp`]: https://man.freebsd.org/cgi/man.cgi?query=tcp&sektion=4\n[NetBSD `getsockopt`]: https://man.netbsd.org/getsockopt.2\n[NetBSD `tcp`]: https://man.netbsd.org/tcp.4\n[DragonFly BSD `getsockopt`]: https://man.dragonflybsd.org/?command=getsockopt&section=2\n[DragonFly BSD `tcp`]: https://man.dragonflybsd.org/?command=tcp&section=4\n[illumos `getsockopt`]: https://illumos.org/man/3SOCKET/getsockopt\n[illumos `tcp`]: https://illumos.org/man/4P/tcp",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.14.",
        "source_code": "pub fn set_tcp_keepintvl<Fd: AsFd>(fd: Fd, duration: Duration) -> io::Result<()> {\n    backend::net::syscalls::sockopt::set_tcp_keepintvl(fd.as_fd(), duration)\n}"
    },
    {
        "crate": "rustix",
        "name": "set_tcp_keepcnt",
        "from_version": "0.38.13",
        "to_version": "0.38.14",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_tcp_keepcnt(fd: Fd, count: u32) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, count)`\n\n# References\n - [POSIX `getsockopt`]\n - [POSIX `netinet/tcp.h`]\n - [Linux `getsockopt`]\n - [Linux `tcp`]\n - [Winsock2 `getsockopt`]\n - [Winsock2 `IPPROTO_TCP` options]\n - [Apple `getsockopt`]\n - [Apple `tcp`]\n - [FreeBSD `getsockopt`]\n - [FreeBSD `tcp`]\n - [NetBSD `getsockopt`]\n - [NetBSD `tcp`]\n - [DragonFly BSD `getsockopt`]\n - [DragonFly BSD `tcp`]\n - [illumos `getsockopt`]\n - [illumos `tcp`]\n\n[POSIX `getsockopt`]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockopt.html\n[POSIX `netinet/tcp.h`]: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/netinet_tcp.h.html\n[Linux `getsockopt`]: https://man7.org/linux/man-pages/man2/getsockopt.2.html\n[Linux `tcp`]: https://man7.org/linux/man-pages/man7/tcp.7.html\n[Winsock2 `getsockopt`]: https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-getsockopt\n[Winsock2 `IPPROTO_TCP` options]: https://docs.microsoft.com/en-us/windows/win32/winsock/ipproto-tcp-socket-options\n[Apple `getsockopt`]: https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/getsockopt.2.html\n[Apple `tcp`]: https://opensource.apple.com/source/xnu/xnu-7195.81.3/bsd/man/man4/tcp.4.auto.html\n[FreeBSD `getsockopt`]: https://man.freebsd.org/cgi/man.cgi?query=getsockopt&sektion=2\n[FreeBSD `tcp`]: https://man.freebsd.org/cgi/man.cgi?query=tcp&sektion=4\n[NetBSD `getsockopt`]: https://man.netbsd.org/getsockopt.2\n[NetBSD `tcp`]: https://man.netbsd.org/tcp.4\n[DragonFly BSD `getsockopt`]: https://man.dragonflybsd.org/?command=getsockopt&section=2\n[DragonFly BSD `tcp`]: https://man.dragonflybsd.org/?command=tcp&section=4\n[illumos `getsockopt`]: https://illumos.org/man/3SOCKET/getsockopt\n[illumos `tcp`]: https://illumos.org/man/4P/tcp",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.14.",
        "source_code": "pub fn set_tcp_keepcnt<Fd: AsFd>(fd: Fd, count: u32) -> io::Result<()> {\n    backend::net::syscalls::sockopt::set_tcp_keepcnt(fd.as_fd(), count)\n}"
    },
    {
        "crate": "rustix",
        "name": "get_tcp_keepcnt",
        "from_version": "0.38.13",
        "to_version": "0.38.14",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_tcp_keepcnt(fd: Fd) -> io::Result<u32>",
        "documentation": "`getsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT)`\n\n# References\n - [POSIX `getsockopt`]\n - [POSIX `netinet/tcp.h`]\n - [Linux `getsockopt`]\n - [Linux `tcp`]\n - [Winsock2 `getsockopt`]\n - [Winsock2 `IPPROTO_TCP` options]\n - [Apple `getsockopt`]\n - [Apple `tcp`]\n - [FreeBSD `getsockopt`]\n - [FreeBSD `tcp`]\n - [NetBSD `getsockopt`]\n - [NetBSD `tcp`]\n - [DragonFly BSD `getsockopt`]\n - [DragonFly BSD `tcp`]\n - [illumos `getsockopt`]\n - [illumos `tcp`]\n\n[POSIX `getsockopt`]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockopt.html\n[POSIX `netinet/tcp.h`]: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/netinet_tcp.h.html\n[Linux `getsockopt`]: https://man7.org/linux/man-pages/man2/getsockopt.2.html\n[Linux `tcp`]: https://man7.org/linux/man-pages/man7/tcp.7.html\n[Winsock2 `getsockopt`]: https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-getsockopt\n[Winsock2 `IPPROTO_TCP` options]: https://docs.microsoft.com/en-us/windows/win32/winsock/ipproto-tcp-socket-options\n[Apple `getsockopt`]: https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/getsockopt.2.html\n[Apple `tcp`]: https://opensource.apple.com/source/xnu/xnu-7195.81.3/bsd/man/man4/tcp.4.auto.html\n[FreeBSD `getsockopt`]: https://man.freebsd.org/cgi/man.cgi?query=getsockopt&sektion=2\n[FreeBSD `tcp`]: https://man.freebsd.org/cgi/man.cgi?query=tcp&sektion=4\n[NetBSD `getsockopt`]: https://man.netbsd.org/getsockopt.2\n[NetBSD `tcp`]: https://man.netbsd.org/tcp.4\n[DragonFly BSD `getsockopt`]: https://man.dragonflybsd.org/?command=getsockopt&section=2\n[DragonFly BSD `tcp`]: https://man.dragonflybsd.org/?command=tcp&section=4\n[illumos `getsockopt`]: https://illumos.org/man/3SOCKET/getsockopt\n[illumos `tcp`]: https://illumos.org/man/4P/tcp",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.14.",
        "source_code": "pub fn get_tcp_keepcnt<Fd: AsFd>(fd: Fd) -> io::Result<u32> {\n    backend::net::syscalls::sockopt::get_tcp_keepcnt(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "set_tcp_keepidle",
        "from_version": "0.38.13",
        "to_version": "0.38.14",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_tcp_keepidle(fd: Fd, duration: Duration) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, duration)`\n\n`TCP_KEEPALIVE` on Apple platforms.\n\n# References\n - [POSIX `getsockopt`]\n - [POSIX `netinet/tcp.h`]\n - [Linux `getsockopt`]\n - [Linux `tcp`]\n - [Winsock2 `getsockopt`]\n - [Winsock2 `IPPROTO_TCP` options]\n - [Apple `getsockopt`]\n - [Apple `tcp`]\n - [FreeBSD `getsockopt`]\n - [FreeBSD `tcp`]\n - [NetBSD `getsockopt`]\n - [NetBSD `tcp`]\n - [DragonFly BSD `getsockopt`]\n - [DragonFly BSD `tcp`]\n - [illumos `getsockopt`]\n - [illumos `tcp`]\n\n[POSIX `getsockopt`]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockopt.html\n[POSIX `netinet/tcp.h`]: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/netinet_tcp.h.html\n[Linux `getsockopt`]: https://man7.org/linux/man-pages/man2/getsockopt.2.html\n[Linux `tcp`]: https://man7.org/linux/man-pages/man7/tcp.7.html\n[Winsock2 `getsockopt`]: https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-getsockopt\n[Winsock2 `IPPROTO_TCP` options]: https://docs.microsoft.com/en-us/windows/win32/winsock/ipproto-tcp-socket-options\n[Apple `getsockopt`]: https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/getsockopt.2.html\n[Apple `tcp`]: https://opensource.apple.com/source/xnu/xnu-7195.81.3/bsd/man/man4/tcp.4.auto.html\n[FreeBSD `getsockopt`]: https://man.freebsd.org/cgi/man.cgi?query=getsockopt&sektion=2\n[FreeBSD `tcp`]: https://man.freebsd.org/cgi/man.cgi?query=tcp&sektion=4\n[NetBSD `getsockopt`]: https://man.netbsd.org/getsockopt.2\n[NetBSD `tcp`]: https://man.netbsd.org/tcp.4\n[DragonFly BSD `getsockopt`]: https://man.dragonflybsd.org/?command=getsockopt&section=2\n[DragonFly BSD `tcp`]: https://man.dragonflybsd.org/?command=tcp&section=4\n[illumos `getsockopt`]: https://illumos.org/man/3SOCKET/getsockopt\n[illumos `tcp`]: https://illumos.org/man/4P/tcp",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.14.",
        "source_code": "pub fn set_tcp_keepidle<Fd: AsFd>(fd: Fd, duration: Duration) -> io::Result<()> {\n    backend::net::syscalls::sockopt::set_tcp_keepidle(fd.as_fd(), duration)\n}"
    },
    {
        "crate": "rustix",
        "name": "getgroups",
        "from_version": "0.38.13",
        "to_version": "0.38.14",
        "module": "process::id",
        "type": "function",
        "signature": "fn getgroups() -> io::Result<Vec<Gid>>",
        "documentation": "`getgroups()`Return a list of the current user's groups.\n\n# References\n - [POSIX]\n - [Linux]\n\n[POSIX]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/getgroups.html\n[Linux]: https://man7.org/linux/man-pages/man2/getgroups.2.html",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn getgroups() -> io::Result<Vec<Gid>> {\n    let mut buffer = Vec::new();\n\n    // This code would benefit from having a better way to read into\n    // uninitialized memory, but that requires `unsafe`.\n    buffer.reserve(8);\n    buffer.resize(buffer.capacity(), Gid::ROOT);\n\n    loop {\n        let ngroups = backend::process::syscalls::getgroups(&mut buffer)?;\n\n        let ngroups = ngroups as usize;\n        assert!(ngroups <= buffer.len());\n        if ngroups < buffer.len() {\n            buffer.resize(ngroups, Gid::ROOT);\n            return Ok(buffer);\n        }",
        "source_code": "pub fn getgroups() -> io::Result<Vec<Gid>> {\n    // This code would benefit from having a better way to read into\n    // uninitialized memory, but that requires `unsafe`.\n    let mut buffer = Vec::with_capacity(8);\n    buffer.resize(buffer.capacity(), Gid::ROOT);\n\n    loop {\n        let ngroups = backend::process::syscalls::getgroups(&mut buffer)?;\n\n        let ngroups = ngroups as usize;\n        assert!(ngroups <= buffer.len());\n        if ngroups < buffer.len() {\n            buffer.resize(ngroups, Gid::ROOT);\n            return Ok(buffer);\n        }"
    },
    {
        "crate": "rustix",
        "name": "set_socket_reuseport",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_socket_reuseport(fd: Fd, value: bool) -> io::Result<()>",
        "documentation": "`setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, value)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn set_socket_reuseport<Fd: AsFd>(fd: Fd, value: bool) -> io::Result<()> {\n    backend::net::sockopt::set_socket_reuseport(fd.as_fd(), value)\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_reuseport_lb",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_reuseport_lb(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_REUSEPORT_LB)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn get_socket_reuseport_lb<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::sockopt::get_socket_reuseport_lb(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_ipv6_tclass",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_ipv6_tclass(fd: Fd) -> io::Result<u32>",
        "documentation": "`getsockopt(fd, IPPROTO_IPV6, IPV6_TCLASS)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ipv6_-and-set_ipv6_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn get_ipv6_tclass<Fd: AsFd>(fd: Fd) -> io::Result<u32> {\n    backend::net::sockopt::get_ipv6_tclass(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_ip_freebind",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_ip_freebind(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, IPPROTO_IP, IP_FREEBIND)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ipv6_-and-set_ipv6_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn get_ip_freebind<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::sockopt::get_ip_freebind(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "set_tcp_quickack",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_tcp_quickack(fd: Fd, value: bool) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_TCP, TCP_QUICKACK, value)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_tcp_-and-set_tcp_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn set_tcp_quickack<Fd: AsFd>(fd: Fd, value: bool) -> io::Result<()> {\n    backend::net::sockopt::set_tcp_quickack(fd.as_fd(), value)\n}"
    },
    {
        "crate": "rustix",
        "name": "get_ipv6_original_dst",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_ipv6_original_dst(fd: Fd) -> io::Result<SocketAddrV6>",
        "documentation": "`getsockopt(fd, IPPROTO_IPV6, IP6T_SO_ORIGINAL_DST)`\n\nEven though this corresponnds to a `IP6T_*` constant, it is an\n`IPPROTO_IPV6` option.\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ipv6_-and-set_ipv6_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn get_ipv6_original_dst<Fd: AsFd>(fd: Fd) -> io::Result<SocketAddrV6> {\n    backend::net::sockopt::get_ipv6_original_dst(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_tcp_user_timeout",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_tcp_user_timeout(fd: Fd) -> io::Result<u32>",
        "documentation": "`getsockopt(fd, IPPROTO_TCP, TCP_USER_TIMEOUT)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_tcp_-and-set_tcp_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn get_tcp_user_timeout<Fd: AsFd>(fd: Fd) -> io::Result<u32> {\n    backend::net::sockopt::get_tcp_user_timeout(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "set_socket_incoming_cpu",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_socket_incoming_cpu(fd: Fd, value: u32) -> io::Result<()>",
        "documentation": "`setsockopt(fd, SOL_SOCKET, SO_INCOMING_CPU, value)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn set_socket_incoming_cpu<Fd: AsFd>(fd: Fd, value: u32) -> io::Result<()> {\n    backend::net::sockopt::set_socket_incoming_cpu(fd.as_fd(), value)\n}"
    },
    {
        "crate": "rustix",
        "name": "get_ip_original_dst",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_ip_original_dst(fd: Fd) -> io::Result<SocketAddrV4>",
        "documentation": "`getsockopt(fd, IPPROTO_IP, SO_ORIGINAL_DST)`\n\nEven though this corresponnds to a `SO_*` constant, it is an\n`IPPROTO_IP` option.\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ipv6_-and-set_ipv6_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn get_ip_original_dst<Fd: AsFd>(fd: Fd) -> io::Result<SocketAddrV4> {\n    backend::net::sockopt::get_ip_original_dst(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_incoming_cpu",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_incoming_cpu(fd: Fd) -> io::Result<u32>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_INCOMING_CPU)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn get_socket_incoming_cpu<Fd: AsFd>(fd: Fd) -> io::Result<u32> {\n    backend::net::sockopt::get_socket_incoming_cpu(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_cookie",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_cookie(fd: Fd) -> io::Result<u64>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_COOKIE)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn get_socket_cookie<Fd: AsFd>(fd: Fd) -> io::Result<u64> {\n    backend::net::sockopt::get_socket_cookie(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "set_ip_add_membership_with_ifindex",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_ip_add_membership_with_ifindex(\n    fd: Fd,\n    multiaddr: &Ipv4Addr,\n    address: &Ipv4Addr,\n    ifindex: i32,\n) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, multiaddr, address, ifindex)`\n\nThis is similar to [`set_ip_add_membership_with_ifindex`] but additionally\nallows a `ifindex` value to be given.\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ip_-and-set_ip_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn set_ip_add_membership_with_ifindex<Fd: AsFd>(\n    fd: Fd,\n    multiaddr: &Ipv4Addr,\n    address: &Ipv4Addr,\n    ifindex: i32,\n) -> io::Result<()> {\n    backend::net::sockopt::set_ip_add_membership_with_ifindex(\n        fd.as_fd(),\n        multiaddr,\n        address,\n        ifindex,\n    )\n}"
    },
    {
        "crate": "rustix",
        "name": "get_tcp_cork",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_tcp_cork(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, IPPROTO_TCP, TCP_CORK)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_tcp_-and-set_tcp_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn get_tcp_cork<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::sockopt::get_tcp_cork(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "set_tcp_cork",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_tcp_cork(fd: Fd, value: bool) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_TCP, TCP_CORK, value)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_tcp_-and-set_tcp_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn set_tcp_cork<Fd: AsFd>(fd: Fd, value: bool) -> io::Result<()> {\n    backend::net::sockopt::set_tcp_cork(fd.as_fd(), value)\n}"
    },
    {
        "crate": "rustix",
        "name": "get_ip_recvtos",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_ip_recvtos(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, IPPROTO_IP, IP_RECVTOS)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ip_-and-set_ip_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn get_ip_recvtos<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::sockopt::get_ip_recvtos(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "shm_unlink",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "shm",
        "type": "function",
        "signature": "fn shm_unlink(name: P) -> io::Result<()>",
        "documentation": "`shm_unlink(name)`Unlinks a shared memory object.\n\n# References\n - [POSIX]\n - [Linux]\n\n[POSIX]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/shm_unlink.html\n[Linux]: https://man7.org/linux/man-pages/man3/shm_unlink.3.html",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn shm_unlink<P: path::Arg>(name: P) -> io::Result<()> {\n    name.into_with_c_str(|name| backend::shm::syscalls::shm_unlink(name))\n}"
    },
    {
        "crate": "rustix",
        "name": "set_ip_drop_source_membership",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_ip_drop_source_membership(\n    fd: Fd,\n    multiaddr: &Ipv4Addr,\n    interface: &Ipv4Addr,\n    sourceaddr: &Ipv4Addr,\n) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_IP, IP_DROP_SOURCE_MEMBERSHIP, value)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ip_-and-set_ip_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn set_ip_drop_source_membership<Fd: AsFd>(\n    fd: Fd,\n    multiaddr: &Ipv4Addr,\n    interface: &Ipv4Addr,\n    sourceaddr: &Ipv4Addr,\n) -> io::Result<()> {\n    backend::net::sockopt::set_ip_drop_source_membership(\n        fd.as_fd(),\n        multiaddr,\n        interface,\n        sourceaddr,\n    )\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_protocol",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_protocol(fd: Fd) -> io::Result<Option<Protocol>>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_PROTOCOL)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn get_socket_protocol<Fd: AsFd>(fd: Fd) -> io::Result<Option<Protocol>> {\n    backend::net::sockopt::get_socket_protocol(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "set_socket_reuseport_lb",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_socket_reuseport_lb(fd: Fd, value: bool) -> io::Result<()>",
        "documentation": "`setsockopt(fd, SOL_SOCKET, SO_REUSEPORT_LB, value)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn set_socket_reuseport_lb<Fd: AsFd>(fd: Fd, value: bool) -> io::Result<()> {\n    backend::net::sockopt::set_socket_reuseport_lb(fd.as_fd(), value)\n}"
    },
    {
        "crate": "rustix",
        "name": "set_ip_drop_membership_with_ifindex",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_ip_drop_membership_with_ifindex(\n    fd: Fd,\n    multiaddr: &Ipv4Addr,\n    address: &Ipv4Addr,\n    ifindex: i32,\n) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_IP, IP_DROP_MEMBERSHIP, multiaddr, interface)`\n\nThis is similar to [`set_ip_drop_membership_with_ifindex`] but additionally\nallows a `ifindex` value to be given.\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ip_-and-set_ip_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn set_ip_drop_membership_with_ifindex<Fd: AsFd>(\n    fd: Fd,\n    multiaddr: &Ipv4Addr,\n    address: &Ipv4Addr,\n    ifindex: i32,\n) -> io::Result<()> {\n    backend::net::sockopt::set_ip_drop_membership_with_ifindex(\n        fd.as_fd(),\n        multiaddr,\n        address,\n        ifindex,\n    )\n}"
    },
    {
        "crate": "rustix",
        "name": "shm_open",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "shm",
        "type": "function",
        "signature": "fn shm_open(name: P, flags: ShmOFlags, mode: Mode) -> io::Result<OwnedFd>",
        "documentation": "`shm_open(name, oflags, mode)`Opens a shared memory object.\n\nFor portability, `name` should begin with a slash, contain no other\nslashes, and be no longer than an implementation-defined limit (255 on\nLinux).\n\nExactly one of [`ShmOFlags::RDONLY`] and [`ShmOFlags::RDWR`] should be\npassed. The file descriptor will be opened with `FD_CLOEXEC` set.\n\n# References\n - [POSIX]\n - [Linux]\n\n[POSIX]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/shm_open.html\n[Linux]: https://man7.org/linux/man-pages/man3/shm_open.3.html",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn shm_open<P: path::Arg>(name: P, flags: ShmOFlags, mode: Mode) -> io::Result<OwnedFd> {\n    name.into_with_c_str(|name| backend::shm::syscalls::shm_open(name, flags, mode))\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_reuseport",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_reuseport(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_REUSEPORT)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn get_socket_reuseport<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::sockopt::get_socket_reuseport(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_ipv6_recvtclass",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_ipv6_recvtclass(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, IPPROTO_IPV6, IPV6_RECVTCLASS)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ipv6_-and-set_ipv6_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn get_ipv6_recvtclass<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::sockopt::get_ipv6_recvtclass(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_tcp_thin_linear_timeouts",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_tcp_thin_linear_timeouts(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, IPPROTO_TCP, TCP_THIN_LINEAR_TIMEOUTS)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_tcp_-and-set_tcp_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn get_tcp_thin_linear_timeouts<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::sockopt::get_tcp_thin_linear_timeouts(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "set_tcp_user_timeout",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_tcp_user_timeout(fd: Fd, value: u32) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_TCP, TCP_USER_TIMEOUT, value)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_tcp_-and-set_tcp_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn set_tcp_user_timeout<Fd: AsFd>(fd: Fd, value: u32) -> io::Result<()> {\n    backend::net::sockopt::set_tcp_user_timeout(fd.as_fd(), value)\n}"
    },
    {
        "crate": "rustix",
        "name": "set_ip_add_source_membership",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_ip_add_source_membership(\n    fd: Fd,\n    multiaddr: &Ipv4Addr,\n    interface: &Ipv4Addr,\n    sourceaddr: &Ipv4Addr,\n) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_IP, IP_ADD_SOURCE_MEMBERSHIP, value)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ip_-and-set_ip_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn set_ip_add_source_membership<Fd: AsFd>(\n    fd: Fd,\n    multiaddr: &Ipv4Addr,\n    interface: &Ipv4Addr,\n    sourceaddr: &Ipv4Addr,\n) -> io::Result<()> {\n    backend::net::sockopt::set_ip_add_source_membership(\n        fd.as_fd(),\n        multiaddr,\n        interface,\n        sourceaddr,\n    )\n}"
    },
    {
        "crate": "rustix",
        "name": "waitpgid",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "process::wait",
        "type": "function",
        "signature": "fn waitpgid(pgid: Pid, waitopts: WaitOptions) -> io::Result<Option<WaitStatus>>",
        "documentation": "`waitpid(-pgid, waitopts)`Wait for a process in a specific process group\nto change state.\n\nThe call will wait for any child process with the given pgid.\n\nOn Success, returns the status of the selected process.\n\nIf `NOHANG` was specified in the options, and no selected child process\nchanged state, returns `None`.\n\n# References\n - [POSIX]\n - [Linux]\n\n[POSIX]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html\n[Linux]: https://man7.org/linux/man-pages/man2/waitpid.2.html",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn waitpgid(pgid: Pid, waitopts: WaitOptions) -> io::Result<Option<WaitStatus>> {\n    Ok(backend::process::syscalls::waitpgid(pgid, waitopts)?.map(|(_, status)| status))\n}"
    },
    {
        "crate": "rustix",
        "name": "set_ip_tos",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_ip_tos(fd: Fd, value: u8) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_IP, IP_TOS, value)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ip_-and-set_ip_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn set_ip_tos<Fd: AsFd>(fd: Fd, value: u8) -> io::Result<()> {\n    backend::net::sockopt::set_ip_tos(fd.as_fd(), value)\n}"
    },
    {
        "crate": "rustix",
        "name": "set_ipv6_recvtclass",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_ipv6_recvtclass(fd: Fd, value: bool) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_IPV6, IPV6_RECVTCLASS, value)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ipv6_-and-set_ipv6_-functions",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.15.",
        "source_code": "pub fn set_ipv6_recvtclass<Fd: AsFd>(fd: Fd, value: bool) -> io::Result<()> {\n    backend::net::sockopt::set_ipv6_recvtclass(fd.as_fd(), value)\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_nosigpipe",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_nosigpipe(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_socket_nosigpipe<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::syscalls::sockopt::get_socket_nosigpipe(fd.as_fd())\n}",
        "source_code": "pub fn get_socket_nosigpipe<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::sockopt::get_socket_nosigpipe(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "set_ipv6_drop_membership",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_ipv6_drop_membership(\n    fd: Fd,\n    multiaddr: &Ipv6Addr,\n    interface: u32,\n) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP, multiaddr, interface)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ipv6_-and-set_ipv6_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn set_ipv6_drop_membership<Fd: AsFd>(\n    fd: Fd,\n    multiaddr: &Ipv6Addr,\n    interface: u32,\n) -> io::Result<()> {\n    backend::net::syscalls::sockopt::set_ipv6_drop_membership(fd.as_fd(), multiaddr, interface)\n}",
        "source_code": "pub fn set_ipv6_drop_membership<Fd: AsFd>(\n    fd: Fd,\n    multiaddr: &Ipv6Addr,\n    interface: u32,\n) -> io::Result<()> {\n    backend::net::sockopt::set_ipv6_drop_membership(fd.as_fd(), multiaddr, interface)\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_send_buffer_size",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_send_buffer_size(fd: Fd) -> io::Result<usize>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_SNDBUF)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_socket_send_buffer_size<Fd: AsFd>(fd: Fd) -> io::Result<usize> {\n    backend::net::syscalls::sockopt::get_socket_send_buffer_size(fd.as_fd())\n}",
        "source_code": "pub fn get_socket_send_buffer_size<Fd: AsFd>(fd: Fd) -> io::Result<usize> {\n    backend::net::sockopt::get_socket_send_buffer_size(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_reuseaddr",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_reuseaddr(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_REUSEADDR)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_socket_reuseaddr<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::syscalls::sockopt::get_socket_reuseaddr(fd.as_fd())\n}",
        "source_code": "pub fn get_socket_reuseaddr<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::sockopt::get_socket_reuseaddr(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_error",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_error(fd: Fd) -> io::Result<Result<(), io::Errno>>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_ERROR)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_socket_error<Fd: AsFd>(fd: Fd) -> io::Result<Result<(), io::Errno>> {\n    backend::net::syscalls::sockopt::get_socket_error(fd.as_fd())\n}",
        "source_code": "pub fn get_socket_error<Fd: AsFd>(fd: Fd) -> io::Result<Result<(), io::Errno>> {\n    backend::net::sockopt::get_socket_error(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_passcred",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_passcred(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_PASSCRED)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_socket_passcred<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::syscalls::sockopt::get_socket_passcred(fd.as_fd())\n}",
        "source_code": "pub fn get_socket_passcred<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::sockopt::get_socket_passcred(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "set_socket_keepalive",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "old_signature": "fn set_socket_keepalive(fd: Fd, keepalive: bool) -> io::Result<()>",
        "signature": "fn set_socket_keepalive(fd: Fd, value: bool) -> io::Result<()>",
        "documentation": "`setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, value)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "signature",
        "changenote": "Signature changed from 'fn set_socket_keepalive(fd: Fd, keepalive: bool) -> io::Result<()>' to 'fn set_socket_keepalive(fd: Fd, value: bool) -> io::Result<()>'.",
        "source_code": "pub fn set_socket_keepalive<Fd: AsFd>(fd: Fd, value: bool) -> io::Result<()> {\n    backend::net::sockopt::set_socket_keepalive(fd.as_fd(), value)\n}"
    },
    {
        "crate": "rustix",
        "name": "set_ip_drop_membership",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_ip_drop_membership(\n    fd: Fd,\n    multiaddr: &Ipv4Addr,\n    interface: &Ipv4Addr,\n) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_IP, IP_DROP_MEMBERSHIP, multiaddr, interface)`\n\nThis is similar to [`set_ip_drop_membership`] but always sets `ifindex`\nvalue to zero.\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ip_-and-set_ip_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn set_ip_drop_membership<Fd: AsFd>(\n    fd: Fd,\n    multiaddr: &Ipv4Addr,\n    interface: &Ipv4Addr,\n) -> io::Result<()> {\n    backend::net::syscalls::sockopt::set_ip_drop_membership(fd.as_fd(), multiaddr, interface)\n}",
        "source_code": "pub fn set_ip_drop_membership<Fd: AsFd>(\n    fd: Fd,\n    multiaddr: &Ipv4Addr,\n    interface: &Ipv4Addr,\n) -> io::Result<()> {\n    backend::net::sockopt::set_ip_drop_membership(fd.as_fd(), multiaddr, interface)\n}"
    },
    {
        "crate": "rustix",
        "name": "get_ip_multicast_ttl",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_ip_multicast_ttl(fd: Fd) -> io::Result<u32>",
        "documentation": "`getsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ip_-and-set_ip_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_ip_multicast_ttl<Fd: AsFd>(fd: Fd) -> io::Result<u32> {\n    backend::net::syscalls::sockopt::get_ip_multicast_ttl(fd.as_fd())\n}",
        "source_code": "pub fn get_ip_multicast_ttl<Fd: AsFd>(fd: Fd) -> io::Result<u32> {\n    backend::net::sockopt::get_ip_multicast_ttl(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "set_tcp_keepcnt",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "old_signature": "fn set_tcp_keepcnt(fd: Fd, count: u32) -> io::Result<()>",
        "signature": "fn set_tcp_keepcnt(fd: Fd, value: u32) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, value)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_tcp_-and-set_tcp_-functions",
        "change_type": "signature",
        "changenote": "Signature changed from 'fn set_tcp_keepcnt(fd: Fd, count: u32) -> io::Result<()>' to 'fn set_tcp_keepcnt(fd: Fd, value: u32) -> io::Result<()>'.",
        "source_code": "pub fn set_tcp_keepcnt<Fd: AsFd>(fd: Fd, value: u32) -> io::Result<()> {\n    backend::net::sockopt::set_tcp_keepcnt(fd.as_fd(), value)\n}"
    },
    {
        "crate": "rustix",
        "name": "get_ip_ttl",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_ip_ttl(fd: Fd) -> io::Result<u32>",
        "documentation": "`getsockopt(fd, IPPROTO_IP, IP_TTL)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ip_-and-set_ip_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_ip_ttl<Fd: AsFd>(fd: Fd) -> io::Result<u32> {\n    backend::net::syscalls::sockopt::get_ip_ttl(fd.as_fd())\n}",
        "source_code": "pub fn get_ip_ttl<Fd: AsFd>(fd: Fd) -> io::Result<u32> {\n    backend::net::sockopt::get_ip_ttl(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_tcp_nodelay",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_tcp_nodelay(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, IPPROTO_TCP, TCP_NODELAY)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_tcp_-and-set_tcp_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_tcp_nodelay<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::syscalls::sockopt::get_tcp_nodelay(fd.as_fd())\n}",
        "source_code": "pub fn get_tcp_nodelay<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::sockopt::get_tcp_nodelay(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_type",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_type(fd: Fd) -> io::Result<SocketType>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_TYPE)`Returns the type of a socket.\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_socket_type<Fd: AsFd>(fd: Fd) -> io::Result<SocketType> {\n    backend::net::syscalls::sockopt::get_socket_type(fd.as_fd())\n}",
        "source_code": "pub fn get_socket_type<Fd: AsFd>(fd: Fd) -> io::Result<SocketType> {\n    backend::net::sockopt::get_socket_type(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "Resource",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "backend::libc::process::types",
        "type": "enum",
        "signature": "enum Resource",
        "documentation": "A resource value for use with [`getrlimit`], [`setrlimit`], and\n[`prlimit`].\n\n[`getrlimit`]: crate::process::getrlimit\n[`setrlimit`]: crate::process::setrlimit\n[`prlimit`]: crate::process::prlimit",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub enum Resource {\n    /// `RLIMIT_CPU`\n    Cpu = bitcast!(c::RLIMIT_CPU),\n    /// `RLIMIT_FSIZE`\n    Fsize = bitcast!(c::RLIMIT_FSIZE),\n    /// `RLIMIT_DATA`\n    Data = bitcast!(c::RLIMIT_DATA),\n    /// `RLIMIT_STACK`\n    Stack = bitcast!(c::RLIMIT_STACK),\n    /// `RLIMIT_CORE`\n    #[cfg(not(target_os = \"haiku\"))]\n    Core = bitcast!(c::RLIMIT_CORE),\n    /// `RLIMIT_RSS`\n    // \"nto\" has `RLIMIT_RSS`, but it has the same value as `RLIMIT_AS`.\n    #[cfg(not(any(apple, solarish, target_os = \"nto\", target_os = \"haiku\")))]\n    Rss = bitcast!(c::RLIMIT_RSS),\n    /// `RLIMIT_NPROC`\n    #[cfg(not(any(solarish, target_os = \"haiku\")))]\n    Nproc = bitcast!(c::RLIMIT_NPROC),\n    /// `RLIMIT_NOFILE`\n    Nofile = bitcast!(c::RLIMIT_NOFILE),\n    /// `RLIMIT_MEMLOCK`\n    #[cfg(not(any(solarish, target_os = \"aix\", target_os = \"haiku\")))]\n    Memlock = bitcast!(c::RLIMIT_MEMLOCK),\n    /// `RLIMIT_AS`\n    #[cfg(not(target_os = \"openbsd\"))]\n    As = bitcast!(c::RLIMIT_AS),\n    /// `RLIMIT_LOCKS`\n    #[cfg(not(any(\n        bsd,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"haiku\",\n        target_os = \"nto\"\n    )))]\n    Locks = bitcast!(c::RLIMIT_LOCKS),\n    /// `RLIMIT_SIGPENDING`\n    #[cfg(not(any(\n        bsd,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"haiku\",\n        target_os = \"nto\"\n    )))]\n    Sigpending = bitcast!(c::RLIMIT_SIGPENDING),\n    /// `RLIMIT_MSGQUEUE`\n    #[cfg(not(any(\n        bsd,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"haiku\",\n        target_os = \"nto\"\n    )))]\n    Msgqueue = bitcast!(c::RLIMIT_MSGQUEUE),\n    /// `RLIMIT_NICE`\n    #[cfg(not(any(\n        bsd,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"haiku\",\n        target_os = \"nto\"\n    )))]\n    Nice = bitcast!(c::RLIMIT_NICE),\n    /// `RLIMIT_RTPRIO`\n    #[cfg(not(any(\n        bsd,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"haiku\",\n        target_os = \"nto\"\n    )))]\n    Rtprio = bitcast!(c::RLIMIT_RTPRIO),\n    /// `RLIMIT_RTTIME`\n    #[cfg(not(any(\n        bsd,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"android\",\n        target_os = \"emscripten\",\n        target_os = \"haiku\",\n        target_os = \"nto\",\n    )))]\n    Rttime = bitcast!(c::RLIMIT_RTTIME),\n}",
        "source_code": "pub enum Resource {\n    /// `RLIMIT_CPU`\n    Cpu = bitcast!(c::RLIMIT_CPU),\n    /// `RLIMIT_FSIZE`\n    Fsize = bitcast!(c::RLIMIT_FSIZE),\n    /// `RLIMIT_DATA`\n    Data = bitcast!(c::RLIMIT_DATA),\n    /// `RLIMIT_STACK`\n    Stack = bitcast!(c::RLIMIT_STACK),\n    /// `RLIMIT_CORE`\n    #[cfg(not(target_os = \"haiku\"))]\n    Core = bitcast!(c::RLIMIT_CORE),\n    /// `RLIMIT_RSS`\n    // \"nto\" has `RLIMIT_RSS`, but it has the same value as `RLIMIT_AS`.\n    #[cfg(not(any(apple, solarish, target_os = \"nto\", target_os = \"haiku\")))]\n    Rss = bitcast!(c::RLIMIT_RSS),\n    /// `RLIMIT_NPROC`\n    #[cfg(not(any(solarish, target_os = \"haiku\")))]\n    Nproc = bitcast!(c::RLIMIT_NPROC),\n    /// `RLIMIT_NOFILE`\n    Nofile = bitcast!(c::RLIMIT_NOFILE),\n    /// `RLIMIT_MEMLOCK`\n    #[cfg(not(any(solarish, target_os = \"aix\", target_os = \"haiku\")))]\n    Memlock = bitcast!(c::RLIMIT_MEMLOCK),\n    /// `RLIMIT_AS`\n    #[cfg(not(target_os = \"openbsd\"))]\n    As = bitcast!(c::RLIMIT_AS),\n    /// `RLIMIT_LOCKS`\n    #[cfg(not(any(\n        bsd,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"haiku\",\n        target_os = \"hurd\",\n        target_os = \"nto\"\n    )))]\n    Locks = bitcast!(c::RLIMIT_LOCKS),\n    /// `RLIMIT_SIGPENDING`\n    #[cfg(not(any(\n        bsd,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"haiku\",\n        target_os = \"hurd\",\n        target_os = \"nto\"\n    )))]\n    Sigpending = bitcast!(c::RLIMIT_SIGPENDING),\n    /// `RLIMIT_MSGQUEUE`\n    #[cfg(not(any(\n        bsd,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"haiku\",\n        target_os = \"hurd\",\n        target_os = \"nto\"\n    )))]\n    Msgqueue = bitcast!(c::RLIMIT_MSGQUEUE),\n    /// `RLIMIT_NICE`\n    #[cfg(not(any(\n        bsd,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"haiku\",\n        target_os = \"hurd\",\n        target_os = \"nto\"\n    )))]\n    Nice = bitcast!(c::RLIMIT_NICE),\n    /// `RLIMIT_RTPRIO`\n    #[cfg(not(any(\n        bsd,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"haiku\",\n        target_os = \"hurd\",\n        target_os = \"nto\"\n    )))]\n    Rtprio = bitcast!(c::RLIMIT_RTPRIO),\n    /// `RLIMIT_RTTIME`\n    #[cfg(not(any(\n        bsd,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"android\",\n        target_os = \"emscripten\",\n        target_os = \"haiku\",\n        target_os = \"hurd\",\n        target_os = \"nto\",\n    )))]\n    Rttime = bitcast!(c::RLIMIT_RTTIME),\n}"
    },
    {
        "crate": "rustix",
        "name": "get_tcp_keepidle",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_tcp_keepidle(fd: Fd) -> io::Result<Duration>",
        "documentation": "`getsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE)`\n\n`TCP_KEEPALIVE` on Apple platforms.\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_tcp_-and-set_tcp_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_tcp_keepidle<Fd: AsFd>(fd: Fd) -> io::Result<Duration> {\n    backend::net::syscalls::sockopt::get_tcp_keepidle(fd.as_fd())\n}",
        "source_code": "pub fn get_tcp_keepidle<Fd: AsFd>(fd: Fd) -> io::Result<Duration> {\n    backend::net::sockopt::get_tcp_keepidle(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_linger",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_linger(fd: Fd) -> io::Result<Option<Duration>>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_LINGER)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_socket_linger<Fd: AsFd>(fd: Fd) -> io::Result<Option<Duration>> {\n    backend::net::syscalls::sockopt::get_socket_linger(fd.as_fd())\n}",
        "source_code": "pub fn get_socket_linger<Fd: AsFd>(fd: Fd) -> io::Result<Option<Duration>> {\n    backend::net::sockopt::get_socket_linger(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "set_ipv6_multicast_loop",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "old_signature": "fn set_ipv6_multicast_loop(fd: Fd, multicast_loop: bool) -> io::Result<()>",
        "signature": "fn set_ipv6_multicast_loop(fd: Fd, value: bool) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, value)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ipv6_-and-set_ipv6_-functions",
        "change_type": "signature",
        "changenote": "Signature changed from 'fn set_ipv6_multicast_loop(fd: Fd, multicast_loop: bool) -> io::Result<()>' to 'fn set_ipv6_multicast_loop(fd: Fd, value: bool) -> io::Result<()>'.",
        "source_code": "pub fn set_ipv6_multicast_loop<Fd: AsFd>(fd: Fd, value: bool) -> io::Result<()> {\n    backend::net::sockopt::set_ipv6_multicast_loop(fd.as_fd(), value)\n}"
    },
    {
        "crate": "rustix",
        "name": "set_socket_reuseaddr",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_socket_reuseaddr(fd: Fd, value: bool) -> io::Result<()>",
        "documentation": "`setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, value)`Set whether local\naddresses may be reused in `bind`.\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn set_socket_reuseaddr<Fd: AsFd>(fd: Fd, value: bool) -> io::Result<()> {\n    backend::net::syscalls::sockopt::set_socket_reuseaddr(fd.as_fd(), value)\n}",
        "source_code": "pub fn set_socket_reuseaddr<Fd: AsFd>(fd: Fd, value: bool) -> io::Result<()> {\n    backend::net::sockopt::set_socket_reuseaddr(fd.as_fd(), value)\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_recv_buffer_size",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_recv_buffer_size(fd: Fd) -> io::Result<usize>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_RCVBUF)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_socket_recv_buffer_size<Fd: AsFd>(fd: Fd) -> io::Result<usize> {\n    backend::net::syscalls::sockopt::get_socket_recv_buffer_size(fd.as_fd())\n}",
        "source_code": "pub fn get_socket_recv_buffer_size<Fd: AsFd>(fd: Fd) -> io::Result<usize> {\n    backend::net::sockopt::get_socket_recv_buffer_size(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "set_ipv6_add_membership",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_ipv6_add_membership(\n    fd: Fd,\n    multiaddr: &Ipv6Addr,\n    interface: u32,\n) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, multiaddr, interface)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ipv6_-and-set_ipv6_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn set_ipv6_add_membership<Fd: AsFd>(\n    fd: Fd,\n    multiaddr: &Ipv6Addr,\n    interface: u32,\n) -> io::Result<()> {\n    backend::net::syscalls::sockopt::set_ipv6_add_membership(fd.as_fd(), multiaddr, interface)\n}",
        "source_code": "pub fn set_ipv6_add_membership<Fd: AsFd>(\n    fd: Fd,\n    multiaddr: &Ipv6Addr,\n    interface: u32,\n) -> io::Result<()> {\n    backend::net::sockopt::set_ipv6_add_membership(fd.as_fd(), multiaddr, interface)\n}"
    },
    {
        "crate": "rustix",
        "name": "set_ip_add_membership",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn set_ip_add_membership(\n    fd: Fd,\n    multiaddr: &Ipv4Addr,\n    interface: &Ipv4Addr,\n) -> io::Result<()>",
        "documentation": "`setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, multiaddr, interface)`\n\nThis is similar to [`set_ip_add_membership`] but always sets `ifindex`\nvalue to zero.\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ip_-and-set_ip_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn set_ip_add_membership<Fd: AsFd>(\n    fd: Fd,\n    multiaddr: &Ipv4Addr,\n    interface: &Ipv4Addr,\n) -> io::Result<()> {\n    backend::net::syscalls::sockopt::set_ip_add_membership(fd.as_fd(), multiaddr, interface)\n}",
        "source_code": "pub fn set_ip_add_membership<Fd: AsFd>(\n    fd: Fd,\n    multiaddr: &Ipv4Addr,\n    interface: &Ipv4Addr,\n) -> io::Result<()> {\n    backend::net::sockopt::set_ip_add_membership(fd.as_fd(), multiaddr, interface)\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_keepalive",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_keepalive(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_KEEPALIVE)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_socket_keepalive<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::syscalls::sockopt::get_socket_keepalive(fd.as_fd())\n}",
        "source_code": "pub fn get_socket_keepalive<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::sockopt::get_socket_keepalive(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_tcp_keepcnt",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_tcp_keepcnt(fd: Fd) -> io::Result<u32>",
        "documentation": "`getsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_tcp_-and-set_tcp_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_tcp_keepcnt<Fd: AsFd>(fd: Fd) -> io::Result<u32> {\n    backend::net::syscalls::sockopt::get_tcp_keepcnt(fd.as_fd())\n}",
        "source_code": "pub fn get_tcp_keepcnt<Fd: AsFd>(fd: Fd) -> io::Result<u32> {\n    backend::net::sockopt::get_tcp_keepcnt(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "WaitId",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "process::wait",
        "type": "enum",
        "signature": "enum WaitId",
        "documentation": "The identifier to wait on in a call to [`waitid`].",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub enum WaitId<'a> {\n    /// Wait on all processes.\n    All,\n\n    /// Wait for a specific process ID.\n    Pid(Pid),\n\n    /// Wait for a specific process file descriptor.\n    #[cfg(target_os = \"linux\")]\n    PidFd(BorrowedFd<'a>),\n\n    /// Eat the lifetime for non-Linux platforms.\n    #[doc(hidden)]\n    #[cfg(not(target_os = \"linux\"))]\n    __EatLifetime(core::marker::PhantomData<&'a ()>),\n    // TODO(notgull): Once this crate has the concept of PGIDs, add a WaitId::Pgid\n}",
        "source_code": "pub enum WaitId<'a> {\n    /// Wait on all processes.\n    #[doc(alias = \"P_ALL\")]\n    All,\n\n    /// Wait for a specific process ID.\n    #[doc(alias = \"P_PID\")]\n    Pid(Pid),\n\n    /// Wait for a specific process group ID, or the calling process' group ID.\n    #[doc(alias = \"P_PGID\")]\n    Pgid(Option<Pid>),\n\n    /// Wait for a specific process file descriptor.\n    #[cfg(target_os = \"linux\")]\n    #[doc(alias = \"P_PIDFD\")]\n    PidFd(BorrowedFd<'a>),\n\n    /// Eat the lifetime for non-Linux platforms.\n    #[doc(hidden)]\n    #[cfg(not(target_os = \"linux\"))]\n    __EatLifetime(core::marker::PhantomData<&'a ()>),\n}"
    },
    {
        "crate": "rustix",
        "name": "get_ipv6_multicast_loop",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_ipv6_multicast_loop(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_ipv6_-and-set_ipv6_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_ipv6_multicast_loop<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::syscalls::sockopt::get_ipv6_multicast_loop(fd.as_fd())\n}",
        "source_code": "pub fn get_ipv6_multicast_loop<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::sockopt::get_ipv6_multicast_loop(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "set_socket_passcred",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "old_signature": "fn set_socket_passcred(fd: Fd, passcred: bool) -> io::Result<()>",
        "signature": "fn set_socket_passcred(fd: Fd, value: bool) -> io::Result<()>",
        "documentation": "`setsockopt(fd, SOL_SOCKET, SO_PASSCRED, value)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "signature",
        "changenote": "Signature changed from 'fn set_socket_passcred(fd: Fd, passcred: bool) -> io::Result<()>' to 'fn set_socket_passcred(fd: Fd, value: bool) -> io::Result<()>'.",
        "source_code": "pub fn set_socket_passcred<Fd: AsFd>(fd: Fd, value: bool) -> io::Result<()> {\n    backend::net::sockopt::set_socket_passcred(fd.as_fd(), value)\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_broadcast",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_broadcast(fd: Fd) -> io::Result<bool>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, SO_BROADCAST)`\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_socket_broadcast<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::syscalls::sockopt::get_socket_broadcast(fd.as_fd())\n}",
        "source_code": "pub fn get_socket_broadcast<Fd: AsFd>(fd: Fd) -> io::Result<bool> {\n    backend::net::sockopt::get_socket_broadcast(fd.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "get_socket_timeout",
        "from_version": "0.38.14",
        "to_version": "0.38.15",
        "module": "net::sockopt",
        "type": "function",
        "signature": "fn get_socket_timeout(fd: Fd, id: Timeout) -> io::Result<Option<Duration>>",
        "documentation": "`getsockopt(fd, SOL_SOCKET, id)`Get the sending or receiving timeout.\n\nSee the [module-level documentation] for more.\n\n[module-level documentation]: self#references-for-get_socket_-and-set_socket_-functions",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn get_socket_timeout<Fd: AsFd>(fd: Fd, id: Timeout) -> io::Result<Option<Duration>> {\n    backend::net::syscalls::sockopt::get_socket_timeout(fd.as_fd(), id)\n}",
        "source_code": "pub fn get_socket_timeout<Fd: AsFd>(fd: Fd, id: Timeout) -> io::Result<Option<Duration>> {\n    backend::net::sockopt::get_socket_timeout(fd.as_fd(), id)\n}"
    },
    {
        "crate": "hyper",
        "name": "Builder",
        "from_version": "0.14.24",
        "to_version": "0.14.25",
        "module": "client::conn::http1",
        "type": "struct",
        "signature": "struct Builder",
        "documentation": "A builder to configure an HTTP connection.\n\nAfter setting options, the builder is used to create a handshake future.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.14.25.",
        "source_code": "pub struct Builder {\n    h09_responses: bool,\n    h1_parser_config: ParserConfig,\n    h1_writev: Option<bool>,\n    h1_title_case_headers: bool,\n    h1_preserve_header_case: bool,\n    #[cfg(feature = \"ffi\")]\n    h1_preserve_header_order: bool,\n    h1_read_buf_exact_size: Option<usize>,\n    h1_max_buf_size: Option<usize>,\n}"
    },
    {
        "crate": "hyper",
        "name": "Builder",
        "from_version": "0.14.24",
        "to_version": "0.14.25",
        "module": "client::conn::http2",
        "type": "struct",
        "signature": "struct Builder",
        "documentation": "A builder to configure an HTTP connection.\n\nAfter setting options, the builder is used to create a handshake future.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.14.25.",
        "source_code": "pub struct Builder {\n    pub(super) exec: Exec,\n    h2_builder: proto::h2::client::Config,\n}"
    },
    {
        "crate": "hyper",
        "name": "CaptureConnection",
        "from_version": "0.14.24",
        "to_version": "0.14.25",
        "module": "client::connect",
        "type": "struct",
        "signature": "struct CaptureConnection",
        "documentation": "[`CaptureConnection`] allows callers to capture [`Connected`] information\n\nTo capture a connection for a request, use [`capture_connection`].",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.14.25.",
        "source_code": "pub struct CaptureConnection {\n    rx: watch::Receiver<Option<Connected>>,\n}"
    },
    {
        "crate": "hyper",
        "name": "capture_connection",
        "from_version": "0.14.24",
        "to_version": "0.14.25",
        "module": "client::connect",
        "type": "function",
        "signature": "fn capture_connection(request: &mut crate::http::Request<B>) -> CaptureConnection",
        "documentation": "Capture the connection for a given request\n\nWhen making a request with Hyper, the underlying connection must implement the [`Connection`] trait.\n[`capture_connection`] allows a caller to capture the returned [`Connected`] structure as soon\nas the connection is established.\n\n*Note*: If establishing a connection fails, [`CaptureConnection::connection_metadata`] will always return none.\n\n# Examples\n\n**Synchronous access**:\nThe [`CaptureConnection::connection_metadata`] method allows callers to check if a connection has been\nestablished. This is ideal for situations where you are certain the connection has already\nbeen established (e.g. after the response future has already completed).\n```rust\nuse hyper::client::connect::{capture_connection, CaptureConnection};\nlet mut request = http::Request::builder()\n  .uri(\"http://foo.com\")\n  .body(())\n  .unwrap();\n\nlet captured_connection = capture_connection(&mut request);\n// some time later after the request has been sent...\nlet connection_info = captured_connection.connection_metadata();\nprintln!(\"we are connected! {:?}\", connection_info.as_ref());\n```\n\n**Asynchronous access**:\nThe [`CaptureConnection::wait_for_connection_metadata`] method returns a future resolves as soon as the\nconnection is available.\n\n```rust\n# #[cfg(feature  = \"runtime\")]\n# async fn example() {\nuse hyper::client::connect::{capture_connection, CaptureConnection};\nlet mut request = http::Request::builder()\n  .uri(\"http://foo.com\")\n  .body(hyper::Body::empty())\n  .unwrap();\n\nlet mut captured = capture_connection(&mut request);\ntokio::task::spawn(async move {\n    let connection_info = captured.wait_for_connection_metadata().await;\n    println!(\"we are connected! {:?}\", connection_info.as_ref());\n});\n\nlet client = hyper::Client::new();\nclient.request(request).await.expect(\"request failed\");\n# }\n```",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.14.25.",
        "source_code": "pub fn capture_connection<B>(request: &mut crate::http::Request<B>) -> CaptureConnection {\n    let (tx, rx) = CaptureConnection::new();\n    request.extensions_mut().insert(tx);\n    rx\n}"
    },
    {
        "crate": "hyper",
        "name": "Builder",
        "from_version": "0.14.24",
        "to_version": "0.14.25",
        "module": "server::conn::http1",
        "type": "struct",
        "signature": "struct Builder",
        "documentation": "A configuration builder for HTTP/1 server connections.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.14.25.",
        "source_code": "pub struct Builder {\n    h1_half_close: bool,\n    h1_keep_alive: bool,\n    h1_title_case_headers: bool,\n    h1_preserve_header_case: bool,\n    h1_header_read_timeout: Option<Duration>,\n    h1_writev: Option<bool>,\n    max_buf_size: Option<usize>,\n    pipeline_flush: bool,\n}"
    },
    {
        "crate": "hyper",
        "name": "Connected",
        "from_version": "0.14.24",
        "to_version": "0.14.25",
        "module": "client::connect",
        "type": "struct",
        "signature": "struct Connected",
        "documentation": "Extra information about the connected transport.\n\nThis can be used to inform recipients about things like if ALPN\nwas used, or if connected to an HTTP proxy.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub struct Connected {\n    pub(super) alpn: Alpn,\n    pub(super) is_proxied: bool,\n    pub(super) extra: Option<Extra>,\n}",
        "source_code": "pub struct Connected {\n    pub(super) alpn: Alpn,\n    pub(super) is_proxied: bool,\n    pub(super) extra: Option<Extra>,\n    pub(super) poisoned: PoisonPill,\n}"
    },
    {
        "crate": "hyper",
        "name": "Client",
        "from_version": "0.14.24",
        "to_version": "0.14.25",
        "module": "client::client",
        "type": "struct",
        "signature": "struct Client",
        "documentation": "A Client to make outgoing HTTP requests.\n\n`Client` is cheap to clone and cloning is the recommended way to share a `Client`. The\nunderlying connection pool will be reused.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub struct Client<C, B = Body> {\n    config: Config,\n    conn_builder: conn::Builder,\n    connector: C,\n    pool: Pool<PoolClient<B>>,\n}",
        "source_code": "pub struct Client<C, B = Body> {\n    config: Config,\n    #[cfg_attr(feature = \"deprecated\", allow(deprecated))]\n    conn_builder: conn::Builder,\n    connector: C,\n    pool: Pool<PoolClient<B>>,\n}"
    },
    {
        "crate": "chrono",
        "name": "Duration",
        "from_version": "0.4.29",
        "to_version": "0.4.30",
        "module": "duration",
        "type": "struct",
        "signature": "struct Duration",
        "documentation": "ISO 8601 time duration with nanosecond precision.\n\nThis also allows for the negative duration; see individual methods for details.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.4.30.",
        "source_code": "pub struct Duration {\n    secs: i64,\n    nanos: i32, // Always 0 <= nanos < NANOS_PER_SEC\n}"
    },
    {
        "crate": "chrono",
        "name": "Duration",
        "from_version": "0.4.29",
        "to_version": "0.4.30",
        "module": "oldtime",
        "type": "struct",
        "signature": "struct Duration",
        "documentation": "ISO 8601 time duration with nanosecond precision.\n\nThis also allows for the negative duration; see individual methods for details.",
        "change_type": "deprecated",
        "changenote": "API removed in version 0.4.30.",
        "old_source_code": "pub struct Duration {\n    secs: i64,\n    nanos: i32, // Always 0 <= nanos < NANOS_PER_SEC\n}"
    },
    {
        "crate": "rustls",
        "name": "verify_server_cert_signed_by_trust_anchor",
        "from_version": "0.21.5",
        "to_version": "0.21.6",
        "module": "verify",
        "type": "function",
        "signature": "fn verify_server_cert_signed_by_trust_anchor(\n    cert: &ParsedCertificate,\n    roots: &RootCertStore,\n    intermediates: &[Certificate],\n    now: SystemTime,\n) -> Result<(), Error>",
        "documentation": "Verify that the end-entity certificate `end_entity` is a valid server cert\nand chains to at least one of the [OwnedTrustAnchor] in the `roots` [RootCertStore].\n\n`intermediates` contains all certificates other than `end_entity` that\nwere sent as part of the server's [Certificate] message. It is in the\nsame order that the server sent them and may be empty.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn verify_server_cert_signed_by_trust_anchor(\n    cert: &ParsedCertificate,\n    roots: &RootCertStore,\n    intermediates: &[Certificate],\n    now: SystemTime,\n) -> Result<(), Error> {\n    let chain = intermediate_chain(intermediates);\n    let trust_roots = trust_roots(roots);\n    let webpki_now = webpki::Time::try_from(now).map_err(|_| Error::FailedToGetCurrentTime)?;\n\n    cert.0\n        .verify_is_valid_tls_server_cert(\n            SUPPORTED_SIG_ALGS,\n            &webpki::TlsServerTrustAnchors(&trust_roots),\n            &chain,\n            webpki_now,\n        )\n        .map_err(pki_error)\n        .map(|_| ())\n}",
        "source_code": "pub fn verify_server_cert_signed_by_trust_anchor(\n    cert: &ParsedCertificate,\n    roots: &RootCertStore,\n    intermediates: &[Certificate],\n    now: SystemTime,\n) -> Result<(), Error> {\n    let chain = intermediate_chain(intermediates);\n    let trust_roots = trust_roots(roots);\n    let webpki_now = webpki::Time::try_from(now).map_err(|_| Error::FailedToGetCurrentTime)?;\n\n    cert.0\n        .verify_for_usage(\n            SUPPORTED_SIG_ALGS,\n            &trust_roots,\n            &chain,\n            webpki_now,\n            webpki::KeyUsage::server_auth(),\n            &[], // no CRLs\n        )\n        .map_err(pki_error)\n        .map(|_| ())\n}"
    },
    {
        "crate": "rustls",
        "name": "WantsTransparencyPolicyOrClientCert",
        "from_version": "0.21.6",
        "to_version": "0.21.7",
        "module": "client::builder",
        "type": "struct",
        "signature": "struct WantsTransparencyPolicyOrClientCert",
        "documentation": "A config builder state where the caller needs to supply a certificate transparency policy or\nclient certificate resolver.\n\nIn this state, the caller can optionally enable certificate transparency, or ignore CT and\ninvoke one of the methods related to client certificates (as in the [`WantsClientCert`] state).\n\nFor more information, see the [`ConfigBuilder`] documentation.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub struct WantsTransparencyPolicyOrClientCert {\n    cipher_suites: Vec<SupportedCipherSuite>,\n    kx_groups: Vec<&'static SupportedKxGroup>,\n    versions: versions::EnabledVersions,\n    root_store: anchors::RootCertStore,\n}",
        "source_code": "pub struct WantsTransparencyPolicyOrClientCert {\n    cipher_suites: Vec<SupportedCipherSuite>,\n    kx_groups: Vec<&'static SupportedKxGroup>,\n    versions: versions::EnabledVersions,\n    root_store: Arc<anchors::RootCertStore>,\n}"
    },
    {
        "crate": "rustls",
        "name": "PeerMisbehaved",
        "from_version": "0.21.6",
        "to_version": "0.21.7",
        "module": "error",
        "type": "enum",
        "signature": "enum PeerMisbehaved",
        "documentation": "The set of cases where we failed to make a connection because we thought\nthe peer was misbehaving.\n\nThis is `non_exhaustive`: we might add or stop using items here in minor\nversions.  We also don't document what they mean.  Generally a user of\nrustls shouldn't vary its behaviour on these error codes, and there is\nnothing it can do to improve matters.\n\nPlease file a bug against rustls if you see `Error::PeerMisbehaved` in\nthe wild.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub enum PeerMisbehaved {\n    AttemptedDowngradeToTls12WhenTls13IsSupported,\n    BadCertChainExtensions,\n    DisallowedEncryptedExtension,\n    DuplicateClientHelloExtensions,\n    DuplicateEncryptedExtensions,\n    DuplicateHelloRetryRequestExtensions,\n    DuplicateNewSessionTicketExtensions,\n    DuplicateServerHelloExtensions,\n    DuplicateServerNameTypes,\n    EarlyDataAttemptedInSecondClientHello,\n    EarlyDataExtensionWithoutResumption,\n    EarlyDataOfferedWithVariedCipherSuite,\n    HandshakeHashVariedAfterRetry,\n    IllegalHelloRetryRequestWithEmptyCookie,\n    IllegalHelloRetryRequestWithNoChanges,\n    IllegalHelloRetryRequestWithOfferedGroup,\n    IllegalHelloRetryRequestWithUnofferedCipherSuite,\n    IllegalHelloRetryRequestWithUnofferedNamedGroup,\n    IllegalHelloRetryRequestWithUnsupportedVersion,\n    IllegalMiddleboxChangeCipherSpec,\n    IllegalTlsInnerPlaintext,\n    IncorrectBinder,\n    InvalidMaxEarlyDataSize,\n    InvalidKeyShare,\n    InvalidSctList,\n    KeyEpochWithPendingFragment,\n    KeyUpdateReceivedInQuicConnection,\n    MessageInterleavedWithHandshakeMessage,\n    MissingBinderInPskExtension,\n    MissingKeyShare,\n    MissingPskModesExtension,\n    MissingQuicTransportParameters,\n    OfferedDuplicateKeyShares,\n    OfferedEarlyDataWithOldProtocolVersion,\n    OfferedEmptyApplicationProtocol,\n    OfferedIncorrectCompressions,\n    PskExtensionMustBeLast,\n    PskExtensionWithMismatchedIdsAndBinders,\n    RefusedToFollowHelloRetryRequest,\n    RejectedEarlyDataInterleavedWithHandshakeMessage,\n    ResumptionAttemptedWithVariedEms,\n    ResumptionOfferedWithVariedCipherSuite,\n    ResumptionOfferedWithVariedEms,\n    ResumptionOfferedWithIncompatibleCipherSuite,\n    SelectedDifferentCipherSuiteAfterRetry,\n    SelectedInvalidPsk,\n    SelectedTls12UsingTls13VersionExtension,\n    SelectedUnofferedApplicationProtocol,\n    SelectedUnofferedCipherSuite,\n    SelectedUnofferedCompression,\n    SelectedUnofferedKxGroup,\n    SelectedUnofferedPsk,\n    SelectedUnusableCipherSuiteForVersion,\n    ServerHelloMustOfferUncompressedEcPoints,\n    ServerNameDifferedOnRetry,\n    ServerNameMustContainOneHostName,\n    SignedKxWithWrongAlgorithm,\n    SignedHandshakeWithUnadvertisedSigScheme,\n    TooMuchEarlyDataReceived,\n    UnexpectedCleartextExtension,\n    UnsolicitedCertExtension,\n    UnsolicitedEncryptedExtension,\n    UnsolicitedSctList,\n    UnsolicitedServerHelloExtension,\n    WrongGroupForKeyShare,\n}",
        "source_code": "pub enum PeerMisbehaved {\n    AttemptedDowngradeToTls12WhenTls13IsSupported,\n    BadCertChainExtensions,\n    DisallowedEncryptedExtension,\n    DuplicateClientHelloExtensions,\n    DuplicateEncryptedExtensions,\n    DuplicateHelloRetryRequestExtensions,\n    DuplicateNewSessionTicketExtensions,\n    DuplicateServerHelloExtensions,\n    DuplicateServerNameTypes,\n    EarlyDataAttemptedInSecondClientHello,\n    EarlyDataExtensionWithoutResumption,\n    EarlyDataOfferedWithVariedCipherSuite,\n    HandshakeHashVariedAfterRetry,\n    IllegalHelloRetryRequestWithEmptyCookie,\n    IllegalHelloRetryRequestWithNoChanges,\n    IllegalHelloRetryRequestWithOfferedGroup,\n    IllegalHelloRetryRequestWithUnofferedCipherSuite,\n    IllegalHelloRetryRequestWithUnofferedNamedGroup,\n    IllegalHelloRetryRequestWithUnsupportedVersion,\n    IllegalHelloRetryRequestWithWrongSessionId,\n    IllegalMiddleboxChangeCipherSpec,\n    IllegalTlsInnerPlaintext,\n    IncorrectBinder,\n    InvalidMaxEarlyDataSize,\n    InvalidKeyShare,\n    InvalidSctList,\n    KeyEpochWithPendingFragment,\n    KeyUpdateReceivedInQuicConnection,\n    MessageInterleavedWithHandshakeMessage,\n    MissingBinderInPskExtension,\n    MissingKeyShare,\n    MissingPskModesExtension,\n    MissingQuicTransportParameters,\n    OfferedDuplicateKeyShares,\n    OfferedEarlyDataWithOldProtocolVersion,\n    OfferedEmptyApplicationProtocol,\n    OfferedIncorrectCompressions,\n    PskExtensionMustBeLast,\n    PskExtensionWithMismatchedIdsAndBinders,\n    RefusedToFollowHelloRetryRequest,\n    RejectedEarlyDataInterleavedWithHandshakeMessage,\n    ResumptionAttemptedWithVariedEms,\n    ResumptionOfferedWithVariedCipherSuite,\n    ResumptionOfferedWithVariedEms,\n    ResumptionOfferedWithIncompatibleCipherSuite,\n    SelectedDifferentCipherSuiteAfterRetry,\n    SelectedInvalidPsk,\n    SelectedTls12UsingTls13VersionExtension,\n    SelectedUnofferedApplicationProtocol,\n    SelectedUnofferedCipherSuite,\n    SelectedUnofferedCompression,\n    SelectedUnofferedKxGroup,\n    SelectedUnofferedPsk,\n    SelectedUnusableCipherSuiteForVersion,\n    ServerHelloMustOfferUncompressedEcPoints,\n    ServerNameDifferedOnRetry,\n    ServerNameMustContainOneHostName,\n    SignedKxWithWrongAlgorithm,\n    SignedHandshakeWithUnadvertisedSigScheme,\n    TooMuchEarlyDataReceived,\n    UnexpectedCleartextExtension,\n    UnsolicitedCertExtension,\n    UnsolicitedEncryptedExtension,\n    UnsolicitedSctList,\n    UnsolicitedServerHelloExtension,\n    WrongGroupForKeyShare,\n}"
    },
    {
        "crate": "rustls",
        "name": "WebPkiVerifier",
        "from_version": "0.21.6",
        "to_version": "0.21.7",
        "module": "verify",
        "type": "struct",
        "signature": "struct WebPkiVerifier",
        "documentation": "Default `ServerCertVerifier`, see the trait impl for more information.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub struct WebPkiVerifier {\n    roots: RootCertStore,\n    ct_policy: Option<CertificateTransparencyPolicy>,\n}",
        "source_code": "pub struct WebPkiVerifier {\n    roots: Arc<RootCertStore>,\n    ct_policy: Option<CertificateTransparencyPolicy>,\n}"
    },
    {
        "crate": "nom",
        "name": "bits",
        "from_version": "7.1.1",
        "to_version": "7.1.2",
        "module": "bits",
        "type": "function",
        "old_signature": "fn bits(mut parser: P) -> impl FnMut(I) -> IResult<I, O, E2>\nwhere\n  E1: ParseError<(I, usize)> + ErrorConvert<E2>,\n  E2: ParseError<I>,\n  I: Slice<RangeFrom<usize>>,\n  P: FnMut((I, usize)) -> IResult<(I, usize), O, E1>,",
        "signature": "fn bits(mut parser: P) -> impl FnMut(I) -> IResult<I, O, E2>\nwhere\n  E1: ParseError<(I, usize)> + ErrorConvert<E2>,\n  E2: ParseError<I>,\n  I: Slice<RangeFrom<usize>>,\n  P: Parser<(I, usize), O, E1>,",
        "documentation": "Converts a byte-level input to a bit-level input, for consumption by a parser that uses bits.\n\nAfterwards, the input is converted back to a byte-level parser, with any remaining bits thrown\naway.\n\n# Example\n```\nuse nom::bits::{bits, streaming::take};\nuse nom::error::Error;\nuse nom::sequence::tuple;\nuse nom::IResult;\n\nfn parse(input: &[u8]) -> IResult<&[u8], (u8, u8)> {\n    bits::<_, _, Error<(&[u8], usize)>, _, _>(tuple((take(4usize), take(8usize))))(input)\n}\n\nlet input = &[0x12, 0x34, 0xff, 0xff];\n\nlet output = parse(input).expect(\"We take 1.5 bytes and the input is longer than 2 bytes\");\n\n// The first byte is consumed, the second byte is partially consumed and dropped.\nlet remaining = output.0;\nassert_eq!(remaining, [0xff, 0xff]);\n\nlet parsed = output.1;\nassert_eq!(parsed.0, 0x01);\nassert_eq!(parsed.1, 0x23);\n```",
        "change_type": "signature",
        "changenote": "Signature changed from 'fn bits(mut parser: P) -> impl FnMut(I) -> IResult<I, O, E2>\nwhere\n  E1: ParseError<(I, usize)> + ErrorConvert<E2>,\n  E2: ParseError<I>,\n  I: Slice<RangeFrom<usize>>,\n  P: FnMut((I, usize)) -> IResult<(I, usize), O, E1>,' to 'fn bits(mut parser: P) -> impl FnMut(I) -> IResult<I, O, E2>\nwhere\n  E1: ParseError<(I, usize)> + ErrorConvert<E2>,\n  E2: ParseError<I>,\n  I: Slice<RangeFrom<usize>>,\n  P: Parser<(I, usize), O, E1>,'.",
        "source_code": "pub fn bits<I, O, E1, E2, P>(mut parser: P) -> impl FnMut(I) -> IResult<I, O, E2>\nwhere\n  E1: ParseError<(I, usize)> + ErrorConvert<E2>,\n  E2: ParseError<I>,\n  I: Slice<RangeFrom<usize>>,\n  P: Parser<(I, usize), O, E1>,\n{\n  move |input: I| match parser.parse((input, 0)) {\n    Ok(((rest, offset), result)) => {\n      // If the next byte has been partially read, it will be sliced away as well.\n      // The parser functions might already slice away all fully read bytes.\n      // That's why `offset / 8` isn't necessarily needed at all times.\n      let remaining_bytes_index = offset / 8 + if offset % 8 == 0 { 0 }"
    },
    {
        "crate": "nom",
        "name": "count",
        "from_version": "7.1.2",
        "to_version": "7.1.3",
        "module": "multi",
        "type": "function",
        "signature": "fn count(mut f: F, count: usize) -> impl FnMut(I) -> IResult<I, Vec<O>, E>\nwhere\n  I: Clone + PartialEq,\n  F: Parser<I, O, E>,\n  E: ParseError<I>,",
        "documentation": "Runs the embedded parser `count` times, gathering the results in a `Vec`\n\n# Arguments\n* `f` The parser to apply.\n* `count` How often to apply the parser.\n```rust\n# use nom::{Err, error::{Error, ErrorKind}, Needed, IResult};\nuse nom::multi::count;\nuse nom::bytes::complete::tag;\n\nfn parser(s: &str) -> IResult<&str, Vec<&str>> {\n  count(tag(\"abc\"), 2)(s)\n}\n\nassert_eq!(parser(\"abcabc\"), Ok((\"\", vec![\"abc\", \"abc\"])));\nassert_eq!(parser(\"abc123\"), Err(Err::Error(Error::new(\"123\", ErrorKind::Tag))));\nassert_eq!(parser(\"123123\"), Err(Err::Error(Error::new(\"123123\", ErrorKind::Tag))));\nassert_eq!(parser(\"\"), Err(Err::Error(Error::new(\"\", ErrorKind::Tag))));\nassert_eq!(parser(\"abcabcabc\"), Ok((\"abc\", vec![\"abc\", \"abc\"])));\n```",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub fn count<I, O, E, F>(mut f: F, count: usize) -> impl FnMut(I) -> IResult<I, Vec<O>, E>\nwhere\n  I: Clone + PartialEq,\n  F: Parser<I, O, E>,\n  E: ParseError<I>,\n{\n  move |i: I| {\n    let mut input = i.clone();\n    let max_initial_capacity = MAX_INITIAL_CAPACITY_BYTES / crate::lib::std::mem::size_of::<O>();\n    let mut res = crate::lib::std::vec::Vec::with_capacity(count.min(max_initial_capacity));\n\n    for _ in 0..count {\n      let input_ = input.clone();\n      match f.parse(input_) {\n        Ok((i, o)) => {\n          res.push(o);\n          input = i;\n        }",
        "source_code": "pub fn count<I, O, E, F>(mut f: F, count: usize) -> impl FnMut(I) -> IResult<I, Vec<O>, E>\nwhere\n  I: Clone + PartialEq,\n  F: Parser<I, O, E>,\n  E: ParseError<I>,\n{\n  move |i: I| {\n    let mut input = i.clone();\n    let max_initial_capacity =\n      MAX_INITIAL_CAPACITY_BYTES / crate::lib::std::mem::size_of::<O>().max(1);\n    let mut res = crate::lib::std::vec::Vec::with_capacity(count.min(max_initial_capacity));\n\n    for _ in 0..count {\n      let input_ = input.clone();\n      match f.parse(input_) {\n        Ok((i, o)) => {\n          res.push(o);\n          input = i;\n        }"
    },
    {
        "crate": "textwrap",
        "name": "LineEnding",
        "from_version": "0.15.0",
        "to_version": "0.15.1",
        "module": "line_ending",
        "type": "enum",
        "signature": "enum LineEnding",
        "documentation": "Supported line endings. Like in the Rust standard library, two line\nendings are supported: `\\r\\n` and `\\n`",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.15.1.",
        "source_code": "pub enum LineEnding {\n    /// _Carriage return and line feed_  a line ending sequence\n    /// historically used in Windows. Corresponds to the sequence\n    /// of ASCII control characters `0x0D 0x0A` or `\\r\\n`\n    CRLF,\n    /// _Line feed_  a line ending historically used in Unix.\n    ///  Corresponds to the ASCII control character `0x0A` or `\\n`\n    LF,\n}"
    },
    {
        "crate": "textwrap",
        "name": "LineEnding",
        "from_version": "0.15.1",
        "to_version": "0.15.2",
        "module": "line_ending",
        "type": "enum",
        "signature": "enum LineEnding",
        "documentation": "Supported line endings. Like in the Rust standard library, two line\nendings are supported: `\\r\\n` and `\\n`",
        "change_type": "deprecated",
        "changenote": "API removed in version 0.15.2.",
        "old_source_code": "pub enum LineEnding {\n    /// _Carriage return and line feed_  a line ending sequence\n    /// historically used in Windows. Corresponds to the sequence\n    /// of ASCII control characters `0x0D 0x0A` or `\\r\\n`\n    CRLF,\n    /// _Line feed_  a line ending historically used in Unix.\n    ///  Corresponds to the ASCII control character `0x0A` or `\\n`\n    LF,\n}"
    },
    {
        "crate": "textwrap",
        "name": "LineEnding",
        "from_version": "0.15.2",
        "to_version": "0.16.0",
        "module": "line_ending",
        "type": "enum",
        "signature": "enum LineEnding",
        "documentation": "Supported line endings. Like in the Rust standard library, two line\nendings are supported: `\\r\\n` and `\\n`",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.16.0.",
        "source_code": "pub enum LineEnding {\n    /// _Carriage return and line feed_  a line ending sequence\n    /// historically used in Windows. Corresponds to the sequence\n    /// of ASCII control characters `0x0D 0x0A` or `\\r\\n`\n    CRLF,\n    /// _Line feed_  a line ending historically used in Unix.\n    ///  Corresponds to the ASCII control character `0x0A` or `\\n`\n    LF,\n}"
    },
    {
        "crate": "textwrap",
        "name": "fill_slow_path",
        "from_version": "0.15.2",
        "to_version": "0.16.0",
        "module": "fuzzing",
        "type": "function",
        "signature": "fn fill_slow_path(text: &str, options: Options<'_>) -> String",
        "documentation": "Exposed for fuzzing so we can check the slow path is correct.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.16.0.",
        "source_code": "pub fn fill_slow_path<'a>(text: &str, options: Options<'_>) -> String {\n    super::fill_slow_path(text, options)\n}"
    },
    {
        "crate": "redox_syscall",
        "name": "pipe2",
        "from_version": "0.3.5",
        "to_version": "0.4.0",
        "module": "call",
        "type": "function",
        "signature": "fn pipe2(fds: &mut [usize; 2], flags: usize) -> Result<usize>",
        "documentation": "Create a pair of file descriptors referencing the read and write ends of a pipe",
        "change_type": "deprecated",
        "changenote": "API removed in version 0.4.0.",
        "old_source_code": "pub fn pipe2(fds: &mut [usize; 2], flags: usize) -> Result<usize> {\n    unsafe { syscall2(SYS_PIPE2, fds.as_ptr() as usize, flags) }"
    },
    {
        "crate": "flate2",
        "name": "FlushCompress",
        "from_version": "1.0.25",
        "to_version": "1.0.26",
        "module": "mem",
        "type": "enum",
        "signature": "enum FlushCompress",
        "documentation": "Values which indicate the form of flushing to be used when compressing\nin-memory data.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub enum FlushCompress {\n    /// A typical parameter for passing to compression/decompression functions,\n    /// this indicates that the underlying stream to decide how much data to\n    /// accumulate before producing output in order to maximize compression.\n    None = ffi::MZ_NO_FLUSH as isize,\n\n    /// All pending output is flushed to the output buffer and the output is\n    /// aligned on a byte boundary so that the decompressor can get all input\n    /// data available so far.\n    ///\n    /// Flushing may degrade compression for some compression algorithms and so\n    /// it should only be used when necessary. This will complete the current\n    /// deflate block and follow it with an empty stored block.\n    Sync = ffi::MZ_SYNC_FLUSH as isize,\n\n    /// All pending output is flushed to the output buffer, but the output is\n    /// not aligned to a byte boundary.\n    ///\n    /// All of the input data so far will be available to the decompressor (as\n    /// with `Flush::Sync`. This completes the current deflate block and follows\n    /// it with an empty fixed codes block that is 10 bites long, and it assures\n    /// that enough bytes are output in order for the decompressor to finish the\n    /// block before the empty fixed code block.\n    Partial = ffi::MZ_PARTIAL_FLUSH as isize,\n\n    /// All output is flushed as with `Flush::Sync` and the compression state is\n    /// reset so decompression can restart from this point if previous\n    /// compressed data has been damaged or if random access is desired.\n    ///\n    /// Using this option too often can seriously degrade compression.\n    Full = ffi::MZ_FULL_FLUSH as isize,\n\n    /// Pending input is processed and pending output is flushed.\n    ///\n    /// The return value may indicate that the stream is not yet done and more\n    /// data has yet to be processed.\n    Finish = ffi::MZ_FINISH as isize,\n\n    #[doc(hidden)]\n    _Nonexhaustive,\n}",
        "source_code": "pub enum FlushCompress {\n    /// A typical parameter for passing to compression/decompression functions,\n    /// this indicates that the underlying stream to decide how much data to\n    /// accumulate before producing output in order to maximize compression.\n    None = ffi::MZ_NO_FLUSH as isize,\n\n    /// All pending output is flushed to the output buffer and the output is\n    /// aligned on a byte boundary so that the decompressor can get all input\n    /// data available so far.\n    ///\n    /// Flushing may degrade compression for some compression algorithms and so\n    /// it should only be used when necessary. This will complete the current\n    /// deflate block and follow it with an empty stored block.\n    Sync = ffi::MZ_SYNC_FLUSH as isize,\n\n    /// All pending output is flushed to the output buffer, but the output is\n    /// not aligned to a byte boundary.\n    ///\n    /// All of the input data so far will be available to the decompressor (as\n    /// with `Flush::Sync`. This completes the current deflate block and follows\n    /// it with an empty fixed codes block that is 10 bites long, and it assures\n    /// that enough bytes are output in order for the decompressor to finish the\n    /// block before the empty fixed code block.\n    Partial = ffi::MZ_PARTIAL_FLUSH as isize,\n\n    /// All output is flushed as with `Flush::Sync` and the compression state is\n    /// reset so decompression can restart from this point if previous\n    /// compressed data has been damaged or if random access is desired.\n    ///\n    /// Using this option too often can seriously degrade compression.\n    Full = ffi::MZ_FULL_FLUSH as isize,\n\n    /// Pending input is processed and pending output is flushed.\n    ///\n    /// The return value may indicate that the stream is not yet done and more\n    /// data has yet to be processed.\n    Finish = ffi::MZ_FINISH as isize,\n}"
    },
    {
        "crate": "flate2",
        "name": "FlushDecompress",
        "from_version": "1.0.25",
        "to_version": "1.0.26",
        "module": "mem",
        "type": "enum",
        "signature": "enum FlushDecompress",
        "documentation": "Values which indicate the form of flushing to be used when\ndecompressing in-memory data.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub enum FlushDecompress {\n    /// A typical parameter for passing to compression/decompression functions,\n    /// this indicates that the underlying stream to decide how much data to\n    /// accumulate before producing output in order to maximize compression.\n    None = ffi::MZ_NO_FLUSH as isize,\n\n    /// All pending output is flushed to the output buffer and the output is\n    /// aligned on a byte boundary so that the decompressor can get all input\n    /// data available so far.\n    ///\n    /// Flushing may degrade compression for some compression algorithms and so\n    /// it should only be used when necessary. This will complete the current\n    /// deflate block and follow it with an empty stored block.\n    Sync = ffi::MZ_SYNC_FLUSH as isize,\n\n    /// Pending input is processed and pending output is flushed.\n    ///\n    /// The return value may indicate that the stream is not yet done and more\n    /// data has yet to be processed.\n    Finish = ffi::MZ_FINISH as isize,\n\n    #[doc(hidden)]\n    _Nonexhaustive,\n}",
        "source_code": "pub enum FlushDecompress {\n    /// A typical parameter for passing to compression/decompression functions,\n    /// this indicates that the underlying stream to decide how much data to\n    /// accumulate before producing output in order to maximize compression.\n    None = ffi::MZ_NO_FLUSH as isize,\n\n    /// All pending output is flushed to the output buffer and the output is\n    /// aligned on a byte boundary so that the decompressor can get all input\n    /// data available so far.\n    ///\n    /// Flushing may degrade compression for some compression algorithms and so\n    /// it should only be used when necessary. This will complete the current\n    /// deflate block and follow it with an empty stored block.\n    Sync = ffi::MZ_SYNC_FLUSH as isize,\n\n    /// Pending input is processed and pending output is flushed.\n    ///\n    /// The return value may indicate that the stream is not yet done and more\n    /// data has yet to be processed.\n    Finish = ffi::MZ_FINISH as isize,\n}"
    },
    {
        "crate": "flate2",
        "name": "GzDecoder",
        "from_version": "1.0.26",
        "to_version": "1.0.27",
        "module": "gz::bufread",
        "type": "struct",
        "signature": "struct GzDecoder",
        "documentation": "A decoder for a single member of a [gzip file].\n\nThis structure exposes a [`BufRead`] interface, reading compressed data\nfrom the underlying reader, and emitting uncompressed data.\n\nAfter reading a single member of the gzip data this reader will return\nOk(0) even if there are more bytes available in the underlying reader.\nIf you need the following bytes, call `into_inner()` after Ok(0) to\nrecover the underlying reader.\n\nTo handle gzip files that may have multiple members, see [`MultiGzDecoder`]\nor read more\n[in the introduction](../index.html#about-multi-member-gzip-files).\n\n[gzip file]: https://www.rfc-editor.org/rfc/rfc1952#page-5\n[`BufRead`]: https://doc.rust-lang.org/std/io/trait.BufRead.html\n\n# Examples\n\n```\nuse std::io::prelude::*;\nuse std::io;\n# use flate2::Compression;\n# use flate2::write::GzEncoder;\nuse flate2::bufread::GzDecoder;\n\n# fn main() {\n#   let mut e = GzEncoder::new(Vec::new(), Compression::default());\n#   e.write_all(b\"Hello World\").unwrap();\n#   let bytes = e.finish().unwrap();\n#   println!(\"{}\", decode_reader(bytes).unwrap());\n# }\n#\n// Uncompresses a Gz Encoded vector of bytes and returns a string or error\n// Here &[u8] implements BufRead\n\nfn decode_reader(bytes: Vec<u8>) -> io::Result<String> {\n   let mut gz = GzDecoder::new(&bytes[..]);\n   let mut s = String::new();\n   gz.read_to_string(&mut s)?;\n   Ok(s)\n}\n```",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub struct GzDecoder<R> {\n    inner: GzState,\n    header: Option<GzHeader>,\n    reader: CrcReader<deflate::bufread::DeflateDecoder<R>>,\n    multi: bool,\n}",
        "source_code": "pub struct GzDecoder<R> {\n    state: GzState,\n    reader: CrcReader<deflate::bufread::DeflateDecoder<R>>,\n    multi: bool,\n}"
    },
    {
        "crate": "libc",
        "name": "PF_BLOCK_TS",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_BLOCK_TS: c_int  = 0x20000000",
        "documentation": "Plug has ts that needs updating.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_BLOCK_TS: c_int = 0x20000000;"
    },
    {
        "crate": "libc",
        "name": "PF_MEMALLOC",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_MEMALLOC: c_int  = 0x00000800",
        "documentation": "Allocating memory to free memory.\n\nSee `memalloc_noreclaim_save()`.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_MEMALLOC: c_int = 0x00000800;"
    },
    {
        "crate": "libc",
        "name": "PF_MEMALLOC_PIN",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_MEMALLOC_PIN: c_int  = 0x10000000",
        "documentation": "Allocations constrained to zones which allow long term pinning.\n\nSee `memalloc_pin_save()`.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_MEMALLOC_PIN: c_int = 0x10000000;"
    },
    {
        "crate": "libc",
        "name": "PF_NPROC_EXCEEDED",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_NPROC_EXCEEDED: c_int  = 0x00001000",
        "documentation": "`set_user()` noticed that `RLIMIT_NPROC` was exceeded.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_NPROC_EXCEEDED: c_int = 0x00001000;"
    },
    {
        "crate": "libc",
        "name": "PF_EXITING",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_EXITING: c_int  = 0x00000004",
        "documentation": "Getting shut down.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_EXITING: c_int = 0x00000004;"
    },
    {
        "crate": "libc",
        "name": "PF_LOCAL_THROTTLE",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_LOCAL_THROTTLE: c_int  = 0x00100000",
        "documentation": "Throttle writes only against the bdi I write to, I am cleaning\ndirty pages from some other bdi.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_LOCAL_THROTTLE: c_int = 0x00100000;"
    },
    {
        "crate": "libc",
        "name": "PF_NOFREEZE",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_NOFREEZE: c_int  = 0x00008000",
        "documentation": "This thread should not be frozen.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_NOFREEZE: c_int = 0x00008000;"
    },
    {
        "crate": "libc",
        "name": "PF_NO_SETAFFINITY",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_NO_SETAFFINITY: c_int  = 0x04000000",
        "documentation": "Userland is not allowed to meddle with `cpus_mask`.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_NO_SETAFFINITY: c_int = 0x04000000;"
    },
    {
        "crate": "libc",
        "name": "PF_KSWAPD",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_KSWAPD: c_int  = 0x00020000",
        "documentation": "I am `kswapd`.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_KSWAPD: c_int = 0x00020000;"
    },
    {
        "crate": "libc",
        "name": "PF_VCPU",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_VCPU: c_int  = 0x00000001",
        "documentation": "I'm a virtual CPU.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_VCPU: c_int = 0x00000001;"
    },
    {
        "crate": "libc",
        "name": "PF_SUPERPRIV",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_SUPERPRIV: c_int  = 0x00000100",
        "documentation": "Used super-user privileges.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_SUPERPRIV: c_int = 0x00000100;"
    },
    {
        "crate": "libc",
        "name": "PF_DUMPCORE",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_DUMPCORE: c_int  = 0x00000200",
        "documentation": "Dumped core.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_DUMPCORE: c_int = 0x00000200;"
    },
    {
        "crate": "libc",
        "name": "PF_MCE_EARLY",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_MCE_EARLY: c_int  = 0x08000000",
        "documentation": "Early kill for mce process policy.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_MCE_EARLY: c_int = 0x08000000;"
    },
    {
        "crate": "libc",
        "name": "PF_FORKNOEXEC",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_FORKNOEXEC: c_int  = 0x00000040",
        "documentation": "Forked but didn't exec.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_FORKNOEXEC: c_int = 0x00000040;"
    },
    {
        "crate": "libc",
        "name": "PF_MCE_PROCESS",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_MCE_PROCESS: c_int  = 0x00000080",
        "documentation": "Process policy on mce errors.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_MCE_PROCESS: c_int = 0x00000080;"
    },
    {
        "crate": "libc",
        "name": "PF_USER_WORKER",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_USER_WORKER: c_int  = 0x00004000",
        "documentation": "Kernel thread cloned from userspace thread.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_USER_WORKER: c_int = 0x00004000;"
    },
    {
        "crate": "libc",
        "name": "PF_POSTCOREDUMP",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_POSTCOREDUMP: c_int  = 0x00000008",
        "documentation": "Coredumps should ignore this task.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_POSTCOREDUMP: c_int = 0x00000008;"
    },
    {
        "crate": "libc",
        "name": "PF_SIGNALED",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_SIGNALED: c_int  = 0x00000400",
        "documentation": "Killed by a signal.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_SIGNALED: c_int = 0x00000400;"
    },
    {
        "crate": "libc",
        "name": "PF_IDLE",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_IDLE: c_int  = 0x00000002",
        "documentation": "I am an IDLE thread.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_IDLE: c_int = 0x00000002;"
    },
    {
        "crate": "libc",
        "name": "PF_RANDOMIZE",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_RANDOMIZE: c_int  = 0x00400000",
        "documentation": "Randomize virtual address space.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_RANDOMIZE: c_int = 0x00400000;"
    },
    {
        "crate": "libc",
        "name": "PF_KTHREAD",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_KTHREAD: c_int  = 0x00200000",
        "documentation": "I am a kernel thread.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_KTHREAD: c_int = 0x00200000;"
    },
    {
        "crate": "libc",
        "name": "PF_WQ_WORKER",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_WQ_WORKER: c_int  = 0x00000020",
        "documentation": "I'm a workqueue worker.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_WQ_WORKER: c_int = 0x00000020;"
    },
    {
        "crate": "libc",
        "name": "PF_SUSPEND_TASK",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_SUSPEND_TASK: c_int  = PF_SUSPEND_TASK_UINT as _",
        "documentation": "This thread called `freeze_processes()` and should not be frozen.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_SUSPEND_TASK: c_int = PF_SUSPEND_TASK_UINT as _;"
    },
    {
        "crate": "libc",
        "name": "PF_IO_WORKER",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_IO_WORKER: c_int  = 0x00000010",
        "documentation": "Task is an IO worker.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_IO_WORKER: c_int = 0x00000010;"
    },
    {
        "crate": "libc",
        "name": "PF_USED_MATH",
        "from_version": "0.2.167",
        "to_version": "0.2.168",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "signature": "const PF_USED_MATH: c_int  = 0x00002000",
        "documentation": "If unset the fpu must be initialized before use.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.2.168.",
        "source_code": "pub const PF_USED_MATH: c_int = 0x00002000;"
    },
    {
        "crate": "tokio",
        "name": "Backtrace",
        "from_version": "1.42.0",
        "to_version": "1.43.0",
        "module": "runtime::dump",
        "type": "struct",
        "signature": "struct Backtrace",
        "documentation": "A captured backtrace.\n\nThis struct provides access to each backtrace frame, similar to [`backtrace::Backtrace`].",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 1.43.0.",
        "source_code": "pub struct Backtrace {\n    frames: Box<[BacktraceFrame]>,\n}"
    },
    {
        "crate": "tokio",
        "name": "BacktraceSymbol",
        "from_version": "1.42.0",
        "to_version": "1.43.0",
        "module": "runtime::dump",
        "type": "struct",
        "signature": "struct BacktraceSymbol",
        "documentation": "A backtrace symbol.\n\nThis struct provides accessors for backtrace symbols, similar to [`backtrace::BacktraceSymbol`].",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 1.43.0.",
        "source_code": "pub struct BacktraceSymbol {\n    name: Option<Box<[u8]>>,\n    name_demangled: Option<Box<str>>,\n    addr: Option<Address>,\n    filename: Option<std::path::PathBuf>,\n    lineno: Option<u32>,\n    colno: Option<u32>,\n}"
    },
    {
        "crate": "tokio",
        "name": "BacktraceFrame",
        "from_version": "1.42.0",
        "to_version": "1.43.0",
        "module": "runtime::dump",
        "type": "struct",
        "signature": "struct BacktraceFrame",
        "documentation": "A backtrace frame.\n\nThis struct represents one stack frame in a captured backtrace, similar to [`backtrace::BacktraceFrame`].",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 1.43.0.",
        "source_code": "pub struct BacktraceFrame {\n    ip: Address,\n    symbol_address: Address,\n    symbols: Box<[BacktraceSymbol]>,\n}"
    },
    {
        "crate": "rustix",
        "name": "port_getn_query",
        "from_version": "0.38.40",
        "to_version": "0.38.41",
        "module": "event::port",
        "type": "function",
        "signature": "fn port_getn_query(port: impl AsFd) -> io::Result<u32>",
        "documentation": "`port_getn(port, NULL, 0, NULL)`Queries the number of events\navailable from a port.\n\nTo retrieve the events, use [`port_getn`].\n\n# References\n - [OpenSolaris]\n - [illumos]\n\n[OpenSolaris]: https://www.unix.com/man-page/opensolaris/3C/port_getn/\n[illumos]: https://illumos.org/man/3C/port_getn",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 0.38.41.",
        "source_code": "pub fn port_getn_query(port: impl AsFd) -> io::Result<u32> {\n    syscalls::port_getn_query(port.as_fd())\n}"
    },
    {
        "crate": "rustix",
        "name": "FlockOperation",
        "from_version": "0.38.41",
        "to_version": "0.38.42",
        "module": "backend::libc::fs::types",
        "type": "enum",
        "signature": "enum FlockOperation",
        "documentation": "`LOCK_*` constants for use with [`flock`] and [`fcntl_lock`].\n\n[`flock`]: crate::fs::flock\n[`fcntl_lock`]: crate::fs::fcntl_lock",
        "change_type": "deprecated",
        "changenote": "API removed in version 0.38.42.",
        "old_source_code": "pub enum FlockOperation {\n    /// `LOCK_SH`\n    LockShared = bitcast!(c::LOCK_SH),\n    /// `LOCK_EX`\n    LockExclusive = bitcast!(c::LOCK_EX),\n    /// `LOCK_UN`\n    Unlock = bitcast!(c::LOCK_UN),\n    /// `LOCK_SH | LOCK_NB`\n    NonBlockingLockShared = bitcast!(c::LOCK_SH | c::LOCK_NB),\n    /// `LOCK_EX | LOCK_NB`\n    NonBlockingLockExclusive = bitcast!(c::LOCK_EX | c::LOCK_NB),\n    /// `LOCK_UN | LOCK_NB`\n    NonBlockingUnlock = bitcast!(c::LOCK_UN | c::LOCK_NB),\n}"
    },
    {
        "crate": "rustix",
        "name": "DecInt",
        "from_version": "0.38.41",
        "to_version": "0.38.42",
        "module": "path::dec_int",
        "type": "struct",
        "signature": "struct DecInt",
        "documentation": "Format an integer into a decimal `Path` component, without constructing a\ntemporary `PathBuf` or `String`.\n\nThis is used for opening paths such as `/proc/self/fd/<fd>` on Linux.\n\n# Examples\n\n```\n# #[cfg(any(feature = \"fs\", feature = \"net\"))]\nuse rustix::path::DecInt;\n\n# #[cfg(any(feature = \"fs\", feature = \"net\"))]\nassert_eq!(\n    format!(\"hello {}\", DecInt::new(9876).as_ref().display()),\n    \"hello 9876\"\n);\n```",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub struct DecInt {\n    // 20 `u8`s is enough to hold the decimal ASCII representation of any\n    // `u64`, and we add one for a NUL terminator for `as_c_str`.\n    buf: [u8; 20 + 1],\n    len: usize,\n}",
        "source_code": "pub struct DecInt {\n    // Enough to hold an {u,i}"
    },
    {
        "crate": "hyper",
        "name": "Incoming",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "body::incoming",
        "type": "struct",
        "signature": "struct Incoming",
        "documentation": "A stream of `Bytes`, used when receiving bodies from the network.\n\nNote that Users should not instantiate this struct directly. When working with the hyper client,\n`Incoming` is returned to you in responses. Similarly, when operating with the hyper server,\nit is provided within requests.\n\n# Examples\n\n```rust,ignore\nasync fn echo(\n   req: Request<hyper::body::Incoming>,\n) -> Result<Response<BoxBody<Bytes, hyper::Error>>, hyper::Error> {\n   //Here, you can process `Incoming`\n}\n```",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 1.5.1.",
        "source_code": "pub struct Incoming {\n    kind: Kind,\n}"
    },
    {
        "crate": "hyper",
        "name": "ReadBuf",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "rt::io",
        "type": "struct",
        "signature": "struct ReadBuf",
        "documentation": "A wrapper around a byte buffer that is incrementally filled and initialized.\n\nThis type is a sort of \"double cursor\". It tracks three regions in the\nbuffer: a region at the beginning of the buffer that has been logically\nfilled with data, a region that has been initialized at some point but not\nyet logically filled, and a region at the end that may be uninitialized.\nThe filled region is guaranteed to be a subset of the initialized region.\n\nIn summary, the contents of the buffer can be visualized as:\n\n```not_rust\n[             capacity              ]\n[ filled |         unfilled         ]\n[    initialized    | uninitialized ]\n```\n\nIt is undefined behavior to de-initialize any bytes from the uninitialized\nregion, since it is merely unknown whether this region is uninitialized or\nnot, and if part of it turns out to be initialized, it must stay initialized.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 1.5.1.",
        "source_code": "pub struct ReadBuf<'a> {\n    raw: &'a mut [MaybeUninit<u8>],\n    filled: usize,\n    init: usize,\n}"
    },
    {
        "crate": "hyper",
        "name": "Write",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "rt::io",
        "type": "trait",
        "signature": "trait Write",
        "documentation": "Write bytes asynchronously.\n\nThis trait is similar to `std::io::Write`, but for asynchronous writes.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 1.5.1.",
        "source_code": "pub trait Write {\n    /// Attempt to write bytes from `buf` into the destination.\n    ///\n    /// On success, returns `Poll::Ready(Ok(num_bytes_written)))`. If\n    /// successful, it must be guaranteed that `n <= buf.len()`. A return value\n    /// of `0` means that the underlying object is no longer able to accept\n    /// bytes, or that the provided buffer is empty.\n    ///\n    /// If the object is not ready for writing, the method returns\n    /// `Poll::Pending` and arranges for the current task (via `cx.waker()`) to\n    /// receive a notification when the object becomes writable or is closed.\n    fn poll_write(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &[u8],\n    ) -> Poll<Result<usize, std::io::Error>>;\n\n    /// Attempts to flush the object.\n    ///\n    /// On success, returns `Poll::Ready(Ok(()))`.\n    ///\n    /// If flushing cannot immediately complete, this method returns\n    /// `Poll::Pending` and arranges for the current task (via `cx.waker()`) to\n    /// receive a notification when the object can make progress.\n    fn poll_flush(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), std::io::Error>>;\n\n    /// Attempts to shut down this writer.\n    fn poll_shutdown(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n    ) -> Poll<Result<(), std::io::Error>>;\n\n    /// Returns whether this writer has an efficient `poll_write_vectored`\n    /// implementation.\n    ///\n    /// The default implementation returns `false`.\n    fn is_write_vectored(&self) -> bool {\n        false\n    }"
    },
    {
        "crate": "hyper",
        "name": "Read",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "rt::io",
        "type": "trait",
        "signature": "trait Read",
        "documentation": "Reads bytes from a source.\n\nThis trait is similar to `std::io::Read`, but supports asynchronous reads.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 1.5.1.",
        "source_code": "pub trait Read {\n    /// Attempts to read bytes into the `buf`.\n    ///\n    /// On success, returns `Poll::Ready(Ok(()))` and places data in the\n    /// unfilled portion of `buf`. If no data was read (`buf.remaining()` is\n    /// unchanged), it implies that EOF has been reached.\n    ///\n    /// If no data is available for reading, the method returns `Poll::Pending`\n    /// and arranges for the current task (via `cx.waker()`) to receive a\n    /// notification when the object becomes readable or is closed.\n    fn poll_read(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: ReadBufCursor<'_>,\n    ) -> Poll<Result<(), std::io::Error>>;\n}"
    },
    {
        "crate": "hyper",
        "name": "ReadBufCursor",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "rt::io",
        "type": "struct",
        "signature": "struct ReadBufCursor",
        "documentation": "The cursor part of a [`ReadBuf`].\n\nThis is created by calling `ReadBuf::unfilled()`.",
        "change_type": "stabilized",
        "changenote": "A new stable API has been introduced since version 1.5.1.",
        "source_code": "pub struct ReadBufCursor<'a> {\n    buf: &'a mut ReadBuf<'a>,\n}"
    },
    {
        "crate": "hyper",
        "name": "Builder",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "client::conn",
        "type": "struct",
        "signature": "struct Builder",
        "documentation": "A builder to configure an HTTP connection.\n\nAfter setting options, the builder is used to create a handshake future.",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct Builder {\n    pub(super) exec: Exec,\n    h09_responses: bool,\n    h1_parser_config: ParserConfig,\n    h1_writev: Option<bool>,\n    h1_title_case_headers: bool,\n    h1_preserve_header_case: bool,\n    #[cfg(feature = \"ffi\")]\n    h1_preserve_header_order: bool,\n    h1_read_buf_exact_size: Option<usize>,\n    h1_max_buf_size: Option<usize>,\n    #[cfg(feature = \"ffi\")]\n    h1_headers_raw: bool,\n    #[cfg(feature = \"http2\")]\n    h2_builder: proto::h2::client::Config,\n    version: Proto,\n}"
    },
    {
        "crate": "hyper",
        "name": "GaiAddrs",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "client::connect::dns",
        "type": "struct",
        "signature": "struct GaiAddrs",
        "documentation": "An iterator of IP addresses returned from `getaddrinfo`.",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct GaiAddrs {\n    inner: SocketAddrs,\n}"
    },
    {
        "crate": "hyper",
        "name": "capture_connection",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "client::connect",
        "type": "function",
        "signature": "fn capture_connection(request: &mut crate::http::Request<B>) -> CaptureConnection",
        "documentation": "Capture the connection for a given request\n\nWhen making a request with Hyper, the underlying connection must implement the [`Connection`] trait.\n[`capture_connection`] allows a caller to capture the returned [`Connected`] structure as soon\nas the connection is established.\n\n*Note*: If establishing a connection fails, [`CaptureConnection::connection_metadata`] will always return none.\n\n# Examples\n\n**Synchronous access**:\nThe [`CaptureConnection::connection_metadata`] method allows callers to check if a connection has been\nestablished. This is ideal for situations where you are certain the connection has already\nbeen established (e.g. after the response future has already completed).\n```rust\nuse hyper::client::connect::{capture_connection, CaptureConnection};\nlet mut request = http::Request::builder()\n  .uri(\"http://foo.com\")\n  .body(())\n  .unwrap();\n\nlet captured_connection = capture_connection(&mut request);\n// some time later after the request has been sent...\nlet connection_info = captured_connection.connection_metadata();\nprintln!(\"we are connected! {:?}\", connection_info.as_ref());\n```\n\n**Asynchronous access**:\nThe [`CaptureConnection::wait_for_connection_metadata`] method returns a future resolves as soon as the\nconnection is available.\n\n```rust\n# #[cfg(feature  = \"runtime\")]\n# async fn example() {\nuse hyper::client::connect::{capture_connection, CaptureConnection};\nlet mut request = http::Request::builder()\n  .uri(\"http://foo.com\")\n  .body(hyper::Body::empty())\n  .unwrap();\n\nlet mut captured = capture_connection(&mut request);\ntokio::task::spawn(async move {\n    let connection_info = captured.wait_for_connection_metadata().await;\n    println!(\"we are connected! {:?}\", connection_info.as_ref());\n});\n\nlet client = hyper::Client::new();\nclient.request(request).await.expect(\"request failed\");\n# }\n```",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub fn capture_connection<B>(request: &mut crate::http::Request<B>) -> CaptureConnection {\n    let (tx, rx) = CaptureConnection::new();\n    request.extensions_mut().insert(tx);\n    rx\n}"
    },
    {
        "crate": "hyper",
        "name": "CaptureConnection",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "client::connect",
        "type": "struct",
        "signature": "struct CaptureConnection",
        "documentation": "[`CaptureConnection`] allows callers to capture [`Connected`] information\n\nTo capture a connection for a request, use [`capture_connection`].",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct CaptureConnection {\n    rx: watch::Receiver<Option<Connected>>,\n}"
    },
    {
        "crate": "hyper",
        "name": "TokioThreadpoolGaiFuture",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "client::connect::dns",
        "type": "struct",
        "signature": "struct TokioThreadpoolGaiFuture",
        "documentation": "The future returned by `TokioThreadpoolGaiResolver`.",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct TokioThreadpoolGaiFuture {\n    name: Name,\n}"
    },
    {
        "crate": "hyper",
        "name": "AddrIncoming",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "server::tcp",
        "type": "struct",
        "signature": "struct AddrIncoming",
        "documentation": "A stream of connections from binding to an address.",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct AddrIncoming {\n    addr: SocketAddr,\n    listener: TcpListener,\n    sleep_on_errors: bool,\n    tcp_keepalive_config: TcpKeepaliveConfig,\n    tcp_nodelay: bool,\n    timeout: Option<Pin<Box<Sleep>>>,\n}"
    },
    {
        "crate": "hyper",
        "name": "Parts",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "server::conn",
        "type": "struct",
        "signature": "struct Parts",
        "documentation": "Deconstructed parts of a `Connection`.\n\nThis allows taking apart a `Connection` at a later time, in order to\nreclaim the IO object, and additional related pieces.",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct Parts<T, S> {\n    /// The original IO object used in the handshake.\n    pub io: T,\n    /// A buffer of bytes that have been read but not processed as HTTP.\n    ///\n    /// If the client sent additional bytes after its last request, and\n    /// this connection \"ended\" with an upgrade, the read buffer will contain\n    /// those bytes.\n    ///\n    /// You will want to check for any existing bytes if you plan to continue\n    /// communicating on the IO object.\n    pub read_buf: Bytes,\n    /// The `Service` used to serve this connection.\n    pub service: S,\n    _inner: (),\n}"
    },
    {
        "crate": "hyper",
        "name": "ResponseFuture",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "client::conn",
        "type": "struct",
        "signature": "struct ResponseFuture",
        "documentation": "A future returned by `SendRequest::send_request`.\n\nYields a `Response` if successful.",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct ResponseFuture {\n    inner: ResponseFutureState,\n}"
    },
    {
        "crate": "hyper",
        "name": "Connected",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "client::connect",
        "type": "struct",
        "signature": "struct Connected",
        "documentation": "Extra information about the connected transport.\n\nThis can be used to inform recipients about things like if ALPN\nwas used, or if connected to an HTTP proxy.",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct Connected {\n    pub(super) alpn: Alpn,\n    pub(super) is_proxied: bool,\n    pub(super) extra: Option<Extra>,\n    pub(super) poisoned: PoisonPill,\n}"
    },
    {
        "crate": "hyper",
        "name": "ResponseFuture",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "client::client",
        "type": "struct",
        "signature": "struct ResponseFuture",
        "documentation": "A `Future` that will resolve to an HTTP Response.\n\nThis is returned by `Client::request` (and `Client::get`).",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct ResponseFuture {\n    inner: SyncWrapper<Pin<Box<dyn Future<Output = crate::Result<Response<Body>>> + Send>>>,\n}"
    },
    {
        "crate": "hyper",
        "name": "Name",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "client::connect::dns",
        "type": "struct",
        "signature": "struct Name",
        "documentation": "A domain name to resolve into IP addresses.",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct Name {\n    host: Box<str>,\n}"
    },
    {
        "crate": "hyper",
        "name": "GaiResolver",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "client::connect::dns",
        "type": "struct",
        "signature": "struct GaiResolver",
        "documentation": "A resolver using blocking `getaddrinfo` calls in a threadpool.",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct GaiResolver {\n    _priv: (),\n}"
    },
    {
        "crate": "hyper",
        "name": "Sender",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "body::body",
        "type": "struct",
        "signature": "struct Sender",
        "documentation": "A sender half created through [`Body::channel()`].\n\nUseful when wanting to stream chunks from another thread.\n\n## Body Closing\n\nNote that the request body will always be closed normally when the sender is dropped (meaning\nthat the empty terminating chunk will be sent to the remote). If you desire to close the\nconnection with an incomplete response (e.g. in the case of an error during asynchronous\nprocessing), call the [`Sender::abort()`] method to abort the body in an abnormal fashion.\n\n[`Body::channel()`]: struct.Body.html#method.channel\n[`Sender::abort()`]: struct.Sender.html#method.abort",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct Sender {\n    want_rx: watch::Receiver,\n    data_tx: BodySender,\n    trailers_tx: Option<TrailersSender>,\n}"
    },
    {
        "crate": "hyper",
        "name": "HttpInfo",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "client::connect::http",
        "type": "struct",
        "signature": "struct HttpInfo",
        "documentation": "Extra information about the transport when an HttpConnector is used.\n\n# Example\n\n```\n# async fn doc() -> hyper::Result<()> {\nuse hyper::Uri;\nuse hyper::client::{Client, connect::HttpInfo};\n\nlet client = Client::new();\nlet uri = Uri::from_static(\"http://example.com\");\n\nlet res = client.get(uri).await?;\nres\n    .extensions()\n    .get::<HttpInfo>()\n    .map(|info| {\n        println!(\"remote addr = {}\", info.remote_addr());\n    });\n# Ok(())\n# }\n```\n\n# Note\n\nIf a different connector is used besides [`HttpConnector`](HttpConnector),\nthis value will not exist in the extensions. Consult that specific\nconnector to see what \"extra\" information it might provide to responses.",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct HttpInfo {\n    remote_addr: SocketAddr,\n    local_addr: SocketAddr,\n}"
    },
    {
        "crate": "hyper",
        "name": "Client",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "client::client",
        "type": "struct",
        "signature": "struct Client",
        "documentation": "A Client to make outgoing HTTP requests.\n\n`Client` is cheap to clone and cloning is the recommended way to share a `Client`. The\nunderlying connection pool will be reused.",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct Client<C, B = Body> {\n    config: Config,\n    #[cfg_attr(feature = \"deprecated\", allow(deprecated))]\n    conn_builder: conn::Builder,\n    connector: C,\n    pool: Pool<PoolClient<B>>,\n}"
    },
    {
        "crate": "hyper",
        "name": "GaiFuture",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "client::connect::dns",
        "type": "struct",
        "signature": "struct GaiFuture",
        "documentation": "A future to resolve a name returned by `GaiResolver`.",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct GaiFuture {\n    inner: JoinHandle<Result<SocketAddrs, io::Error>>,\n}"
    },
    {
        "crate": "hyper",
        "name": "Body",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "body::body",
        "type": "struct",
        "signature": "struct Body",
        "documentation": "A stream of `Bytes`, used when receiving bodies.\n\nA good default [`HttpBody`](crate::body::HttpBody) to use in many\napplications.\n\nNote: To read the full body, use [`body::to_bytes`](crate::body::to_bytes())\nor [`body::aggregate`](crate::body::aggregate()).",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct Body {\n    kind: Kind,\n    /// Keep the extra bits in an `Option<Box<Extra>>`, so that\n    /// Body stays small in the common case (no extras needed).\n    extra: Option<Box<Extra>>,\n}"
    },
    {
        "crate": "hyper",
        "name": "Parts",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "client::conn",
        "type": "struct",
        "signature": "struct Parts",
        "documentation": "Deconstructed parts of a `Connection`.\n\nThis allows taking apart a `Connection` at a later time, in order to\nreclaim the IO object, and additional related pieces.",
        "change_type": "deprecated",
        "changenote": "API removed in version 1.5.1.",
        "old_source_code": "pub struct Parts<T> {\n    /// The original IO object used in the handshake.\n    pub io: T,\n    /// A buffer of bytes that have been read but not processed as HTTP.\n    ///\n    /// For instance, if the `Connection` is used for an HTTP upgrade request,\n    /// it is possible the server sent back the first bytes of the new protocol\n    /// along with the response upgrade.\n    ///\n    /// You will want to check for any existing bytes if you plan to continue\n    /// communicating on the IO object.\n    pub read_buf: Bytes,\n    _inner: (),\n}"
    },
    {
        "crate": "hyper",
        "name": "hyper_clientconn_options",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "ffi::client",
        "type": "struct",
        "signature": "struct hyper_clientconn_options",
        "documentation": "An options builder to configure an HTTP client connection.\n\nMethods:\n\n- hyper_clientconn_options_new:     Creates a new set of HTTP clientconn options to be used in a handshake.\n- hyper_clientconn_options_exec:    Set the client background task executor.\n- hyper_clientconn_options_http2:   Set whether to use HTTP2.\n- hyper_clientconn_options_set_preserve_header_case:  Set whether header case is preserved.\n- hyper_clientconn_options_set_preserve_header_order: Set whether header order is preserved.\n- hyper_clientconn_options_http1_allow_multiline_headers: Set whether HTTP/1 connections accept obsolete line folding for header values.\n- hyper_clientconn_options_free:    Free a set of HTTP clientconn options.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub struct hyper_clientconn_options {\n    builder: conn::Builder,\n    /// Use a `Weak` to prevent cycles.\n    exec: WeakExec,\n}",
        "source_code": "pub struct hyper_clientconn_options {\n    http1_allow_obsolete_multiline_headers_in_responses: bool,\n    http1_preserve_header_case: bool,\n    http1_preserve_header_order: bool,\n    http2: bool,\n    /// Use a `Weak` to prevent cycles.\n    exec: WeakExec,\n}"
    },
    {
        "crate": "hyper",
        "name": "OnUpgrade",
        "from_version": "0.14.32",
        "to_version": "1.5.1",
        "module": "upgrade",
        "type": "struct",
        "signature": "struct OnUpgrade",
        "documentation": "A future for a possible HTTP upgrade.\n\nIf no upgrade was available, or it doesn't succeed, yields an `Error`.",
        "change_type": "implicit",
        "changenote": "Implementation has changed while maintaining the same signature.",
        "old_source_code": "pub struct OnUpgrade {\n    rx: Option<oneshot::Receiver<crate::Result<Upgraded>>>,\n}",
        "source_code": "pub struct OnUpgrade {\n    rx: Option<Arc<Mutex<oneshot::Receiver<crate::Result<Upgraded>>>>>,\n}"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_XNET",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::dragonfly",
        "type": "constant",
        "old_signature": "const IPPROTO_XNET: ::c_int  = 15",
        "signature": "const IPPROTO_XNET: c_int  = 15",
        "documentation": "Cross Net Debugger",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_XNET: ::c_int  = 15' to 'const IPPROTO_XNET: c_int  = 15'.",
        "source_code": "pub const IPPROTO_XNET: c_int = 15;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_IDPR",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IPPROTO_IDPR: ::c_int  = 35",
        "signature": "const IPPROTO_IDPR: c_int  = 35",
        "documentation": "InterDomain Policy Routing",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_IDPR: ::c_int  = 35' to 'const IPPROTO_IDPR: c_int  = 35'.",
        "source_code": "pub const IPPROTO_IDPR: c_int = 35;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_PIM",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IPPROTO_PIM: ::c_int  = 103",
        "signature": "const IPPROTO_PIM: c_int  = 103",
        "documentation": "Protocol Independent Mcast",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_PIM: ::c_int  = 103' to 'const IPPROTO_PIM: c_int  = 103'.",
        "source_code": "pub const IPPROTO_PIM: c_int = 103;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_MPTCP",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::linux_like",
        "type": "constant",
        "old_signature": "const IPPROTO_MPTCP: ::c_int  = 262",
        "signature": "const IPPROTO_MPTCP: c_int  = 262",
        "documentation": "Multipath TCP",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_MPTCP: ::c_int  = 262' to 'const IPPROTO_MPTCP: c_int  = 262'.",
        "source_code": "pub const IPPROTO_MPTCP: c_int = 262;"
    },
    {
        "crate": "libc",
        "name": "DCCP_SERVICE_LIST_MAX_LEN",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::linux_like::linux",
        "type": "constant",
        "old_signature": "const DCCP_SERVICE_LIST_MAX_LEN: ::c_int  = 32",
        "signature": "const DCCP_SERVICE_LIST_MAX_LEN: c_int  = 32",
        "documentation": "maximum number of services provided on the same listening port",
        "change_type": "signature",
        "changenote": "Signature changed from 'const DCCP_SERVICE_LIST_MAX_LEN: ::c_int  = 32' to 'const DCCP_SERVICE_LIST_MAX_LEN: c_int  = 32'.",
        "source_code": "pub const DCCP_SERVICE_LIST_MAX_LEN: c_int = 32;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_HOPOPTS",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::dragonfly",
        "type": "constant",
        "old_signature": "const IPPROTO_HOPOPTS: ::c_int  = 0",
        "signature": "const IPPROTO_HOPOPTS: c_int  = 0",
        "documentation": "IP6 hop-by-hop options",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_HOPOPTS: ::c_int  = 0' to 'const IPPROTO_HOPOPTS: c_int  = 0'.",
        "source_code": "pub const IPPROTO_HOPOPTS: c_int = 0;"
    },
    {
        "crate": "libc",
        "name": "IFMIB_IFCOUNT",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IFMIB_IFCOUNT: ::c_int  = 1",
        "signature": "const IFMIB_IFCOUNT: c_int  = 1",
        "documentation": "number of interfaces configured",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IFMIB_IFCOUNT: ::c_int  = 1' to 'const IFMIB_IFCOUNT: c_int  = 1'.",
        "source_code": "pub const IFMIB_IFCOUNT: c_int = 1;"
    },
    {
        "crate": "libc",
        "name": "NCARGS",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const NCARGS: ::c_int  = ARG_MAX",
        "signature": "const NCARGS: c_int  = ARG_MAX",
        "documentation": "max bytes for an exec function",
        "change_type": "signature",
        "changenote": "Signature changed from 'const NCARGS: ::c_int  = ARG_MAX' to 'const NCARGS: c_int  = ARG_MAX'.",
        "source_code": "pub const NCARGS: c_int = ARG_MAX;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_TLSP",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::dragonfly",
        "type": "constant",
        "old_signature": "const IPPROTO_TLSP: ::c_int  = 56",
        "signature": "const IPPROTO_TLSP: c_int  = 56",
        "documentation": "Transport Layer Security",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_TLSP: ::c_int  = 56' to 'const IPPROTO_TLSP: c_int  = 56'.",
        "source_code": "pub const IPPROTO_TLSP: c_int = 56;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_SCTP",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IPPROTO_SCTP: ::c_int  = 132",
        "signature": "const IPPROTO_SCTP: c_int  = 132",
        "documentation": "SCTP",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_SCTP: ::c_int  = 132' to 'const IPPROTO_SCTP: c_int  = 132'.",
        "source_code": "pub const IPPROTO_SCTP: c_int = 132;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_COMP",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::linux_like",
        "type": "constant",
        "old_signature": "const IPPROTO_COMP: ::c_int  = 108",
        "signature": "const IPPROTO_COMP: c_int  = 108",
        "documentation": "IP Payload Comp. Protocol",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_COMP: ::c_int  = 108' to 'const IPPROTO_COMP: c_int  = 108'.",
        "source_code": "pub const IPPROTO_COMP: c_int = 108;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_IDPR",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::apple",
        "type": "constant",
        "old_signature": "const IPPROTO_IDPR: ::c_int  = 35",
        "signature": "const IPPROTO_IDPR: c_int  = 35",
        "documentation": "InterDomain Policy Routing",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_IDPR: ::c_int  = 35' to 'const IPPROTO_IDPR: c_int  = 35'.",
        "source_code": "pub const IPPROTO_IDPR: c_int = 35;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_SWIPE",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::apple",
        "type": "constant",
        "old_signature": "const IPPROTO_SWIPE: ::c_int  = 53",
        "signature": "const IPPROTO_SWIPE: c_int  = 53",
        "documentation": "IP with encryption",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_SWIPE: ::c_int  = 53' to 'const IPPROTO_SWIPE: c_int  = 53'.",
        "source_code": "pub const IPPROTO_SWIPE: c_int = 53;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_XTP",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IPPROTO_XTP: ::c_int  = 36",
        "signature": "const IPPROTO_XTP: c_int  = 36",
        "documentation": "XTP",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_XTP: ::c_int  = 36' to 'const IPPROTO_XTP: c_int  = 36'.",
        "source_code": "pub const IPPROTO_XTP: c_int = 36;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_RSVP",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::linux_like",
        "type": "constant",
        "old_signature": "const IPPROTO_RSVP: ::c_int  = 46",
        "signature": "const IPPROTO_RSVP: c_int  = 46",
        "documentation": "resource reservation",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_RSVP: ::c_int  = 46' to 'const IPPROTO_RSVP: c_int  = 46'.",
        "source_code": "pub const IPPROTO_RSVP: c_int = 46;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_MOBILE",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::dragonfly",
        "type": "constant",
        "old_signature": "const IPPROTO_MOBILE: ::c_int  = 55",
        "signature": "const IPPROTO_MOBILE: c_int  = 55",
        "documentation": "IP Mobility",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_MOBILE: ::c_int  = 55' to 'const IPPROTO_MOBILE: c_int  = 55'.",
        "source_code": "pub const IPPROTO_MOBILE: c_int = 55;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_HELLO",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::dragonfly",
        "type": "constant",
        "old_signature": "const IPPROTO_HELLO: ::c_int  = 63",
        "signature": "const IPPROTO_HELLO: c_int  = 63",
        "documentation": "\"hello\" routing protocol",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_HELLO: ::c_int  = 63' to 'const IPPROTO_HELLO: c_int  = 63'.",
        "source_code": "pub const IPPROTO_HELLO: c_int = 63;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_LEAF2",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IPPROTO_LEAF2: ::c_int  = 26",
        "signature": "const IPPROTO_LEAF2: c_int  = 26",
        "documentation": "Leaf-2",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_LEAF2: ::c_int  = 26' to 'const IPPROTO_LEAF2: c_int  = 26'.",
        "source_code": "pub const IPPROTO_LEAF2: c_int = 26;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_AX25",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::apple",
        "type": "constant",
        "old_signature": "const IPPROTO_AX25: ::c_int  = 93",
        "signature": "const IPPROTO_AX25: c_int  = 93",
        "documentation": "AX.25 Frames",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_AX25: ::c_int  = 93' to 'const IPPROTO_AX25: c_int  = 93'.",
        "source_code": "pub const IPPROTO_AX25: c_int = 93;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_EON",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::apple",
        "type": "constant",
        "old_signature": "const IPPROTO_EON: ::c_int  = 80",
        "signature": "const IPPROTO_EON: c_int  = 80",
        "documentation": "ISO cnlp",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_EON: ::c_int  = 80' to 'const IPPROTO_EON: c_int  = 80'.",
        "source_code": "pub const IPPROTO_EON: c_int = 80;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_GRE",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "fuchsia",
        "type": "constant",
        "old_signature": "const IPPROTO_GRE: ::c_int  = 47",
        "signature": "const IPPROTO_GRE: c_int  = 47",
        "documentation": "General Routing Encap.",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_GRE: ::c_int  = 47' to 'const IPPROTO_GRE: c_int  = 47'.",
        "source_code": "pub const IPPROTO_GRE: c_int = 47;"
    },
    {
        "crate": "libc",
        "name": "OPEN_MAX",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const OPEN_MAX: ::c_int  = 64",
        "signature": "const OPEN_MAX: c_int  = 64",
        "documentation": "max open files per process",
        "change_type": "signature",
        "changenote": "Signature changed from 'const OPEN_MAX: ::c_int  = 64' to 'const OPEN_MAX: c_int  = 64'.",
        "source_code": "pub const OPEN_MAX: c_int = 64;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_BHA",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::apple",
        "type": "constant",
        "old_signature": "const IPPROTO_BHA: ::c_int  = 49",
        "signature": "const IPPROTO_BHA: c_int  = 49",
        "documentation": "BHA",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_BHA: ::c_int  = 49' to 'const IPPROTO_BHA: c_int  = 49'.",
        "source_code": "pub const IPPROTO_BHA: c_int = 49;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_MOBILE",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::netbsdlike::netbsd",
        "type": "constant",
        "old_signature": "const IPPROTO_MOBILE: ::c_int  = 55",
        "signature": "const IPPROTO_MOBILE: c_int  = 55",
        "documentation": "IP Mobility RFC 2004",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_MOBILE: ::c_int  = 55' to 'const IPPROTO_MOBILE: c_int  = 55'.",
        "source_code": "pub const IPPROTO_MOBILE: c_int = 55;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_AH",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::linux_like",
        "type": "constant",
        "old_signature": "const IPPROTO_AH: ::c_int  = 51",
        "signature": "const IPPROTO_AH: c_int  = 51",
        "documentation": "IP6 Auth Header",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_AH: ::c_int  = 51' to 'const IPPROTO_AH: c_int  = 51'.",
        "source_code": "pub const IPPROTO_AH: c_int = 51;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_NONE",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IPPROTO_NONE: ::c_int  = 59",
        "signature": "const IPPROTO_NONE: c_int  = 59",
        "documentation": "IP6 no next header",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_NONE: ::c_int  = 59' to 'const IPPROTO_NONE: c_int  = 59'.",
        "source_code": "pub const IPPROTO_NONE: c_int = 59;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_SCCSP",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::apple",
        "type": "constant",
        "old_signature": "const IPPROTO_SCCSP: ::c_int  = 96",
        "signature": "const IPPROTO_SCCSP: c_int  = 96",
        "documentation": "Semaphore Comm. security",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_SCCSP: ::c_int  = 96' to 'const IPPROTO_SCCSP: c_int  = 96'.",
        "source_code": "pub const IPPROTO_SCCSP: c_int = 96;"
    },
    {
        "crate": "libc",
        "name": "IFCAP_TXTLS_RTLMT",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IFCAP_TXTLS_RTLMT: ::c_int  = 0x80000000",
        "signature": "const IFCAP_TXTLS_RTLMT: c_int  = 0x80000000",
        "documentation": "can do TLS with rate limiting",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IFCAP_TXTLS_RTLMT: ::c_int  = 0x80000000' to 'const IFCAP_TXTLS_RTLMT: c_int  = 0x80000000'.",
        "source_code": "pub const IFCAP_TXTLS_RTLMT: c_int = 0x80000000;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_XNET",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IPPROTO_XNET: ::c_int  = 15",
        "signature": "const IPPROTO_XNET: c_int  = 15",
        "documentation": "Cross Net Debugger",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_XNET: ::c_int  = 15' to 'const IPPROTO_XNET: c_int  = 15'.",
        "source_code": "pub const IPPROTO_XNET: c_int = 15;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_TP",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IPPROTO_TP: ::c_int  = 29",
        "signature": "const IPPROTO_TP: c_int  = 29",
        "documentation": "tp-4 w/ class negotiation",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_TP: ::c_int  = 29' to 'const IPPROTO_TP: c_int  = 29'.",
        "source_code": "pub const IPPROTO_TP: c_int = 29;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_HELLO",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IPPROTO_HELLO: ::c_int  = 63",
        "signature": "const IPPROTO_HELLO: c_int  = 63",
        "documentation": "\"hello\" routing protocol",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_HELLO: ::c_int  = 63' to 'const IPPROTO_HELLO: c_int  = 63'.",
        "source_code": "pub const IPPROTO_HELLO: c_int = 63;"
    },
    {
        "crate": "libc",
        "name": "IFDATA_DRIVERNAME",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IFDATA_DRIVERNAME: ::c_int  = 3",
        "signature": "const IFDATA_DRIVERNAME: c_int  = 3",
        "documentation": "driver name and unit",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IFDATA_DRIVERNAME: ::c_int  = 3' to 'const IFDATA_DRIVERNAME: c_int  = 3'.",
        "source_code": "pub const IFDATA_DRIVERNAME: c_int = 3;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_HMP",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::apple",
        "type": "constant",
        "old_signature": "const IPPROTO_HMP: ::c_int  = 20",
        "signature": "const IPPROTO_HMP: c_int  = 20",
        "documentation": "Host Monitoring",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_HMP: ::c_int  = 20' to 'const IPPROTO_HMP: c_int  = 20'.",
        "source_code": "pub const IPPROTO_HMP: c_int = 20;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_TP",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::netbsdlike::openbsd",
        "type": "constant",
        "old_signature": "const IPPROTO_TP: ::c_int  = 29",
        "signature": "const IPPROTO_TP: c_int  = 29",
        "documentation": "tp-4 w/ class negotiation",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_TP: ::c_int  = 29' to 'const IPPROTO_TP: c_int  = 29'.",
        "source_code": "pub const IPPROTO_TP: c_int = 29;"
    },
    {
        "crate": "libc",
        "name": "IFF_ALLMULTI",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IFF_ALLMULTI: ::c_int  = 0x200",
        "signature": "const IFF_ALLMULTI: c_int  = 0x200",
        "documentation": "(n) receive all multicast packets",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IFF_ALLMULTI: ::c_int  = 0x200' to 'const IFF_ALLMULTI: c_int  = 0x200'.",
        "source_code": "pub const IFF_ALLMULTI: c_int = 0x200;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_IDP",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::linux_like",
        "type": "constant",
        "old_signature": "const IPPROTO_IDP: ::c_int  = 22",
        "signature": "const IPPROTO_IDP: c_int  = 22",
        "documentation": "xns idp",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_IDP: ::c_int  = 22' to 'const IPPROTO_IDP: c_int  = 22'.",
        "source_code": "pub const IPPROTO_IDP: c_int = 22;"
    },
    {
        "crate": "libc",
        "name": "IFF_POINTOPOINT",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IFF_POINTOPOINT: ::c_int  = 0x10",
        "signature": "const IFF_POINTOPOINT: c_int  = 0x10",
        "documentation": "(i) is a point-to-point link",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IFF_POINTOPOINT: ::c_int  = 0x10' to 'const IFF_POINTOPOINT: c_int  = 0x10'.",
        "source_code": "pub const IFF_POINTOPOINT: c_int = 0x10;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_IPCOMP",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::netbsdlike::netbsd",
        "type": "constant",
        "old_signature": "const IPPROTO_IPCOMP: ::c_int  = 108",
        "signature": "const IPPROTO_IPCOMP: c_int  = 108",
        "documentation": "IP Payload Comp. Protocol",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_IPCOMP: ::c_int  = 108' to 'const IPPROTO_IPCOMP: c_int  = 108'.",
        "source_code": "pub const IPPROTO_IPCOMP: c_int = 108;"
    },
    {
        "crate": "libc",
        "name": "IPPROTO_ST",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::freebsdlike::freebsd",
        "type": "constant",
        "old_signature": "const IPPROTO_ST: ::c_int  = 7",
        "signature": "const IPPROTO_ST: c_int  = 7",
        "documentation": "Stream protocol II.",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IPPROTO_ST: ::c_int  = 7' to 'const IPPROTO_ST: c_int  = 7'.",
        "source_code": "pub const IPPROTO_ST: c_int = 7;"
    },
    {
        "crate": "libc",
        "name": "IFDATA_MULTIADDRS",
        "from_version": "0.2.166",
        "to_version": "0.2.167",
        "module": "unix::bsd::apple",
        "type": "constant",
        "old_signature": "const IFDATA_MULTIADDRS: ::c_int  = 4",
        "signature": "const IFDATA_MULTIADDRS: c_int  = 4",
        "documentation": "Multicast addresses assigned to interface",
        "change_type": "signature",
        "changenote": "Signature changed from 'const IFDATA_MULTIADDRS: ::c_int  = 4' to 'const IFDATA_MULTIADDRS: c_int  = 4'.",
        "source_code": "pub const IFDATA_MULTIADDRS: c_int = 4;"
    }
]